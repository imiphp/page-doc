var originSearchDatas = [{"id":260,"title":"断点调试","pageTitle":"断点调试","url":"adv/debug.html","content":"断点调试目录XDebugPHP &gt;= 8.1 &amp; Swoole &gt;= 5.0.2 已经完全支持了 XDebug 断点调试，如果你正在使用老版本请升级后使用。YasdSwoole 开发组成员 @codinghuang 开发了一个新的调试扩展，名为 Yasd ，另一个 Swoole 调试器。众所周知，xdebug 原生对 Swoole 并不兼容，并且代码难以维护，所以才有了 Yasd！Yasd 完全兼容 xdebug 协议，你可以在任何支持 xdebug 的 IDE 中以同样的方式使用 Yasd 进行单步调试。Yasd 地址：https://github.com/swoole/yasd"},{"id":7,"title":"参与框架开发","pageTitle":"参与框架开发","url":"adv/devp.html","content":"参与框架开发目录仓库Github：https://github.com/imiphp/imi分支分支说明2.1v2.1.x 版本分支2.0v2.0.x 版本分支1.xv1.3.x 版本分支目录结构├── .github             // Github 相关文件\n├── config              // 框架核心配置文件目录\n├── dev                 // 开发用脚本目录\n├── doc                 // 文档 markdown 源文件\n├── mddoc               // 文档 html 模版\n├── res                 // 资源文件\n├── split-repository    // 组件发版工具\n├── src                 // PHP 源代码\n├── tests               // 测试用例目录\n└── website             // 官网 Html 源代码PR 基本操作在 Github 的 imi 页面点击 fork 按钮，将项目复刻到你自己名下。将代码拉到本地，在你想要合并的分支基础上创建一个用于此次贡献的分支。此次贡献的代码都提交到上一步创建的分支中。在 Github 的 imi 页面点击 Pull requests，然后点击 New pull request 把你修改的分支申请合并。参考：https://zhuanlan.zhihu.com/p/584834288https://zhuanlan.zhihu.com/p/540082562参与方式文档imi 的文档是用 markdown 编写，使用 mddoc 将 markdown 转换为 html 用于访问。文档源代码在 imi 仓库中的 doc 目录，mddoc 的 html 模版在 mddoc 目录中。你可以帮助完善文档，包括但不限于修正错别字、补充文档说明、贡献示例代码等。代码imi 完全使用 PHP 开发，一个稍微有点能力的 PHP 开发者，应该都可以参与进来。你可以帮助 imi 变得更好更强大，包括但不限于修复 BUG、贡献新功能等。贡献代码需要能跑通原有测试用例，并且为新增功能特性编写测试用例。关于测试用例环境要求Redis、MySQL首次运行测试执行 tests/db/install-db.sh 导入数据库表结构配置系统环境变量，如果默认值跟你的一样就无需配置了名称描述默认值SERVER_HOST测试用的服务，监听的主机名127.0.0.1MYSQL_SERVER_HOSTMySQL 主机名127.0.0.1MYSQL_SERVER_PORTMySQL 端口3306MYSQL_SERVER_USERNAMEMySQL 用户名rootMYSQL_SERVER_PASSWORDMySQL 密码rootREDIS_SERVER_HOSTRedis 主机名127.0.0.1REDIS_SERVER_PORTRedis 端口6379REDIS_SERVER_PASSWORDRedis 密码 REDIS_CACHE_DBRedis 缓存用的 db，该 db 会被清空数据，请慎重设置1配置命令：export NAME=VALUE首次运行测试脚本：composer install-test首次之后再运行测试的命令：composer testGithub Action通过 git push 代码后，查看 Gtihub Action 中的自动化测试结果。官方网站imi 官方网站 (https://www.imiphp.com) 的源代码在 imi 仓库中的 website 目录中。你可以帮助完善官网说明，如果你有更好设计想法，也可以与我们沟通或者直接贡献代码。"},{"id":261,"title":"生产环境性能优化","pageTitle":"生产环境性能优化","url":"adv/performance.html","content":"生产环境性能优化目录imi 为性能做了以下努力：框架核心运行时缓存项目运行时缓存热更新重启采用增量方式数据库 Statement 复用减少不必要的注入处理使用框架核心运行时缓存+热更新重启采用增量方式，我们的实际项目原本重启需要 6 秒，现在只需几毫秒，提升可谓是巨大的。使用项目运行时缓存后，每次启动和热重启worker进程时，硬盘读写压力不再巨大。我们将持续为性能优化，为可靠性优化。上面提到的框架核心运行时缓存需要在开发时手动生成，并且如果更新框架需要手动进行清除并重新生成。项目配置文件中，设置：[\n    &#039;debug&#039; =&gt; false,\n]当然你也可以在项目 Main 文件中，设置 imi 为非 debug 模式：\\Imi\\App::setDebug(false);"},{"id":"645b0aa9bd90a9.70985846","title":"","pageTitle":"","url":"adv/README.html","content":""},{"id":32,"title":"编写自定义注解","pageTitle":"编写自定义注解","url":"annotations/annotation.html","content":"编写自定义注解目录imi 框架的注解是一种通过在代码中添加特定格式的注释，来实现对应功能的机制。PHP 8.0 开始原生支持属性注解，也就是通过在类属性上加上 #[\\Attribute] 注解来定义属性注解，然后在需要使用的地方使用对应的注解类来对属性进行注解。这使得在使用 PHP 8.0 及以上版本的项目中，使用注解更加方便。在 imi 框架中，使用注解可以实现很多功能。比如：路由、模型定义、事务、缓存等等除了内置的注解以外，如果编写属于自己的注解呢？这篇教程就来教大家来编写属于自己的注解。注解定义注解扫描imi 是常驻内存运行的框架，因此在冷启动时会采用全量扫描的方式来实现注解缓存。在使用时，就像读取配置一样简单高效。注解类每个注解都是一个类。注解类需要继承\\Imi\\Bean\\Annotation\\Base类&lt;?php\nnamespace ImiApp\\Annotation;\n\nuse Imi\\Bean\\Annotation\\Base;\nuse Imi\\Bean\\Annotation\\Parser;\n\n/**\n * 示例注解\n * @Annotation\n * @Target(&quot;METHOD&quot;)\n * @Parser(&quot;\\Imi\\Bean\\Parser\\NullParser&quot;)\n *\n * // 下面是IDE提示注释\n * @property string $name 随便定义的属性\n * @property int $age 随便定义的属性\n */\n// 下面的是原生注解定义\n#[\\Attribute(\\Attribute::TARGET_METHOD)]\nclass MyAnnotation extends Base\n{\n    /**\n     * 只传一个参数时的参数名\n     * @var string|null\n     */\n    protected ?string $defaultFieldName = &#039;name&#039;;\n\n    /**\n     * 构造方法里定义注解的属性，并且设置默认值\n     */\n    public function __construct(?array $__data = null, string $name = &#039;&#039;, int $age = 0)\n    {\n        parent::__construct(...\\func_get_args());\n    }\n}defaultFieldName定义的参数名，在你使用注解时候，如果只传这一个参数，可以省略参数名写在类上的：@Annotation注解，表示当前类是注解类。@Target注解，表示当前注解可以写在什么上面。可选：CLASS、METHOD、PROPERTY、CONST。支持传多个的写法：@Target({&quot;CLASS&quot;, &quot;METHOD&quot;, &quot;PROPERTY&quot;, &quot;CONST&quot;})@Parser注解，指定扫描注解时候的处理器，可以不写该注解，或者填写&quot;\\Imi\\Bean\\Parser\\NullParser&quot;即可，详见下文编写处理器注解使用由于注解是一个类，所以使用注解需要use它&lt;?php\nnamespace ImiApp\\Test;\n\nuse ImiApp\\Annotation\\MyAnnotation;\n\n#[Bean([&#039;Test&#039;])]\nclass Test\n{\n    /**\n     * @MyAnnotation(&quot;a&quot;)\n     * @MyAnnotation(name=&quot;b&quot;, age=11)\n     */\n    // 下面是原生注解用法\n    #[MyAnnotation(name: &#039;a&#039;)]\n    #[MyAnnotation(name: &#039;b&#039;, age: 11)]\n    public function aaa()\n    {\n\n    }\n\n}注入注解imi 中可以注入带有注解的方法。编写 AOP 类：namespace ImiApp\\Aop;\n\nuse Imi\\Aop\\Annotation\\Aspect;\nuse Imi\\Aop\\Annotation\\PointCut;\nuse Imi\\Aop\\PointCutType;\nuse Imi\\Aop\\AroundJoinPoint;\n\n/**\n * @Aspect\n */\nclass TransactionAop\n{\n    /**\n     * 自动事务支持\n     * @PointCut(\n     *         type=PointCutType::ANNOTATION,\n     *         allow={\n     *             \\ImiApp\\Annotation\\MyAnnotation::class\n     *         }\n     * )\n     * @Around\n     * @return mixed\n     */\n    public function parseTransaction(AroundJoinPoint $joinPoint)\n    {\n        // 前置操作\n\n        // 执行原方法，获取返回值\n        $result = $joinPoint-&gt;proceed($args);\n        // 执行原方法，获取返回值（方法返回值是引用返回时）\n        // $result = $joinPoint-&gt;proceed($args, true);\n        // 后置操作\n\n        // 返回返回值，如有必要你也可以自己决定其他返回值\n        return $result;\n    }\n}具体用法请参考：https://doc.imiphp.com/v2.1/components/aop/index.html获取注解具体用法请参考：https://doc.imiphp.com/v2.1/annotations/annotationManager.html编写处理器一般如果没有特殊需求，可以不写处理器。&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Imi\\Bean\\Parser;\n\nclass MyParser extends \\Imi\\Bean\\Parser\\BaseParser\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function parse(\\Imi\\Bean\\Annotation\\Base $annotation, string $className, string $target, string $targetName): void\n    {\n        var_dump($annotation); // 注解对象\n        var_dump($className); // 注解所在类名\n        var_dump($target); // 注解所在目标，self::TARGET_XXX 常量\n        var_dump($targetName); // 注解所在目标名称。例：如果在方法上，就是方法名\n\n        // YourManager::set(); // 可选：你可以将处理后的数据，写入一个你自定义的静态类中，这个类没有硬性规定，随便你怎么写\n    }\n}如果你希望把在处理器中存储的数据存到 runtime 缓存，可以在项目的 Main 类中监听事件来实现。&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace ImiApp;\n\nuse Imi\\Event\\Event;\nuse Imi\\Event\\EventParam;\nuse Imi\\Log\\Log;\n\nclass Main extends \\Imi\\Main\\AppBaseMain\n{\n    public function __init(): void\n    {\n        // 监听读取 Runtime 缓存\n        Event::on(&#039;IMI.LOAD_RUNTIME_INFO&#039;, function (EventParam $e) {\n            $cacheName = $e-&gt;getData()[&#039;cacheName&#039;]; // 缓存名称\n            $data = $e-&gt;getData()[&#039;data&#039;]; // 数组\n            YourManager::setData($data[&#039;myData&#039;] ?? []); // 从 runtime 缓存读取到管理类里，myData 是自定义键名，可以换为别的\n        });\n        // 监听构建 Runtime 缓存\n        Event::on(&#039;IMI.BUILD_RUNTIME&#039;, function (EventParam $e) {\n            $cacheName = $e-&gt;getData()[&#039;cacheName&#039;]; // 缓存名称\n            $data = $e-&gt;getData()[&#039;data&#039;]; // 数组\n            $data[&#039;myData&#039;] = YourManager::getData(); // 写入 runtime 缓存，myData 是自定义键名，可以换为别的\n        });\n    }\n}"},{"id":33,"title":"注解管理器","pageTitle":"注解管理器","url":"annotations/annotationManager.html","content":"注解管理器目录imi 中内置了一个注解管理器，通过它可以轻松获取到类、方法、属性、常量中的注解。类：\\Imi\\Bean\\Annotation\\AnnotationManager用法获取注解使用点AnnotationManager::getAnnotationPoints($annotationClassName, $where = null): array参数名称说明annotationClassName注解类名where使用点，默认为null不限制。可选：class/method/property/constant返回：注解数组获取类注解AnnotationManager::getClassAnnotations($className, $annotationClassName = null): array参数名称说明className目标类名annotationClassName想要获取的注解类类名，为null则不限制返回：注解数组获取方法注解AnnotationManager::getMethodAnnotations($className, $methodName, $annotationClassName = null): array参数名称说明className目标类名methodName目标方法名annotationClassName想要获取的注解类类名，为null则不限制返回：注解数组获取属性注解AnnotationManager::getPropertyAnnotations($className, $propertyName, $annotationClassName = null): array参数名称说明className目标类名propertyName目标属性名annotationClassName想要获取的注解类类名，为null则不限制返回：注解数组获取常量注解AnnotationManager::getConstantAnnotations($className, $constantName, $annotationClassName = null): array参数名称说明className目标类名constantName目标常量名annotationClassName想要获取的注解类类名，为null则不限制返回：注解数组获取一个类中所有包含指定注解的方法AnnotationManager::getMethodsAnnotations($className, $annotationClassName = null): array参数名称说明className目标类名annotationClassName想要获取的注解类类名，为null则不限制返回：[\n    &#039;方法名&#039;    =&gt;  [\n        // 注解数组\n    ],\n]获取一个类中所有包含指定注解的属性AnnotationManager::getPropertiesAnnotations($className, $annotationClassName = null): array参数名称说明className目标类名annotationClassName想要获取的注解类类名，为null则不限制返回：[\n    &#039;属性名&#039;    =&gt;  [\n        // 注解数组\n    ],\n]获取一个类中所有包含指定注解的常量AnnotationManager::getConstantsAnnotations($className, $annotationClassName = null): array参数名称说明className目标类名annotationClassName想要获取的注解类类名，为null则不限制返回：[\n    &#039;常量名&#039;    =&gt;  [\n        // 注解数组\n    ],\n]"},{"id":31,"title":"方法参数过滤器","pageTitle":"方法参数过滤器","url":"annotations/filterArg.html","content":"方法参数过滤器目录imi 框架的方法参数过滤器是一种方便开发者在框架层面对方法参数进行过滤的机制。注解说明@FilterArg属性名称说明name参数名filter过滤器callable用法示例简单使用：/*\n * @FilterArg(name=&quot;data&quot;, filter=&quot;json_decode&quot;)\n */\npublic function test($data)\n{\n    var_dump($data); // 这是一个stdClass对象\n}\n\n$obj-&gt;test(&#039;{&quot;id&quot;:1, &quot;message&quot;: &quot;imi nb!&quot;}&#039;);复杂用法：结合@Callback、@Inject注解使用，支持使用bean中的方法。/**\n * @Bean(&quot;XXX&quot;)\n */\nclass TestXXX\n{\n    public function decode($data)\n    {\n        return json_decode($data, true);\n    }\n}\n\n/*\n * @FilterArg(name=&quot;data&quot;, filter=@Callback(\n *     class=@Inject(&quot;XXX&quot;),\n *     method=&quot;decode&quot;\n * ))\n */\npublic function test($data)\n{\n    var_dump($data); // 这是一个数组\n}\n\n$obj-&gt;test(&#039;{&quot;id&quot;:1, &quot;message&quot;: &quot;imi nb!&quot;}&#039;);"},{"id":30,"title":"注入值注解","pageTitle":"注入值注解","url":"annotations/injectValue.html","content":"注入值注解目录在 imi 框架中，提供了一类特殊的注解，称为“注入值注解”，这些注解允许将值动态注入到注解的属性中。通过这种方式，可以在运行时动态地将一些值注入到注解属性中，而不是在编写代码时硬编码这些值。这样可以更加灵活地配置代码的行为，减少硬编码造成的代码耦合和维护成本。注解说明@ConstValue从常量中读取值属性名称说明name常量名default常量不存在时，返回的默认值@ConfigValue从配置中读取值属性名称说明name配置名，支持@app、@currentServer等用法default配置不存在时，返回的默认值@EnvValue从环境变量中读取值属性名称说明name环境变量名称default配置不存在时，返回的默认值@Inject对象注入，使用：App::getBean()属性名称说明nameBean名称或类名argsBean实例化参数@RequestInject对象注入，使用：RequestContext::getBean()同@Inject@Callback回调注解属性名称说明class类名，或者传入对象，比如可以使用 @Inject、@RequestInject 再次值注入method方法名用法示例/*\n * @Cacheable(\n *   key=&quot;index:{page}&quot;,\n *   ttl=10,\n *   lockable=@Lockable(\n *     id=&quot;index:{page}&quot;,\n *     waitTimeout=999999,\n *   ),\n *   preventBreakdown=true,\n * )\n */@DbInject注入数据库对象属性名称说明name连接池名，如果为null则取配置@app.db.defaultPoolqueryType查询类型，影响读写分离逻辑。可选：QueryType::READ/QueryType::WRITE，默认为QueryType::WRITE@RedisInject注入Redis对象属性名称说明name连接池名，如果为null则取配置@app.redis.defaultPool@PoolResource注入连接池资源属性名称说明name连接池名"},{"id":34,"title":"注解相关问题","pageTitle":"注解相关问题","url":"annotations/qa.html","content":"注解相关问题目录本页列出注解相关常见问题，欢迎大家补充。如何忽略一些我不想被扫描到的类？在项目配置文件中配置：return [\n    // 忽略扫描的命名空间\n    &#039;ignoreNamespace&#039;   =&gt;  [\n        &#039;Imi\\Test\\Component\\Annotation\\A\\*&#039;,    // 忽略扫描该命名空间下所有类\n        &#039;Imi\\Test\\Component\\Annotation\\B\\TestB&#039;,// 忽略该类\n    ],\n    // 全局忽略扫描的目录\n    &#039;ignorePaths&#039; =&gt; [\n        &#039;绝对路径，可包含通配符*&#039;,\n    ],\n    // 仅扫描项目时忽略扫描的目录\n    &#039;appIgnorePaths&#039; =&gt; [\n        &#039;绝对路径，可包含通配符*&#039;,\n    ],\n]怎样忽略扫描指定注解在项目的 Main.php 中写入：&lt;?php\nnamespace ImiApp;\n\nuse Imi\\Main\\AppBaseMain;\nuse Yurun\\Doctrine\\Common\\Annotations\\AnnotationReader;\n\nclass Main extends AppBaseMain\n{\n    public function __init(): void\n    {\n        AnnotationReader::addGlobalIgnoredName(&#039;xxx&#039;);\n    }\n\n}"},{"id":3,"title":"开发者社区","pageTitle":"开发者社区","url":"base/community.html","content":"开发者社区目录Githubissue: https://github.com/imiphp/imi/issues支持：问答、反馈bug、功能建议、贡献代码QQ 群imi框架交流群：17916227支持：问答、交流微信群请注明来意：支持：问答、交流"},{"id":10,"title":"应用配置","pageTitle":"应用配置","url":"base/config.html","content":"应用配置目录配置分为：环境变量、项目配置和服务器配置。环境变量 是通过环境变量指定的配置，一般是在框架加载完成前就要使用的配置，会采用环境变量的形式。项目配置 是一些公共的配置，会影响整个项目。服务器配置 是针对指定服务器，比如你写的某个 Http 服务的一些特别配置，可以在里面配置一些服务器相关的设置。imi 还支持你在项目根目录下，建立一个.env文件，在里面设置运行环境配置。环境变量变量名称描述默认值IMI_MACRO_OUTPUT_DIR宏定义文件处理后的输出目录，生成文件名格式：md5(原文件完成路径).php空字符串IMI_MACRO_LOCK_FILE_DIR宏定义文件锁目录。当项目文件放置在，共享目录等不支持文件锁的文件系统时，可以配置一个支持文件锁的目录。比如：/tmp空字符串环境变量可以配置在系统中也可以在运行命令时指定：IMI_MACRO_LOCK_FILE_DIR=/tmp vendor/bin/imi-swoole swoole/start配置文件结构共有结构&lt;?php\nreturn [\n    // 项目命名空间，即将在 imi 3.0 废弃，改为 composer.json 中配置，详见下文\n    &#039;namespace&#039; =&gt; &#039;ImiApp&#039;,\n\n    // 加载子配置文件，可以使用 \\Imi\\Config::get(&#039;@app.别名1.xxx&#039;) 获取\n    &#039;configs&#039;    =&gt;    [\n        &quot;别名1&quot;    =&gt;    &#039;配置文件路径1&#039;,\n        &quot;别名2&quot;    =&gt;    &#039;配置文件路径2&#039;,\n        ……\n    ],\n\n    // 如果配置了 configs.别名1，这里的值会被上面的文件覆盖\n    &#039;别名1&#039; =&gt; [],\n\n    // bean扫描目录，指定命名空间，建议省略\n    // &#039;beanScan&#039;    =&gt;    [\n    //     &#039;ImiDemo\\WebSocketDemo\\Listener&#039;,\n    // ],\n\n    // 日志配置，详见日志文档\n    &#039;logger&#039; =&gt; [],\n\n    // imi 核心配置，一般可以省略\n    &#039;imi&#039; =&gt; [\n        // 运行时缓存配置\n        &#039;runtime&#039; =&gt; [\n            // --- bean 相关缓存开始 ---\n            &#039;bean&#039; =&gt; true, // 启用 bean 相关缓存，如果为false，则下面的配置无效\n            &#039;annotation_parser_data&#039; =&gt; true, // 处理器存储数据缓存\n            &#039;annotation_parser_parsers&#039; =&gt; true, // 处理器数据缓存\n            &#039;annotation_manager_annotations&#039; =&gt; true, // 注解缓存\n            &#039;annotation_manager_annotation_relation&#039; =&gt; true, // 注解关联缓存\n            &#039;partial&#039; =&gt; true, // partial 缓存\n            // --- bean 相关缓存结束 ---\n\n            &#039;cli&#039; =&gt; true, // 命令行缓存\n            &#039;route&#039; =&gt; true, // 路由缓存\n            &#039;enum&#039; =&gt; true, // 枚举类缓存\n            &#039;event&#039; =&gt; true, // 事件缓存\n\n            // swoole 相关\n            &#039;swoole&#039; =&gt; [\n                &#039;process&#039; =&gt; true, // 进程缓存\n            ],\n\n            // workerman 相关\n            &#039;workerman&#039; =&gt; [\n                &#039;process&#039; =&gt; true, // 进程缓存\n            ]\n        ],\n        &#039;Timer&#039; =&gt; &#039;&#039;, // 定时器类名，详见定时器文档\n        // 服务器容器绑定\n        &#039;beans&#039; =&gt; [\n            &#039;ServerUtil&#039; =&gt; &#039;&#039;, // 服务器工具类类名，详见服务器工具类文档\n            // 其它自定义\n            &#039;aaa&#039; =&gt; XXX::class,\n        ],\n        // ide 助手文件生成\n        &#039;ideHelper&#039; =&gt; null, // 是否生成IDE助手文件，如果为`null`则依据`App::isDebug()`决定\n    ],\n\n    // 统一的服务器配置\n    &#039;server&#039; =&gt; [\n        // 启动服务时，检查连接池连接或非连接池连接是否可用。如不可用直接退出程序。\n        &#039;checkPoolResource&#039; =&gt; false,\n    ],\n];Swoole 项目配置文件return [\n    // 忽略扫描的命名空间\n    &#039;ignoreNamespace&#039;   =&gt;  [\n        &#039;Imi\\Test\\Component\\Annotation\\A\\*&#039;,    // 忽略扫描该命名空间下所有类\n        &#039;Imi\\Test\\Component\\Annotation\\B\\TestB&#039;,// 忽略该类\n    ],\n    // 全局忽略扫描的目录\n    &#039;ignorePaths&#039; =&gt; [\n        &#039;绝对路径，可包含通配符*&#039;,\n    ],\n    // 仅扫描项目时忽略扫描的目录\n    &#039;appIgnorePaths&#039; =&gt; [\n        &#039;绝对路径，可包含通配符*&#039;,\n    ],\n    // Swoole &gt;= 4.1.0可用，不设置默认为true，开启一键协程化\n    &#039;enableCoroutine&#039;    =&gt;    true,\n    // runtime目录设置，默认可不设置，为当前项目下的.runtime目录\n    // 注意，多个项目不可设置为相同目录！\n    &#039;runtimePath&#039;   =&gt;  &#039;/tmp/imidemo-runtime/&#039;,\n    // 定义进程名规则\n    &#039;process&#039;   =&gt;  [\n        &#039;master&#039;        =&gt;  &#039;imi:master:{namespace}&#039;,\n        &#039;manager&#039;       =&gt;  &#039;imi:manager:{namespace}&#039;,\n        &#039;worker&#039;        =&gt;  &#039;imi:worker-{workerId}:{namespace}&#039;,\n        &#039;taskWorker&#039;    =&gt;  &#039;imi:taskWorker-{workerId}:{namespace}&#039;,\n        &#039;process&#039;       =&gt;  &#039;imi:process-{processName}:{namespace}&#039;,\n        &#039;processPool&#039;   =&gt;  &#039;imi:process-pool-{processPoolName}-{workerId}:{namespace}&#039;,\n        &#039;tool&#039;          =&gt;  &#039;imi:{toolName}/{toolOperation}:{namespace}&#039;,\n    ],\n    // 主服务器配置\n    &#039;mainServer&#039;    =&gt;    [\n        // 指定服务器命名空间\n        &#039;namespace&#039;    =&gt;    &#039;ImiDemo\\HttpDemo\\MainServer&#039;,\n        // 服务器类型(http/WebSocket/TcpServer/UdpServer)\n        &#039;type&#039;        =&gt;    \\Imi\\Swoole\\Server\\Type::HTTP,\n        // 监听的IP地址，可选\n        &#039;host&#039;        =&gt;    &#039;0.0.0.0&#039;,\n        // 监听的端口\n        &#039;port&#039;        =&gt;    8080,\n        // 参考 swoole mode，可选\n        &#039;mode&#039;        =&gt;    SWOOLE_BASE,\n        // 参考 swoole sockType，可选\n        &#039;sockType&#039;    =&gt;    SWOOLE_SOCK_TCP,\n        // 同步连接，当连接事件执行完后，才执行 receive 事件。仅 TCP、WebSocket 有效\n        &#039;syncConnect&#039; =&gt; true,\n        // 服务器配置，参数用法同\\Swoole\\Server-&gt;set($configs)\n        // 参考: http://wiki.swoole.com/#/server/setting\n        // 参考: http://wiki.swoole.com/#/websocket_server?id=%e9%80%89%e9%a1%b9\n        // 参考: http://wiki.swoole.com/#/http_server?id=%e9%85%8d%e7%bd%ae%e9%80%89%e9%a1%b9\n        &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::TEXT, // 配置 WebSocket 纯文本通信协议\n        // &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::BINARY, // 配置 WebSocket 二进制通信协议\n        &#039;configs&#039;    =&gt;    [\n            &#039;reactor_num&#039;        =&gt; 8,\n            &#039;worker_num&#039;        =&gt; 8,\n            &#039;task_worker_num&#039;    =&gt; 16,\n            // Swoole 错误日志文件。如果不设置或为null则自动记录到 .runtime/swoole/swoole.log。如果设为 false 不记录 Swoole 错误日志。\n            // &#039;log_file&#039; =&gt; &#039;&#039;,\n        ],\n        // 服务器容器绑定\n        &#039;beans&#039; =&gt; [\n            &#039;aaa&#039; =&gt; XXX::class,\n        ],\n    ],\n    // 子服务器（端口监听）配置\n    &#039;subServers&#039;    =&gt;    [\n        // 子服务器别名\n        &#039;alias1&#039;    =&gt;    [\n            // 这里同主服务器配置\n        ]\n    ],\n];Workerman 项目配置文件return [\n    // 忽略扫描的命名空间\n    &#039;ignoreNamespace&#039;   =&gt;  [\n        &#039;Imi\\Test\\Component\\Annotation\\A\\*&#039;,    // 忽略扫描该命名空间下所有类\n        &#039;Imi\\Test\\Component\\Annotation\\B\\TestB&#039;,// 忽略该类\n    ],\n    // 全局忽略扫描的目录\n    &#039;ignorePaths&#039; =&gt; [\n        &#039;绝对路径，可包含通配符*&#039;,\n    ],\n    // 仅扫描项目时忽略扫描的目录\n    &#039;appIgnorePaths&#039; =&gt; [\n        &#039;绝对路径，可包含通配符*&#039;,\n    ],\n    // runtime目录设置，默认可不设置，为当前项目下的.runtime目录\n    // 注意，多个项目不可设置为相同目录！\n    &#039;runtimePath&#039;   =&gt;  &#039;/tmp/imidemo-runtime/&#039;,\n    // Workerman 服务器配置\n    &#039;workermanServer&#039; =&gt; [\n        // 服务器名\n        &#039;http&#039; =&gt; [\n            // 指定服务器命名空间\n            &#039;namespace&#039; =&gt; &#039;Imi\\Workerman\\Test\\HttpServer\\ApiServer&#039;,\n            // 服务器类型\n            &#039;type&#039;      =&gt; Imi\\Workerman\\Server\\Type::HTTP, // HTTP、WEBSOCKET、TCP、UDP\n            &#039;host&#039;      =&gt; &#039;0.0.0.0&#039;,\n            &#039;port&#039;      =&gt; 8080,\n            // socket的上下文选项，参考：http://doc3.workerman.net/315128\n            &#039;context&#039;   =&gt; [],\n            &#039;configs&#039;   =&gt; [\n                // 支持设置 Workerman 参数\n            ],\n            // 服务器容器绑定\n            &#039;beans&#039; =&gt; [\n                &#039;aaa&#039; =&gt; XXX::class,\n            ],\n        ],\n    ],\n];PHP-FPM 项目配置文件[\n    // 忽略扫描的命名空间\n    &#039;ignoreNamespace&#039;   =&gt;  [\n        &#039;ImiApp\\public\\*&#039;, // 忽略 public 目录\n        &#039;Imi\\Test\\Component\\Annotation\\A\\*&#039;,    // 忽略扫描该命名空间下所有类\n        &#039;Imi\\Test\\Component\\Annotation\\B\\TestB&#039;,// 忽略该类\n    ],\n    // 全局忽略扫描的目录\n    &#039;ignorePaths&#039; =&gt; [\n        &#039;绝对路径，可包含通配符*&#039;,\n    ],\n    // 仅扫描项目时忽略扫描的目录\n    &#039;appIgnorePaths&#039; =&gt; [\n        &#039;绝对路径，可包含通配符*&#039;,\n    ],\n    &#039;fpm&#039; =&gt; [\n        &#039;serverPath&#039; =&gt; &#039;如果兼容 Swoole、Workerman 服务器子目录，则设置一下该目录路径&#039;,\n    ],\n].env在 .env 中的配置方式，支持两种写法。写法一：直接注入配置，和Config::set()写法类似，支持@app等写法。写法二：传统方式，如设定一个ABC=123，在配置文件中：use function Imi\\env;\n\nuse Imi\\Env;\n\nreturn [\n    &#039;abc1&#039;   =&gt;  env(&#039;ABC&#039;, &#039;default&#039;), // imi 框架封装，支持第二个参数为默认值\n    &#039;abc2&#039;   =&gt;  Env::get(&#039;ABC&#039;, &#039;default&#039;), // imi 框架封装，支持第二个参数为默认值\n    &#039;abc3&#039;   =&gt;  getenv(&#039;ABC&#039;), // PHP 内置\n    &#039;abc3&#039;   =&gt;  $_ENV[&#039;ABC&#039;] ?? null, // PHP 内置\n];更多写法：env:A=123\nB=0\nC=1,2,3\nD=[4, 5, 6]\nE=imi\nBOOL_TRUE=true\nBOOL_FALSE=false\nNULL_VALUE=null\nEMPTY_VALUE=php:use Imi\\Env;\nuse function Imi\\env;\n\n// Imi\\env() 同 Imi\\env::get()\nenv(&#039;A&#039;); // 123\nenv(&#039;E&#039;); // imi\nenv(&#039;A&#039;, &#039;default&#039;); // &#039;123&#039;\nenv(&#039;A&#039;, 0); // 123\nenv(&#039;A&#039;, 3.14); // 123.0\nenv(&#039;A&#039;, false); // &#039;123&#039;\nenv(&#039;B&#039;, false); // false\nenv(&#039;BOOL_TRUE&#039;, false); // true\nenv(&#039;BOOL_FALSE&#039;, false); // false\nenv(&#039;C&#039;, []); // [&#039;1&#039;, &#039;2&#039;, &#039;3&#039;]\nenv(&#039;D&#039;, []); // [&#039;4&#039;, &#039;5&#039;, &#039;6&#039;]\nenv(&#039;NULL_VALUE&#039;); // null\nenv(&#039;NULL_VALUE&#039;, 666); // null\n\nEnv::str(&#039;A&#039;); // &#039;123&#039;\nEnv::int(&#039;A&#039;); // 123\nEnv::int(&#039;E&#039;); // 抛出异常\nEnv::int(&#039;NULL_VALUE&#039;); // null\nEnv::float(&#039;A&#039;); // 123.0\nEnv::float(&#039;E&#039;); // 抛出异常\nEnv::float(&#039;NULL_VALUE&#039;); // null\nEnv::bool(&#039;A&#039;); // 抛出异常\nEnv::bool(&#039;B&#039;); // false\nEnv::bool(&#039;bool_TRUE&#039;); // true\nEnv::bool(&#039;bool_FALSE&#039;); // false\nEnv::bool(&#039;E&#039;); // 抛出异常\nEnv::bool(&#039;NULL_VALUE&#039;); // null\nEnv::json(&#039;D&#039;); // [&#039;4&#039;, &#039;5&#039;, &#039;6&#039;]\nEnv::json(&#039;NULL_VALUE&#039;); // null\nEnv::json(&#039;EMPTY_VALUE&#039;); // 抛出异常\nEnv::list(&#039;C&#039;); // [&#039;1&#039;, &#039;2&#039;, &#039;3&#039;]\nEnv::list(&#039;NULL_VALUE&#039;); // null\nEnv::list(&#039;EMPTY_VALUE&#039;); // 抛出异常如下，是设置连接池的uri例子：@app.pools.maindb.async.resource = &quot;tcp://192.168.0.222/?username=root&amp;password=root&amp;database=db_test&amp;timeout=60&quot;数组的支持：@app.a.0.id = 1\n@app.a.0.name = name1\n@app.a.1.id = 2\n@app.a.1.name = name2同：[\n    &#039;a&#039; =&gt;  [\n        [&#039;id&#039;=&gt;1, &#039;name&#039;=&gt;&#039;name1&#039;],\n        [&#039;id&#039;=&gt;2, &#039;name&#039;=&gt;&#039;name2&#039;],\n    ]\n]自定义项目目录通常情况下，框架会自动识别项目目录。但在一些场景，你也可以自己定义项目目录。在入口文件定义：\\Imi\\App::set(\\Imi\\AppContexts::APP_PATH, &#039;项目目录&#039;, true); // phar 模式下不是物理目录\n\\Imi\\App::set(\\Imi\\AppContexts::APP_PATH_PHYSICS, &#039;项目物理目录&#039;, true);在项目里，无论你是否定义，都可以使用下面的方法，获取到项目目录：\\Imi\\App::get(\\Imi\\AppContexts::APP_PATH); // phar 模式下不是物理目录\n\\Imi\\App::get(\\Imi\\AppContexts::APP_PATH_PHYSICS);composer.json在 composer.json 中，我们允许配置一些优先于项目及框架加载前的配置。在项目启动时，会在项目目录下生成 imi.cache 文件，如果修改了 composer.json 中 imi 相关配置，需要手动删除 imi.cache 文件才可生效！格式如下：{\n    &quot;imi&quot;: {\n        // 项目命名空间\n        &quot;namespace&quot;: &quot;ImiApp&quot;\n    }\n}复制粘贴到 composer.json 注意删除注释"},{"id":5,"title":"赞助开发","pageTitle":"赞助开发","url":"base/donate.html","content":"赞助开发目录imi 遵循木兰宽松许可证（Mulan PSL v2）开源协议发布，并提供免费商业使用。如果您认为 imi 很好并想要支持我们，我们将不胜感激！官网捐赠请在官网右上角点击“打赏捐赠”：https://www.imiphp.com/其它渠道请加我的微信并注明来意："},{"id":38,"title":"Swoole 环境安装教程","pageTitle":"Swoole 环境安装教程","url":"base/env.html","content":"Swoole 环境安装教程目录运行环境Linux 系统 (Swoole 不支持在 Windows 上运行)PHP &gt;= 7.4Composer &gt;= 2.0Swoole &gt;= 4.8.0Redis、PDO 扩展Windows 开发者可以使用 Windows 10 Linux 子系统、Docker 或虚拟机等环境，实现在 Windows 系统上开发和调试。swoole-cliswoole-cli 介绍Swoole-Cli 是一个 PHP 的二进制发行版，集成了 swoole、php 内核、php-cli、php-fpm 以及多个常用扩展。Swoole-Cli是全部静态编译打包的，不依赖任何操作系统的 so 动态链接库，具备非常好的移植性，可以在任意 Linux/macOS/Windows(CygWin)系统之间复制，下载即可使用。下载地址：https://github.com/swoole/swoole-src/releases开源地址：https://github.com/swoole/swoole-cli需注意 CygWin 版，无法用于 imi 框架单文件打包imi 作者宇润为 swoole-cli 贡献了实现打包 PHP 文件进二进制可执行文件，从 v5.0.3 版本开始可以实现打包 PHP 文件进二进制可执行文件，也可以整项目可以打包为 phar 后再打包进可执行文件，支持 phar 的压缩。打包：./swoole-cli ./pack-sfx.php 你的php文件名 目标可执行文件运行打包进可执行文件的代码：目标可执行文件 --self运行其它文件：目标可执行文件 test.phpDocker推荐使用 Swoole 官方 Docker：https://github.com/swoole/docker-swoole支持 Windows安装教程教程可能过期，仅供参考！虚拟机安装 Linux【宇润】VirtualBox 虚拟机安装 Ubuntu 16.04【宇润】VirtualBox 虚拟机安装 Ubuntu 18.04【宇润】VirtualBox 虚拟机安装 CentOS 7【宇润】VirtualBox 虚拟机安装 CentOS 8.1PHP 环境安装【宇润】Ubuntu、Debian 系统安装 php 一把梭教程【宇润】CentOS 系统安装 php 一把梭教程（RedHat Linux + yum）Swoole 环境安装【宇润】一键安装 Swoole 环境教程，一把梭，让天下没有难装的 Swoole"},{"id":9,"title":"开始一个新项目","pageTitle":"开始一个新项目","url":"base/new.html","content":"开始一个新项目目录项目初始化imi 提供了多个项目模板可供选择：创建 Http Server 项目：composer create-project imiphp/project-http:~2.1.0创建 WebSocket Server 项目：composer create-project imiphp/project-websocket:~2.1.0创建 TCP Server 项目：composer create-project imiphp/project-tcp:~2.1.0创建 UDP Server 项目：composer create-project imiphp/project-udp:~2.1.0创建 gRPC 项目：composer create-project imiphp/project-grpc:~2.1.0创建 MQTT Server 项目：composer create-project imiphp/project-mqtt:~2.1.0运行命令后，会在当前目录创建一个新的 imi 项目，并下载所需的依赖。如何运行请看上面项目中的README.md项目最终使用什么协议，和上面的命令行无绝对关系。命令行创建项目只是提供一个快捷途径，服务的通信协议，可以通过修改配置文件来更换。流程说明在 imi 框架中，一个项目分为一个主服务器和多个子服务器。其中，主服务器为必须，子服务器为可选。子服务器通过监听端口实现，一般不推荐开启过多的子服务器。在项目中，如果你需要做一些初始化的事情，你可以在服务器的命名空间目录下创建一个Main.php，并把类命名为Main项目的Main必须继承Imi\\Main\\AppBaseMain类。&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace ImiApp;\n\nclass Main extends \\Imi\\Main\\AppBaseMain\n{\n    public function __init(): void\n    {\n    }\n}服务器的Main必须继承Imi\\Main\\BaseMain类。&lt;?php\n\nnamespace ImiApp\\ApiServer;\n\nuse Imi\\Main\\BaseMain;\n\nclass Main extends BaseMain\n{\n    public function __init(): void\n    {\n    }\n}当然，如果你不需要初始化，就不需要创建了"},{"id":11,"title":"常见问题","pageTitle":"常见问题","url":"base/qa.html","content":"常见问题目录通过 composer create-project 创建项目报错问题解决方案： 请确保你的环境依赖版本符合要求：PHP &gt;= 7.4 && Composer &gt;= 2.0查看命令：php -v &amp;&amp; composer -V通过 composer create-project 创建项目后无法以 Swoole 模式运行解决方案： 为 Windows 系统用户兼容考虑，默认没有引入 Swoole 组件，如有需要请手动引入：composer require imiphp/imi-swooleComposer 引入 imi-swoole 组件报错解决方案： 请确保你的 Swoole &gt;= 4.8.0查看命令：php --ri swoole更新框架后运行报错解决方案： 尝试删除 .runtime 目录中的 imi-runtime 和 runtime 目录你也可以使用命令来删除：vendor/bin/imi-xxx imi/clearRuntime &amp;&amp; vendor/bin/imi-xxx imi/clearImiRuntime (xxx 根据运行模式不同而不同)PHP Warning:  exec() has been disabled for security reasons解决方案： 不要禁用 exec、shell_exec，在 php.ini 中修改 disable_functions 项imi 框架的组件能不能用于其他框架中目前暂时是不能的Imi\\ 命名空间下的类报错提示不存在当项目文件放置在，共享目录等不支持文件锁的文件系统时，可以配置一个支持文件锁的目录。比如：/tmp。可以在运行命令时指定环境变量：IMI_MACRO_LOCK_FILE_DIR=/tmp vendor/bin/imi-swoole swoole/startCan't create more than max_prepared_stmt_count statementsPDOException: SQLSTATE[42000]: Syntax error or access violation: 1461 Can&#039;t create more than max_prepared_stmt_count statements (current value: 16382)imi 默认会缓存 Statement，建议调大 mysql 的 max_prepared_stmt_count 配置值。从 imi v2.1.34 开始你也可以配置 Statement 最大缓存数量 来自动清理缓存的 Statement。Workerman 报错：send buffer full and drop package这个问题一般出现在，服务器循环发送数据给客户端，导致塞满发送缓冲区。如果你是 Workerman，可以在入口文件中加上：// 发送缓冲区大小，单位：字节。可以根据需要调整，不建议设置得很大，会浪费内存\n\\Workerman\\Connection\\TcpConnection::$defaultMaxSendBufferSize = 2 * 1024 * 1024;如果你是 Workerman Gateway，可以在服务器配置中的 configs 加上相应配置：[\n    &#039;gateway&#039; =&gt; [\n        &#039;namespace&#039;   =&gt; &#039;Imi\\WorkermanGateway\\Test\\AppServer\\Gateway&#039;,\n        &#039;type&#039;        =&gt; Imi\\WorkermanGateway\\Workerman\\Server\\Type::GATEWAY,\n        &#039;socketName&#039;  =&gt; &#039;websocket://0.0.0.0:8081&#039;, // 网关监听的地址\n        &#039;configs&#039;     =&gt; [\n            &#039;lanIp&#039;           =&gt; &#039;127.0.0.1&#039;,\n            &#039;startPort&#039;       =&gt; 12900,\n            &#039;registerAddress&#039; =&gt; &#039;127.0.0.1:13004&#039;,\n            // 发送缓冲区大小，单位：字节。可以根据需要调整，不建议设置得很大，会浪费内存\n            &#039;sendToClientBufferSize&#039; =&gt; 2 * 1024 * 1024,\n        ],\n    ],\n]Workerman Gateway 网关模式发送大数据失败修改：/etc/sysctl.conf#TCP接收/发送缓存的最小值、默认值、最大值\nnet.ipv4.tcp_rmem = 4096 32768 262142\nnet.ipv4.tcp_wmem = 4096 32768 262142将最大值调整为你希望达到的大小保存后：sysctl -pWorker 进程数量建议设置多少？Swoole 常驻内存并且有协程，所以 worker_num 建议设为 CPU 的 1-2 倍。Workerman 常驻内存但依然是阻塞的，count 可参考 php-fpm 进程数的配置，并酌情减少一定的数量。"},{"id":"645b0aa9c106c2.97920595","title":"","pageTitle":"","url":"base/README.html","content":""},{"id":4,"title":"技术支持","pageTitle":"技术支持","url":"base/support.html","content":"技术支持目录免费技术支持如果在使用过程中遇到问题，请在官方群或 Github issue 中提问讨论。如果需要一对一的咨询，您可以将您的公司加入 imi 框架的案例中，即可免费获得 5 人及以下的群/私聊技术支持服务。企业技术支持我们可以为您提供 PHP/Swoole/imi 等方面的技术支持。如果您有需要，请添加我们的微信并详细说明您的需求："},{"id":12,"title":"v2.0-v2.1 升级指南","pageTitle":"v2.0-v2.1 升级指南","url":"base/version/2.0-2.1.html","content":"v2.0-v2.1 升级指南目录v2.0 是一个非常成功的 LTS 版本，进行了底层重构，增加了强类型规范化以及功能增强，让我们的项目拥有了更强大的能力。相比于 v2.0 版本，v2.1 版本不会有太大的不兼容性更改，可以在参考本页说明的情况下平滑升级。不兼容的更改Swoole 最低版本从 4.7 升级为 4.8。RedisModel、MemoryTableModel 初始化数据时，@Column 注解配置的 type 将不生效。json、list 类型字段不会自动处理，此特性仅支持数据库表模型。在使用 \\Imi\\Swoole\\Process\\Pool 调用 start() 方法启动进程池后，请使用 wait() 方法等待进程池结束。Swoole CronProcess 的 Unix Socket 文件名已更改。新功能v2.1.46发布日期： 2023-05-12模型查询构建器Model::query()、Model::dbQuery()支持定义表别名 (文档)Imi\\Util\\Random 新增 float() 和 bytes() 方法v2.1.45发布日期： 2023-04-29异步执行新增 @Defer、@DeferAsync 注解 (文档)支持优雅的 SSE 服务端推送功能 (文档)v2.1.43发布日期： 2023-04-07增加环境变量 IMI_SCAN_STATISTICS，支持关闭输出扫描阶段的日志 (#488) (文档)新增内存缓存驱动 (#490) (文档)v2.1.41发布日期： 2023-03-31查询构建器 fieldRaw()、joinRaw()、whereRaw()、orWhereRaw()、groupRaw()、havingRaw()、orderRaw()、setFieldExp()、setFieldInc()、setFieldDec() 支持传参数绑定v2.1.40发布日期： 2023-03-24支持 Phar 构建前后回调配置 (#478) (文档)支持 phar 构建后写出资源文件 (#478) (文档)支持关闭定时任务执行成功的日志 (#477)v2.1.39发布日期： 2023-03-10支持 MySQL 查询构建器 insert ignore into (#476)v2.1.36发布日期： 2023-02-03实现数据库查询构建器的指定分区操作 (#466)Imi\\Util\\System::getCpuCoresNum() 支持 MacOS 系统 (#468)v2.1.34发布日期： 2022-12-16支持模型自定义关联支持设置 Statement 最大缓存数量v2.1.33发布日期： 2022-12-03ProtobufUtil::getMessageValue() 支持可遍历对象，无法处理的原样返回v2.1.32发布日期： 2022-11-25Listener 注解支持设置事件仅触发一次 (#458)v2.1.31发布日期： 2022-11-18兼容 PHP 8.2 (#441)支持 PHP 8.2 交叉类型支持 PHP 8.2 只读类v2.1.30发布日期： 2022-10-28支持 AOP 切入带有引用返回值的方法 (#450)新增 imi-influxdb 组件支持服务指标监控 InfluxDB 驱动支持服务指标监控 TDengine InfluxDB 兼容驱动v2.1.29发布日期： 2022-10-14服务发现（负载均衡）调用链路追踪 OpenTracing（Zipkin、Jaeger）重构骨架项目：增加模块划分、自动格式化、代码静态分析、自动化测试，更加符合实际项目的开发Imi\\Grpc\\Util\\ProtobufUtil::setMessageData() 增加参数 $ignoreUnknown，可以忽略未知字段新增 Imi\\Grpc\\Util\\ProtobufUtil::newMessage() 和 Imi\\Grpc\\Util\\ProtobufUtil::newMessageArray()增强 BeanFactory::getObjectClass() 支持字符串增强 @Column 注解的 createTime、updateTime 支持传入 int 值，表示时间精度，仅 bigint、int8 有效 (#445)v2.1.28发布日期： 2022-09-23新增数据库迁移支持在非 cli 环境执行 Imi\\Util\\Imi::getImiCmd()、Imi\\Util\\Imi::getImiCmdArray()v2.1.27发布日期： 2022-09-16实现模型发号器，支持 UUID、雪花算法 (#430) (文档)新增 RequestParam 注解 (#432) (文档)v2.1.24发布日期： 2022-08-27支持 WebSocket 二进制协议新增支持键值过期的存储对象 Imi\\Util\\ExpiredStorage请求上下文缓存驱动v2.1.23发布日期： 2022-08-20支持模型序列化 (#412)v2.1.22发布日期： 2022-08-13gRPC 的 HTTP 代理网关新增命令行工具的 --bootstrap 参数支持在 Swoole BASE 模式下获取所有 Worker 连接数支持模型增量更新v2.1.20发布日期： 2022-07-22PDO 驱动绑定值支持 resource 类型使用 \\PDO::PARAM_LOBv2.1.19发布日期： 2022-07-15Db类添加一个工具方法Db::debugSqlv2.1.18发布日期： 2022-07-02模型生成支持 MySQL、PgSQL 虚拟列容器增加3个方法：set、newInstance、bindCallable请求上下文增加2个方法：remember、unset （请求上下文、连接上下文）v2.1.17发布日期： 2022-06-24支持配置启动服务时检测连接是否可用 (@app.server.checkPoolResource)v2.1.16发布日期： 2022-06-17实现 Swoole 用户进程双向通信v2.1.15发布日期： 2022-06-10新增 @EnvValue 注解 (文档)v2.1.11发布日期： 2022-05-07在 Model 中支持 MySQL 数据类型 setv2.1.9发布日期： 2022-04-16定时任务支持：移除所有任务、检测是否存在任务、获取单个任务、获取所有任务v2.1.8发布日期： 2022-04-08模型关联支持在查询结果中，包含被软删除的数据v2.1.7发布日期： 2022-04-02新增 Imi\\dump() 调试输出函数单文件运行 imi支持验证器动态数组对象验证Db 构建器添加 find、value、column 查询方法v2.1.6发布日期： 2022-03-20支持在 composer.json 中配置项目命名空间Db的分块查询与游标查询支持v2.1.5发布日期： 2022-03-11实现 WebSocket、Tcp、Udp 异常处理器v2.1.4发布日期： 2022-03-04支持监听 Swoole WebSocket Server disconnect 事件支持定义命令行名称分割符Phar 打包支持v2.1.2发布日期： 2022-02-18枚举类增加 validate() 和 assert()Query-&gt;where() 条件的值支持传原始 SQLv2.1.1发布日期： 2022-02-12定时任务的最小、最大延迟执行秒数Swoole WebSocket Server 支持 syncConnect支持为数据库连接设置表前缀模型注解 JsonEncode 增强，增加 JsonDecode 注解支持从 Query 构建 SQL 语句新增 Model::exists() 用于判断记录是否存在支持设置字段为 createTime，插入记录时自动设置时间v2.1.0发布日期： 2022-01-21宏定义异步日志"},{"id":6,"title":"版本支持计划","pageTitle":"版本支持计划","url":"base/version/support.html","content":"版本支持计划目录imi 版本维护支持时间表imi 版本环境要求状态发布时间结束支持时间v3.0PHP： 8.1-?，Swoole： 5.0-?正在开发--v2.1PHP： 7.4-8.2，Swoole： 4.8-5.0积极开发2022-01-212024-12-31v2.0PHP： 7.4-8.1，Swoole： 4.7-5.0长期支持2021-08-202023-12-31v1.3PHP： 7.1-8.0，Swoole： 4.4-4.8长期支持2021-05-152023-12-31v1.2PHP： 7.1-8.0，Swoole： 4.3-4.6停止维护2020-04-132021-05-15v1.1PHP： 7.1-7.4，Swoole： 4.3-4.4停止维护2020-02-272020-04-13v1.0PHP： 7.1-7.4，Swoole： 4.3-4.4停止维护2019-06-172020-02-27v0.x-停止维护2018-06-212019-06-17状态说明：状态说明正在开发该分支正在计划或开发中，还没有发布稳定版本积极开发作为主要分支进行日常开发，会经常加入新特性新功能，可以作为稳定版使用长期支持只进行 bug 修复及安全修复，不再加入新特性和新功能。停止维护不再维护，推荐升级到更高版本。赞助维护如果您的项目正在使用已经停止支持的旧版本，并且因为各种原因选择不升级，那么您可以选择付费支持 imi 旧版本的维护工作。您的付费可以让不受支持的 imi 旧版本继续得到维护，让所有正在使用旧版本的用户都能受益。"},{"id":196,"title":"权限控制","pageTitle":"权限控制","url":"components/access-control.html","content":"权限控制目录介绍imi 框架的权限控制组件，不提供具体 API、管理界面，仅提供基础操作组件。本组件中支持：角色关联操作，用户关联角色，用于关联操作。用户除了角色赋予的操作权限以外，还可以单独赋予操作权限。Composer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-access-control&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入本组件\n        &#039;AccessControl&#039;    =&gt;  &#039;Imi\\AC&#039;,\n    ],\n]本组件中包含几个数据表，打开本组件目录，找到Model目录，在数据库中建立对应的表，即可使用。建表这里优先推荐用generate/table：https://doc.imiphp.com/v2.1/dev/generate/table.html操作权限引入操作权限操作类use Imi\\AC\\AccessControl\\Operation;创建操作权限Operation::create(&#039;权限名称&#039;);\n\n// 权限代码不传或为null，则和权限名称相同，不可重复\nOperation::create(&#039;权限名称&#039;, &#039;权限代码&#039;);\n\n// 指定父级ID、排序索引\nOperation::create(&#039;权限名称&#039;, &#039;权限代码&#039;, $parentId, $index, &#039;介绍&#039;);修改操作权限// 参数比创建时多了权限id，其余都一样，注意权限id是int类型\nOperation::update(权限id, &#039;权限名称&#039;, &#039;权限代码&#039;, $parentId, $index, &#039;介绍&#039;);删除操作权限// 注意权限id是int类型\nOperation::delete(权限id);查询操作操作权限列表// 查询权限列表\n$data = Operation::selectList();\n// 将列表转换为树状结构\n$tree = Operation::listToTree($data);角色创建角色use Imi\\AC\\AccessControl\\Role;\n\n// 与 Operation::create 一样，不多做说明了\n$role = Role::create(&#039;权限名称&#039;, &#039;权限代码&#039;, &#039;介绍&#039;);获取角色信息// 支持ID、Code两种模式\n$role = new Role(&#039;权限ID&#039;);\n$role = new Role(&#039;权限代码&#039;, &#039;code&#039;);\n$roleInfo = $role-&gt;getRoleInfo(); // $roleInfo-&gt;id/code/name/description获取角色操作权限// 数组，成员为 \\Imi\\AC\\Model\\Operation 类型\n$operations = $role-&gt;getOperations();\n\n// 树形结构，成员为 \\Imi\\AC\\Model\\Filter\\OperationTreeItem 类型，$item-&gt;children 为其下一级角色，同样为 \\Imi\\AC\\Model\\Filter\\OperationTreeItem 类型\n$operationTree = $role-&gt;getOperationTree();增加、设置角色权限$role-&gt;addOperations(&#039;code1&#039;, &#039;code2&#039;); // 只在当前基础上增加这两个权限\n\n$role-&gt;setOperations(&#039;code1&#039;, &#039;code2&#039;); // 将角色权限设置为仅有这两个权限移除角色权限$role-&gt;removeOperations(&#039;code1&#039;, &#039;code2&#039;);判断角色是否拥有权限$result = $role-&gt;hasOperations(&#039;code1&#039;, &#039;code2&#039;);用户获取该用户所有角色use Imi\\AC\\AccessControl\\Member;\n\n$memberId = 1;\n$member = new Member(1);\n\n$roles = $member-&gt;getRoles();增加、设置角色$member-&gt;addRoles(&#039;code1&#039;, &#039;code2&#039;); // 只在当前基础上增加这两个角色\n\n$member-&gt;setRoles(&#039;code1&#039;, &#039;code2&#039;); // 将用户角色设置为仅有这两个角色移除角色$member-&gt;removeRoles(&#039;code1&#039;, &#039;code2&#039;);判断用户是否拥有角色$result = $member-&gt;hasRoles(&#039;code1&#039;, &#039;code2&#039;);获取用户操作权限// 数组，成员为 \\Imi\\AC\\Model\\Operation 类型\n$operations = $member-&gt;getOperations();\n\n// 树形结构，成员为 \\Imi\\AC\\Model\\Filter\\OperationTreeItem 类型，$item-&gt;children 为其下一级角色，同样为 \\Imi\\AC\\Model\\Filter\\OperationTreeItem 类型\n$operationTree = $member-&gt;getOperationTree();增加、设置用户权限$member-&gt;addOperations(&#039;code1&#039;, &#039;code2&#039;); // 只在当前基础上增加这两个权限\n\n$member-&gt;setOperations(&#039;code1&#039;, &#039;code2&#039;); // 将角色权限设置为仅有这两个权限移除用户权限$member-&gt;removeOperations(&#039;code1&#039;, &#039;code2&#039;);判断用户是否拥有权限$result = $member-&gt;hasOperations(&#039;code1&#039;, &#039;code2&#039;);"},{"id":178,"title":"AOP","pageTitle":"AOP","url":"components/aop/index.html","content":"AOP目录介绍首先，你不要看到 AOP 就感觉好难好复杂，看下去其实也就那样。而且在 imi 中你也不一定需要用到AOP，这是非必须的。AOP 的概念通过搜索引擎一定是看烦了，而且看了也没什么大卵用，不贴近实际。我先举个 AOP 实际应用的简单例子，比如在写一个方法的时候，可能要针对某个方法写前置和后置操作，传统写法如下：abstract class ParentClass\n{\n    public function test()\n    {\n        $this-&gt;__beforeTest();\n        // 做一些事情...\n        echo &#039;Parent-&gt;test()&#039;, PHP_EOL;\n        $this-&gt;__afterTest();\n    }\n\n    public abstract function __beforeTest();\n\n    public abstract function __afterTest();\n}\n\nclass Child extends ParentClass\n{\n    public function __beforeTest()\n    {\n        echo &#039;Child-&gt;__beforeTest()&#039;, PHP_EOL;\n    }\n\n    public function __afterTest()\n    {\n        echo &#039;Child-&gt;__afterTest()&#039;, PHP_EOL;\n    }\n}\n\n$child = new Child;\n$child-&gt;test();运行结果：Child-&gt;__beforeTest()\nParent-&gt;test()\nChild-&gt;__afterTest()这种写法你需要事先定义好前置和后置方法，如果需要前后置的方法一多，写起来会非常繁琐。AOP 可以很好地解决这个问题，不仅可以在编写上不用事先定义这么多方法，还非常有助于解耦。AOP 名词切面 Aspect普通的类，你要切入的类。切入点 PointCut普通类中的方法，你要切入的方法。参数：名称描述默认值type切入点类型，PointCutType::XXXPointCutType::METHODallow允许的切入点[]deny不允许的切入点，即使包含中有的，也可以被排除[]切入点类型（\\Imi\\Aop\\PointCutType）：名称描述值METHOD方法，包括构造方法 __construct()1ANNOTATION带有注解的方法2CONSTRUCT构造方法3ANNOTATION_CONSTRUCT带有注解的类的构造方法4allow、deny 说明：注入METHOD时：支持格式类名::方法名，其中类名和方法名都支持代入*表示通配符注入CONSTRUCT时：支持格式类名，类名支持代入*表示通配符注入ANNOTATION、ANNOTATION_CONSTRUCT时：只格式完整的类名连接点 Joinpoint在这个方法相关的什么时机触发通知，比如：调用的前置后置、抛出异常等。通知 Advice在连接点触发的通知，比如在前置操作触发，通知里写前置的具体实现。imi 支持的通知点有：@Before前置操作，注意与@Around区别。@After后置操作@Around环绕操作。先触发环绕操作，在前置操作前和后置操作后，都可以做一些事情。与@Before区别：@Around先于@Before执行，并可以完全不让原方法运行，可用于请求拦截等操作。@AfterReturning在原方法返回后触发，可以修改返回值@AfterThrowing在抛出异常后触发，允许设置allow和deny，设置允许和拒绝捕获的异常类通知执行顺序正常执行时@Around → @Before → $joinPoint-&gt;proceed()→ @After → @AfterReturning → @Around有异常抛出时@Around → @Before → 抛出异常 → @AfterThrowing使用方法使用注解注入方法监听池子的资源获取和释放：&lt;?php\nnamespace Test;\n\nuse Imi\\Aop\\JoinPoint;\nuse Imi\\Aop\\Annotation\\After;\nuse Imi\\Aop\\Annotation\\Aspect;\nuse Imi\\Aop\\Annotation\\PointCut;\n\n/**\n * @Aspect\n */\nclass Pool\n{\n    /**\n     * @PointCut(\n     *         allow={\n     *             &quot;Imi\\*Pool*::getResource&quot;,\n     *             &quot;Imi\\*Pool*::release&quot;,\n     *         }\n     * )\n     * @After\n     * @param JoinPoint $a\n     * @return void\n     */\n    public function test(JoinPoint $joinPoint)\n    {\n        echo $joinPoint-&gt;getType() . &#039; &#039; . get_parent_class($joinPoint-&gt;getTarget()) . &#039;::&#039; . $joinPoint-&gt;getMethod() . &#039;(): &#039; . $joinPoint-&gt;getTarget()-&gt;getFree() . &#039;/&#039; . $joinPoint-&gt;getTarget()-&gt;getCount() . PHP_EOL;\n        var_dump(&#039;args:&#039;, $joinPoint-&gt;getArgs());\n    }\n}运行效果：after Imi\\Swoole\\Redis\\Pool\\CoroutineRedisPool::getResource(): 0/1\nafter Imi\\Swoole\\Redis\\Pool\\CoroutineRedisPool::release(): 1/1类名、方法名和命名空间没有要求。类注释中必须写@Aspect表明是一个切面类方法中写@PointCut表示指定切入点，支持通配符@After代表在该方法调用后触发注入带有注解的方法可参考imi\\src\\Db\\Aop\\TransactionAop.php文件：/**\n * @Aspect\n */\nclass TransactionAop\n{\n    /**\n     * 自动事务支持\n     * @PointCut(\n     *         type=PointCutType::ANNOTATION,\n     *         allow={\n     *             Transaction::class\n     *         }\n     * )\n     * @Around\n     * @return mixed\n     */\n    public function parseTransaction(AroundJoinPoint $joinPoint)\n    {\n    }\n}无论这个注解在方法上出现了几次，都只会触发一次注入处理配置注入实现代码namespace Test;\n\nuse Imi\\Aop\\JoinPoint;\n\nclass Test\n{\n    /**\n     * @param JoinPoint $a\n     * @return void\n     */\n    public function test(JoinPoint $joinPoint)\n    {\n        echo $joinPoint-&gt;getType() . &#039; &#039; . get_parent_class($joinPoint-&gt;getTarget()) . &#039;::&#039; . $joinPoint-&gt;getMethod() . &#039;(): &#039; . $joinPoint-&gt;getTarget()-&gt;getFree() . &#039;/&#039; . $joinPoint-&gt;getTarget()-&gt;getCount() . PHP_EOL;\n    }\n}对类没有任何要求，方法只需要参数对即可。配置&lt;?php\nreturn [\n    // 类名\n    \\Test\\Test::class    =&gt;    [\n        // 固定写法methods\n        &#039;methods&#039;    =&gt;    [\n            // 方法名\n            &#039;test&#039;    =&gt;    [\n                // 指定切入点\n                &#039;pointCut&#039;    =&gt;    [\n                    &#039;allow&#039;    =&gt;    [\n                        &quot;Imi\\*Pool*::getResource&quot;,\n                        &quot;Imi\\*Pool*::release&quot;,\n                    ]\n                ],\n                &#039;after&#039;    =&gt;    [\n                    \n                ]\n            ]\n        ]\n    ],\n];所有注入演示&lt;?php\nnamespace Test;\n\nuse Imi\\Aop\\JoinPoint;\nuse Imi\\Aop\\AroundJoinPoint;\nuse Imi\\Aop\\Annotation\\After;\nuse Imi\\Aop\\Annotation\\Around;\nuse Imi\\Aop\\Annotation\\Aspect;\nuse Imi\\Aop\\Annotation\\Before;\nuse Imi\\Aop\\Annotation\\PointCut;\nuse Imi\\Aop\\AfterThrowingJoinPoint;\nuse Imi\\Aop\\AfterReturningJoinPoint;\nuse Imi\\Aop\\Annotation\\AfterThrowing;\nuse Imi\\Aop\\Annotation\\AfterReturning;\n\n/**\n * @Aspect\n */\nclass Test\n{\n    /**\n     * 前置操作\n     * @PointCut(\n     *         allow={\n     *             &quot;ImiDemo\\HttpDemo\\MainServer\\Model\\Goods::getScore&quot;,\n     *         }\n     * )\n     * @Before\n     * @param JoinPoint $a\n     * @return void\n     */\n    public function before(JoinPoint $joinPoint)\n    {\n        // 修改参数\n        // $joinPoint-&gt;setArgs(/*参数数组*/);\n        echo &#039;getScore()-before&#039;, PHP_EOL;\n    }\n\n    /**\n     * 后置操作\n     * @PointCut(\n     *         allow={\n     *             &quot;ImiDemo\\HttpDemo\\MainServer\\Model\\Goods::getScore&quot;,\n     *         }\n     * )\n     * @After\n     * @param JoinPoint $a\n     * @return void\n     */\n    public function after(JoinPoint $joinPoint)\n    {\n        echo &#039;getScore()-after&#039;, PHP_EOL;\n    }\n\n    /**\n     * 环绕\n     * @PointCut(\n     *         allow={\n     *             &quot;ImiDemo\\HttpDemo\\MainServer\\Model\\Goods::getScore1&quot;,\n     *         }\n     * )\n     * @Around\n     * @return mixed\n     */\n    public function around(AroundJoinPoint $joinPoint)\n    {\n        var_dump(&#039;调用前&#039;);\n        // 执行原方法，获取返回值\n        $result = $joinPoint-&gt;proceed();\n        // 执行原方法，获取返回值（方法返回值是引用返回时）\n        // $result = $joinPoint-&gt;proceed(null, true);\n        var_dump(&#039;调用后&#039;);\n        return &#039;value&#039;; // 无视原方法调用后的返回值，强制返回一个其它值\n        return $result; // 返回原方法返回值\n    }\n\n    /**\n     * 返回值\n     * @PointCut(\n     *         allow={\n     *             &quot;ImiDemo\\HttpDemo\\MainServer\\Model\\Goods::getScore&quot;,\n     *         }\n     * )\n     * @AfterReturning\n     * @param AfterReturningJoinPoint $joinPoint\n     * @return void\n     */\n    public function afterReturning(AfterReturningJoinPoint $joinPoint)\n    {\n        $joinPoint-&gt;setReturnValue(&#039;修改返回值&#039;);\n    }\n\n    /**\n     * 异常捕获\n     * @PointCut(\n     *         allow={\n     *             &quot;ImiDemo\\HttpDemo\\MainServer\\Model\\Goods::getScore&quot;,\n     *         }\n     * )\n     * @AfterThrowing\n     * @param AfterThrowingJoinPoint $joinPoint\n     * @return void\n     */\n    public function afterThrowing(AfterThrowingJoinPoint $joinPoint)\n    {\n        // 异常不会被继续抛出，也不会记录日志\n        $joinPoint-&gt;cancelThrow();\n        var_dump(&#039;异常捕获:&#039; . $joinPoint-&gt;getThrowable()-&gt;getMessage());\n        // 如有需要，可以手动记录下日志：\n        \\Imi\\Log\\Log::error($joinPoint-&gt;getThrowable());\n    }\n}\n属性注入如下代码例子，定义一个类，使用@Inject注解来注释属性，在通过getBean()实例化时，会自动给被注释的属性赋值相应的实例对象。namespace Test;\n\nclass TestClass\n{\n    /**\n     * 某Model对象\n     * @Inject(&quot;XXX\\Model\\User&quot;)\n     */\n    protected $model;\n    \n    /**\n     * 某Model对象，通过注释类型注入\n     * @Inject\n     * \n     * @var XXX\\Model\\User\n     */\n    protected $model2;\n    \n    /**\n     * 某Model对象，通过 PHP 7.4 以上类型声明注入\n     * @Inject\n     */\n    protected XXX\\Model\\User $model3;\n\n    public function test()\n    {\n        var_dump($model-&gt;toArray());\n    }\n}\n\n$testClass = App::getBean(&#039;Test\\TestClass&#039;);\n$testClass-&gt;test();非 Bean 类使用属性注入imi 提供了一个 Imi\\Bean\\Traits\\TAutoInject 来让非 Bean 类也能够使用属性注入。也就是直接new对象，也可以自动注入属性。无构造方法的类：namespace Test;\n\nuse Imi\\Aop\\Annotation\\Inject;\n\nclass Test\n{\n    use Imi\\Bean\\Traits\\TAutoInject;\n\n    /**\n     * @Inject(&quot;XXX&quot;)\n     */\n    public $xxx;\n}\n\n$test = new Test;\n$test-&gt;xxx; // 会被自动注入，不用手动初始化有构造方法的类：namespace Test;\n\nuse Imi\\Aop\\Annotation\\Inject;\n\nclass Test\n{\n    use Imi\\Bean\\Traits\\TAutoInject;\n\n    /**\n     * @Inject(&quot;XXX&quot;)\n     */\n    public $xxx;\n\n    private $value;\n\n    public function __construct()\n    {\n        $this-&gt;__autoInject(); // 手动调用 __autoInject() 方法\n        $this-&gt;value = 123;\n    }\n}\n\n$test = new Test;\n$test-&gt;xxx; // 会被自动注入，不用手动初始化方法参数注入/**\n * @InjectArg(name=&quot;a&quot;, value=&quot;123&quot;)\n * @InjectArg(name=&quot;b&quot;, value=@Inject(&quot;\\ImiDemo\\HttpDemo\\MainServer\\Model\\User&quot;))\n *\n * @return void\n */\npublic function test($a, $b)\n{\n    var_dump($a, $b);\n}可以直接注入值，也可以使用值注入注解。"},{"id":183,"title":"异步执行","pageTitle":"异步执行","url":"components/async/index.html","content":"异步执行目录imi v2.0.7 起开始支持在方法上声明注解，让这个方法可以以异步的方式调用，并且支持选择等待获取返回值。此特性所有环境都可使用，但仅在 Swoole 下才是真异步注解@Asyncimi v2.0.7 支持在方法上使用 @Async 注解，让这个方法被正常调用时是异步调用。@Async 注解类：\\Imi\\Async\\Annotation\\Async在 Swoole 下，方法被调用时，会立即创建一个协程并执行，只有协程挂起时，才会继续执行当前代码。@Deferimi v2.1.45 起支持。@Defer 注解类：\\Imi\\Async\\Annotation\\Defer在 Swoole 下，会在协程关闭之前 (即协程函数执行完毕时) 进行调用，就算抛出了异常，已注册的 defer 也会被执行。@DeferAsyncimi v2.1.45 起支持。@DeferAsync 注解类：\\Imi\\Async\\Annotation\\DeferAsync在 Swoole 下，会在协程关闭之前 (即协程函数执行完毕时) 进行调用，调用时会创建一个协程并立即执行，代码所在上下文是一个新的协程。使用示例@Async、@Defer 和 @DeferAsync 的使用方法完全一致，仅执行顺序不同。异步执行无返回值定义：&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Imi\\Swoole\\Test\\Component\\Async;\n\nuse Imi\\Async\\Annotation\\Async;\nuse Imi\\Async\\AsyncResult;\nuse Imi\\Async\\Contract\\IAsyncResult;\nuse Imi\\Bean\\Annotation\\Bean;\n\nclass AsyncTester\n{\n    /**\n     * @Async\n     */\n    public function test1(): void\n    {\n        // 这里的代码是异步执行的\n        sleep(1);\n    }\n}调用：$asyncTester = \\Imi\\App::getBean(AsyncTester::class);\n$result = $asyncTester-&gt;test1();\n// 下面的代码会立即执行，而不是等待 1 秒后\n// ...\n$result-&gt;get(); // 等待异步执行完毕\n$result-&gt;get(0.1); // 等待异步执行完毕，超时时间为 0.1 秒，超时则抛出异常异步执行有返回值定义：&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Imi\\Swoole\\Test\\Component\\Async;\n\nuse Imi\\Async\\Annotation\\Async;\nuse Imi\\Async\\AsyncResult;\nuse Imi\\Async\\Contract\\IAsyncResult;\nuse Imi\\Bean\\Annotation\\Bean;\n\nclass AsyncTester\n{\n    /**\n     * 如果一定要声明方法返回值类型，必须声明为 IAsyncResult\n     * \n     * @Async\n     */\n    public function test2(float $a, float $b): IAsyncResult\n    {\n        return new AsyncResult($a + $b);\n    }\n\n    /**\n     * 不声明方法返回值类型也可以\n     * \n     * @Async\n     *\n     * @return float|IAsyncResult\n     */\n    public function test3(float $a, float $b)\n    {\n        return $a + $b;\n    }\n}调用：$asyncTester = \\Imi\\App::getBean(AsyncTester::class);\n$asyncTester-&gt;test2(1, 2)-&gt;get(); // 3\n$asyncTester-&gt;test3(1, 2)-&gt;get(); // 3捕获异常调用：$asyncTester = \\Imi\\App::getBean(AsyncTester::class);\ntry {\n    $asyncTester-&gt;test1()-&gt;get(0.01);\n} catch (\\Imi\\Async\\Exception\\AsyncTimeoutException $te) {\n    // 捕获异步超时异常\n} catch (\\Throwable $th) {\n    // 捕获执行期间其它异常\n}"},{"id":165,"title":"Apcu 缓存","pageTitle":"Apcu 缓存","url":"components/cache/apcu.html","content":"Apcu 缓存目录使用需要安装 Apcu 扩展Apcu 仅推荐在 php-fpm 模式使用配置&lt;?php\nreturn [\n    &#039;caches&#039;    =&gt;    [\n        // 缓存名称\n        &#039;alias1&#039;    =&gt;    [\n            // 缓存驱动类\n            &#039;handlerClass&#039;    =&gt;    \\Imi\\Cache\\Handler\\Apcu::class,\n            // 驱动实例配置\n            &#039;option&#039;        =&gt;    [\n                &#039;prefix&#039; =&gt;  &#039;&#039;, // 缓存键前缀\n            ],\n        ],\n    ],\n];"},{"id":162,"title":"文件缓存","pageTitle":"文件缓存","url":"components/cache/file.html","content":"文件缓存目录配置&lt;?php\nreturn [\n    &#039;caches&#039;    =&gt;    [\n        // 缓存名称\n        &#039;alias1&#039;    =&gt;    [\n            // 缓存驱动类\n            &#039;handlerClass&#039;    =&gt;    \\Imi\\Cache\\Handler\\File::class,\n            // 驱动实例配置\n            &#039;option&#039;        =&gt;    [\n                &#039;savePath&#039;    =&gt;    &#039;文件缓存保存路径&#039;,\n                &#039;formatHandlerClass&#039;    =&gt;    null, // 数据读写修改器\n                // 保存文件名处理回调，一般可以不写\n                // &#039;saveFileNameCallback&#039;    =&gt;    function($savePath, $key){\n                //     return &#039;&#039;;\n                // },\n                &#039;keyAsFileName&#039; =&gt; false, // 使用键名作为文件名，如果设置了 $saveFileNameCallback 则 $keyAsFileName 无效\n            ],\n        ],\n    ],\n];formatHandlerClass 可选：Imi\\Util\\Format\\Json、Imi\\Util\\Format\\PhpSerialize，或者可以自行实现Imi\\Util\\Format\\IFormat接口文件缓存除非挂载 samba 等网络磁盘，否则不支持分布式存储，请慎重选择！"},{"id":161,"title":"缓存","pageTitle":"缓存","url":"components/cache/index.html","content":"缓存目录imi 中的缓存，符合PSR-16规范。使用时需要先配置驱动和实例。配置默认缓存设置&lt;?php\nreturn [\n    &#039;cache&#039;    =&gt;    [\n        &#039;default&#039;    =&gt;    &#039;alias1&#039;,\n    ],\n];缓存相关注解，不指定 name 属性时，使用该配置手动使用写入缓存// 永久有效\nImi\\Cache\\CacheManager::set(&#039;缓存名称&#039;, &#039;key&#039;, &#039;value&#039;);\n\n$ttl = 3600; // 缓存有效时间，单位：秒\nImi\\Cache\\CacheManager::set(&#039;缓存名称&#039;, &#039;key&#039;, &#039;value&#039;, $ttl);批量写入缓存$values = [\n    &#039;k1&#039;    =&gt;    &#039;v1&#039;,\n    &#039;k2&#039;    =&gt;    &#039;v2&#039;,\n];\nImi\\Cache\\CacheManager::setMultiple(&#039;缓存名称&#039;, $values);\n\n$ttl = 3600; // 缓存有效时间，单位：秒\nImi\\Cache\\CacheManager::setMultiple(&#039;缓存名称&#039;, $values, $ttl);读取缓存Imi\\Cache\\CacheManager::get(&#039;缓存名称&#039;, &#039;key&#039;);\n\nImi\\Cache\\CacheManager::get(&#039;缓存名称&#039;, &#039;key&#039;, &#039;default&#039;);批量读取缓存$keys = [&#039;k1&#039;, &#039;k2&#039;];\n\nImi\\Cache\\CacheManager::getMultiple(&#039;缓存名称&#039;, $keys);\n\nImi\\Cache\\CacheManager::getMultiple(&#039;缓存名称&#039;, $keys, &#039;default&#039;);删除缓存Imi\\Cache\\CacheManager::delete(&#039;缓存名称&#039;, &#039;key&#039;);批量删除缓存$keys = [&#039;k1&#039;, &#039;k2&#039;];\n\nImi\\Cache\\CacheManager::deleteMultiple(&#039;缓存名称&#039;, $keys);缓存是否存在Imi\\Cache\\CacheManager::has(&#039;缓存名称&#039;, &#039;key&#039;);清空缓存Imi\\Cache\\CacheManager::clear(&#039;缓存名称&#039;);注解使用除了手动控制缓存读写，你还可以使用注解来做，真的炒鸡方便哦！首先来认识一下 imi 中的缓存注解吧！@Cacheable调用方法前检测是否存在缓存，如果存在直接返回；不存在则执行方法体，然后将返回值存入缓存用法：基本用法：@Cacheable(name=&quot;缓存器名，为null则取cache.default配置&quot;, key=&quot;缓存键名，支持{id}、{data.name}、{:args}(所有参数的hash值)形式，代入参数，如果为null，则使用类名+方法名+全部参数，序列化后hash&quot;, ttl=&quot;超时时间，单位秒&quot;, lockable=&quot;Lock 注解，在调用方法体前后加锁&quot;, hashMethod=&quot;md5&quot;)防止缓存击穿：/*\n * @Cacheable(\n *   key=&quot;index:{page}&quot;,\n *   ttl=10,\n *   lockable=@Lockable(\n *     id=&quot;index:{page}&quot;,\n *     waitTimeout=999999,\n *   ),\n *   preventBreakdown=true,\n * )\n */lockable 用法请参考 LockpreventBreakdown 如果设为 true，会在获得锁后，尝试获取缓存，如果缓存存在则不再执行方法体如果 preventBreakdown 设为 true，并且lockable中也设定了afterLock，优先级为：afterLock &gt; 缓存检测@CacheEvict缓存驱逐注解，方法体执行时，将指定缓存清除用法：在方法执行前删除缓存：@CacheEvict(name=&quot;同上&quot;, key=&quot;同上&quot;, beforeInvocation=true, hashMethod=&quot;md5&quot;)在方法执行后删除缓存：@CacheEvict(name=&quot;同上&quot;, key=&quot;同上&quot;, hashMethod=&quot;md5&quot;)@CachePut方法体执行后，将返回值存入缓存用法：将方法返回值全部写入缓存：@CachePut(name=&quot;同上&quot;, key=&quot;同上&quot;, ttl=&quot;同上&quot;, hashMethod=&quot;md5&quot;)将方法返回值的一部分写入缓存：@CachePut(name=&quot;同上&quot;, key=&quot;同上&quot;, ttl=&quot;同上&quot;, value=&quot;a.b&quot;, hashMethod=&quot;md5&quot;)上面的注解，如果方法返回值为：[\n    &#039;a&#039; =&gt;  [\n        &#039;b&#039; =&gt;  123,\n    ],\n]则会将123写入缓存。"},{"id":167,"title":"内存缓存","pageTitle":"内存缓存","url":"components/cache/memory.html","content":"内存缓存目录缓存数据储存在全局存储对象里。配置&lt;?php\nreturn [\n    &#039;caches&#039;    =&gt;    [\n        // 缓存名称\n        &#039;alias1&#039;    =&gt;    [\n            // 缓存驱动类\n            &#039;handlerClass&#039;    =&gt;    \\Imi\\Cache\\Handler\\Memory::class,\n            // 驱动实例配置，暂无任何配置\n            &#039;option&#039;        =&gt;    [\n            ],\n        ],\n    ],\n];本驱动不支持也没有必要支持序列化"},{"id":163,"title":"Redis 缓存","pageTitle":"Redis 缓存","url":"components/cache/redis.html","content":"Redis 缓存目录使用 redis 的 set 和 get 方法实现，支持 ttl配置return [\n    &#039;caches&#039;    =&gt;    [\n        // 缓存名称\n        &#039;alias1&#039;    =&gt;    [\n            // 缓存驱动类\n            &#039;handlerClass&#039;    =&gt;    \\Imi\\Cache\\Handler\\Redis::class,\n            // 驱动实例配置\n            &#039;option&#039;        =&gt;    [\n                &#039;poolName&#039;              =&gt;  &#039;连接池名称&#039;,\n                &#039;prefix&#039;                =&gt;  &#039;&#039;, // 缓存键前缀\n                &#039;formatHandlerClass&#039;    =&gt;  null, // 数据读写修改器\n                &#039;replaceDot&#039;            =&gt;  false, // 将 key 中的 &quot;.&quot; 替换为 &quot;:&quot;\n            ],\n        ],\n    ],\n];formatHandlerClass 可选：Imi\\Util\\Format\\Json、Imi\\Util\\Format\\PhpSerialize，或者可以自行实现Imi\\Util\\Format\\IFormat接口"},{"id":164,"title":"RedisHash 缓存","pageTitle":"RedisHash 缓存","url":"components/cache/redisHash.html","content":"RedisHash 缓存目录使用 redis 的 hash，即 hset 和 hget 方法实现，不支持ttl使用时需要注意，key格式为hashkey-&gt;member，即为$redis-&gt;hget(&#039;hashkey&#039;, &#039;member&#039;)配置return [\n    &#039;caches&#039;    =&gt;    [\n        // 缓存名称\n        &#039;alias1&#039;    =&gt;    [\n            // 缓存驱动类\n            &#039;handlerClass&#039;    =&gt;    \\Imi\\Cache\\Handler\\RedisHash::class,\n            // 驱动实例配置\n            &#039;option&#039;        =&gt;    [\n                &#039;poolName&#039;    =&gt;    &#039;连接池名称&#039;,\n                &#039;separator&#039; =&gt;    &#039;分隔符，分隔 hash key和 member，默认为-&gt;&#039;,\n                &#039;defaultHashKey&#039;    =&gt;    &#039;imi:RedisHashCache&#039;, // 默认缺省的 hash key\n                &#039;formatHandlerClass&#039;    =&gt;    null, // 数据读写修改器\n            ],\n        ],\n    ],\n];formatHandlerClass 可选：Imi\\Util\\Format\\Json、Imi\\Util\\Format\\PhpSerialize，或者可以自行实现Imi\\Util\\Format\\IFormat接口"},{"id":166,"title":"请求上下文缓存","pageTitle":"请求上下文缓存","url":"components/cache/requestContext.html","content":"请求上下文缓存目录缓存数据存储在请求上下文里。配置&lt;?php\nreturn [\n    &#039;caches&#039;    =&gt;    [\n        // 缓存名称\n        &#039;alias1&#039;    =&gt;    [\n            // 缓存驱动类\n            &#039;handlerClass&#039;    =&gt;    \\Imi\\Cache\\Handler\\RequestContext::class,\n            // 驱动实例配置\n            &#039;option&#039;        =&gt;    [\n                &#039;key&#039; =&gt; &#039;RequestContextCache&#039;, // 在请求上下文中的键名\n            ],\n        ],\n    ],\n];本驱动不支持也没有必要支持序列化"},{"id":211,"title":"配置中心","pageTitle":"配置中心","url":"components/config/center.html","content":"配置中心目录我们通常会把一些配置放到专门的配置文件里，一般会随着代码分发和部署。在需要修改配置的时候，需要重新走发版流程，显得非常笨重和不方便。这时候，配置中心的作用就体现了。我们从配置中心拿配置，而不是写死在项目里，可以比较灵活地实现不中断服务的配置发布。支持的配置中心： Nacos (imi-nacos) Apollo etcd (imi-etcd) (@ChrisLeeAreemm) Consul Zookeeper (imi-zookeeper)支持的容器：SwooleWorkerman设计监听模式工作进程模式每个进程自己监听，适用于 Swoole 环境。进程模式由一个专门的进程监听，并通知到其它进程。适用于 Swoole、Workerman 环境。对配置中心压力更小。php-fpm 模式比较特殊，是走的文件缓存逻辑。超过一定时间才去请求配置中心，获取数据，实时性有一定影响。监听方式客户端轮询客户端定时请求配置中心，对配置中心服务端压力较大，但是最为通用。服务端推送（长轮询）如果配置中心支持服务端推送（长轮询），建议用这个方式，对配置中心服务端压力较小。使用Nacos安装：composer require imiphp/imi-nacos:~2.1.0配置：@app.beans：[\n    &#039;ConfigCenter&#039; =&gt; [\n        // &#039;mode&#039;    =&gt; \\Imi\\ConfigCenter\\Enum\\Mode::WORKER, // 工作进程模式\n        &#039;mode&#039;    =&gt; \\Imi\\ConfigCenter\\Enum\\Mode::PROCESS, // 进程模式\n        &#039;configs&#039; =&gt; [\n            &#039;nacos&#039; =&gt; [\n                &#039;driver&#039;  =&gt; \\Imi\\Nacos\\Config\\NacosConfigDriver::class,\n                // 客户端连接配置\n                &#039;client&#039;  =&gt; [\n                    &#039;host&#039;                =&gt; &#039;127.0.0.1&#039;, // 主机名\n                    &#039;port&#039;                =&gt; 8848, // 端口号\n                    &#039;prefix&#039;              =&gt; &#039;/&#039;, // 前缀\n                    &#039;username&#039;            =&gt; &#039;nacos&#039;, // 用户名\n                    &#039;password&#039;            =&gt; &#039;nacos&#039;, // 密码\n                    &#039;timeout&#039;             =&gt; 60000, // 网络请求超时时间，单位：毫秒\n                    &#039;ssl&#039;                 =&gt; false, // 是否使用 ssl(https) 请求\n                    &#039;authorizationBearer&#039; =&gt; false, // 是否使用请求头 Authorization: Bearer {accessToken} 方式传递 Token，旧版本 Nacos 需要设为 true\n                ],\n                // 监听器配置\n                &#039;listener&#039; =&gt; [\n                    &#039;timeout&#039;         =&gt; 30000, // 配置监听器长轮询超时时间，单位：毫秒\n                    &#039;failedWaitTime&#039;  =&gt; 3000, // 失败后等待重试时间，单位：毫秒\n                    &#039;savePath&#039;        =&gt; Imi::getRuntimePath(&#039;config-cache&#039;), // 配置保存路径，默认为空不保存到文件。php-fpm 模式请一定要设置！\n                    &#039;fileCacheTime&#039;   =&gt; 30, // 文件缓存时间，默认为0时不受缓存影响，此配置只影响 pull 操作。php-fpm 模式请一定要设置为大于0的值！\n                    &#039;pollingInterval&#039; =&gt; 10000, // 客户端轮询间隔时间，单位：毫秒\n                ],\n                // 配置项\n                &#039;configs&#039; =&gt; [\n                    &#039;nacos&#039; =&gt; [\n                        &#039;key&#039;   =&gt; &#039;imi-nacos-key1&#039;,\n                        &#039;group&#039; =&gt; &#039;imi&#039;,\n                        &#039;type&#039;  =&gt; &#039;json&#039;, // 配置内容类型，Nacos &gt;= 1.3 可以不配，由配置项类型智能指定\n                    ],\n                ],\n            ],\n        ],\n    ],\n]获取配置：\\Imi\\Config::get(&#039;nacos&#039;); // 对应 imi-nacos-key1写入配置：/** @var \\Imi\\ConfigCenter\\ConfigCenter $configCenter */\n$configCenter = App::getBean(&#039;ConfigCenter&#039;);\n$name = &#039;imi-nacos-key1&#039;;\n$group = &#039;imi&#039;;\n$type = &#039;json&#039;;\n$value = json_encode([&#039;imi&#039; =&gt; &#039;niubi&#039;]);\n$configCenter-&gt;getDriver(&#039;nacos&#039;)-&gt;push($name, $value, [\n    &#039;group&#039; =&gt; $group,\n    &#039;type&#039;  =&gt; $type,\n]);Etcd安装：composer require imiphp/imi-etcd:~2.1.0配置：@app.beans：use function Imi\\env;\nuse Imi\\Util\\Imi;\n\n[\n    &#039;ConfigCenter&#039; =&gt; [\n        // &#039;mode&#039;    =&gt; \\Imi\\ConfigCenter\\Enum\\Mode::WORKER, // 工作进程模式\n        &#039;mode&#039;    =&gt; \\Imi\\ConfigCenter\\Enum\\Mode::PROCESS, // 进程模式\n        &#039;configs&#039; =&gt; [\n            &#039;etcd&#039; =&gt; [\n                &#039;driver&#039;  =&gt; \\Imi\\Etcd\\Config\\EtcdConfigDriver::class,\n                // 客户端连接配置\n                &#039;client&#039;  =&gt; [\n                    &#039;scheme&#039;              =&gt; env(&#039;IMI_ETCD_SCHEME&#039;, &#039;http&#039;), // 主机名\n                    &#039;host&#039;                =&gt; env(&#039;IMI_ETCD_HOST&#039;, &#039;127.0.0.1&#039;), // 主机名\n                    &#039;port&#039;                =&gt; env(&#039;IMI_ETCD_PORT&#039;, 2379), // 端口号\n                    &#039;timeout&#039;             =&gt; env(&#039;IMI_ETCD_TIMEOUT&#039;, 6000), // 网络请求超时时间，单位：毫秒\n                    &#039;ssl&#039;                 =&gt; env(&#039;IMI_ETCD_SSL&#039;, false), // 是否使用 ssl(https) 请求\n                    &#039;version&#039;             =&gt; env(&#039;IMI_ETCD_VERSION&#039;, &#039;v3&#039;), /**\n                     * v3 v3alpha v3beta v2\n                     * etcd v3.2以及之前版本只使用[CLIENT-URL]/v3alpha/*。\n                     * etcd v3.3使用[CLIENT-URL]/v3beta/*保持[CLIENT-URL]/v3alpha/*使用。\n                     * etcd v3.4使用[CLIENT-URL]/v3/*保持[CLIENT-URL]/v3beta/*使用。\n                     * [CLIENT-URL]/v3alpha/*被抛弃使用。\n                     * etcd v3.5以及最新版本只使用[CLIENT-URL]/v3/*。\n                     * [CLIENT-URL]/v3beta/*被抛弃使用。\n                     */\n                    &#039;pretty&#039;              =&gt; env(&#039;IMI_ETCD_PRETTY&#039;, true),\n                    &#039;sslCert&#039;             =&gt; &#039;&#039;,\n                    &#039;sslKey&#039;              =&gt; &#039;&#039;\n                ],\n                // 监听器配置\n                &#039;listener&#039; =&gt; [\n                    &#039;timeout&#039;         =&gt; 30000, // 配置监听器长轮询超时时间，单位：毫秒\n                    &#039;failedWaitTime&#039;  =&gt; 3000, // 失败后等待重试时间，单位：毫秒\n                    &#039;savePath&#039;        =&gt; Imi::getRuntimePath(&#039;config-cache&#039;), // 配置保存路径，默认为空不保存到文件。php-fpm 模式请一定要设置！\n                    &#039;fileCacheTime&#039;   =&gt; 30, // 文件缓存时间，默认为0时不受缓存影响，此配置只影响 pull 操作。php-fpm 模式请一定要设置为大于0的值！\n                    &#039;pollingInterval&#039; =&gt; 10000, // 客户端轮询间隔时间，单位：毫秒\n                ],\n                // 配置项\n                &#039;configs&#039; =&gt; [\n                    &#039;etcd&#039; =&gt; [\n                        &#039;key&#039;  =&gt; &#039;imi-etcd-key1&#039;,\n                    ],\n                ],\n            ],\n        ],\n    ],\n]获取配置：\\Imi\\Config::get(&#039;etcd&#039;); // 对应 imi-etcd-key1写入配置：/** @var \\Imi\\ConfigCenter\\ConfigCenter $configCenter */\n$configCenter = App::getBean(&#039;ConfigCenter&#039;);\n$name = &#039;imi-etcd-key1&#039;;\n$value = json_encode([&#039;imi&#039; =&gt; &#039;niubi&#039;]);\n$options = [];\n$configCenter-&gt;getDriver(&#039;etcd&#039;)-&gt;push($name, $value);\n$configCenter-&gt;getDriver(&#039;etcd&#039;)-&gt;push($name, $value, $options);ZooKeeperSwoole 用户请安装 swoole-zookeeper 扩展。非 Swoole 用户请安装 php-zookeeper 扩展。安装：composer require imiphp/imi-zookeeper:~2.1.0配置：@app.beans：use function Imi\\env;\nuse Imi\\Util\\Imi;\n\n[\n    &#039;ConfigCenter&#039; =&gt; [\n        // &#039;mode&#039;    =&gt; \\Imi\\ConfigCenter\\Enum\\Mode::WORKER, // 工作进程模式\n        &#039;mode&#039;    =&gt; \\Imi\\ConfigCenter\\Enum\\Mode::PROCESS, // 进程模式\n        &#039;configs&#039; =&gt; [\n            &#039;zookeeper&#039; =&gt; [\n                &#039;driver&#039;  =&gt; \\Imi\\ZooKeeper\\Config\\SwooleZooKeeperConfigDriver::class, // Swoole 驱动\n                // &#039;driver&#039;  =&gt; \\Imi\\ZooKeeper\\Config\\ZooKeeperConfigDriver::class, // 非 Swoole 驱动\n                // 客户端连接配置\n                &#039;client&#039;  =&gt; [\n                    &#039;host&#039;    =&gt; env(&#039;IMI_ZOOKEEPER_HOST&#039;, &#039;127.0.0.1:2181&#039;), // 主机名:端口\n                    &#039;timeout&#039; =&gt; 10, // 网络请求超时时间，单位：秒\n                ],\n                // 监听器配置\n                &#039;listener&#039; =&gt; [\n                    &#039;timeout&#039;         =&gt; 30000, // 配置监听器长轮询超时时间，单位：毫秒\n                    &#039;failedWaitTime&#039;  =&gt; 3000, // 失败后等待重试时间，单位：毫秒\n                    &#039;savePath&#039;        =&gt; Imi::getRuntimePath(&#039;config-cache&#039;), // 配置保存路径，默认为空不保存到文件。php-fpm 模式请一定要设置！\n                    &#039;fileCacheTime&#039;   =&gt; 30, // 文件缓存时间，默认为0时不受缓存影响，此配置只影响 pull 操作。php-fpm 模式请一定要设置为大于0的值！\n                    &#039;pollingInterval&#039; =&gt; 10000, // 客户端轮询间隔时间，单位：毫秒\n                ],\n                // 配置项\n                &#039;configs&#039; =&gt; [\n                    &#039;zookeeper&#039; =&gt; [\n                        &#039;key&#039;   =&gt; &#039;imi-zooKeeper-key1&#039;,\n                        &#039;type&#039;  =&gt; &#039;json&#039;, // 配置内容类型\n                    ],\n                ],\n            ],\n        ],\n    ],\n]获取配置：\\Imi\\Config::get(&#039;zookeeper&#039;); // 对应 imi-zooKeeper-key1写入配置：/** @var \\Imi\\ConfigCenter\\ConfigCenter $configCenter */\n$configCenter = App::getBean(&#039;ConfigCenter&#039;);\n$name = &#039;imi-zooKeeper-key1&#039;;\n$value = json_encode([&#039;imi&#039; =&gt; &#039;niubi&#039;]);\n$configCenter-&gt;getDriver(&#039;zookeeper&#039;)-&gt;push($name, $value);开发配置中心驱动上面的 imi 配置中心组件，都是基于 imi-config-center 开发的，你可以参考他们的代码进行开发实现其它配置中心驱动。"},{"id":125,"title":"配置(Config)","pageTitle":"配置(Config)","url":"components/config/index.html","content":"配置(Config)目录关于配置文件的定义，请看基础入门-配置文件章节。读取配置类：Imi\\Config读取项目配置echo Config::get(&#039;@app.namespace&#039;); // namespace 可以换为其它的节读取主服务器配置echo Config::get(&#039;@server.main.namespace&#039;); // namespace 可以换为其它的节读取子服务器配置// 如子服务器名为abc，读取它下面的配置\necho Config::get(&#039;@server.abc.namespace&#039;); // namespace 可以换为其它的节智能读取注意！只限在请求中使用该方式！优先读取当前服务器配置，如果没有配置则取项目配置（@app）echo Config::get(&#039;@currentServer.db.default&#039;);"},{"id":212,"title":"通过配置中心配置连接池","pageTitle":"通过配置中心配置连接池","url":"components/config/pool.html","content":"通过配置中心配置连接池imi 支持在配置中心里配置连接池的信息。这里以 Nacos、MySQL 为例，其它配置中心驱动或 Redis 连接池配置写法以此类推。安装组件参考 配置中心 中的相关说明。创建配置在配置中心系统里创建一个配置，我们这里命名为 mysql.resource，Group 设置为 imi，你也可以改为其它名字。配置内容：（相关配置请修改为你自己的）{\n    &quot;host&quot;: &quot;127.0.0.1&quot;,\n    &quot;port&quot;: 3306,\n    &quot;username&quot;: &quot;root&quot;,\n    &quot;password&quot;: &quot;root&quot;,\n    &quot;database&quot;: &quot;mysql&quot;,\n    &quot;charset&quot;: &quot;utf8mb4&quot;\n}修改 imi 配置配置好连接池，这里的 resource 配置是写的空数组，当然你也可以配置一个可以连接的资源配置。config.php：// 连接池配置\n&#039;pools&#039;    =&gt; [\n    // 主数据库\n    &#039;maindb&#039;    =&gt; [\n        &#039;pool&#039;    =&gt; [\n            &#039;class&#039;        =&gt; \\Imi\\Swoole\\Db\\Pool\\CoroutineDbPool::class,\n            &#039;config&#039;       =&gt; [\n                &#039;maxResources&#039;    =&gt; 10,\n                &#039;minResources&#039;    =&gt; 1,\n            ],\n        ],\n        &#039;resource&#039;    =&gt; [],\n    ],\n],\n&#039;db&#039;    =&gt; [\n    &#039;defaultPool&#039;   =&gt; &#039;maindb&#039;, // 默认连接池\n],bean.php：[\n    &#039;ConfigCenter&#039; =&gt; [\n        // 其它配置参考《配置中心》文档\n        &#039;configs&#039; =&gt; [\n            &#039;nacos&#039; =&gt; [\n                // 其它配置参考《配置中心》文档\n                // 配置项\n                &#039;configs&#039; =&gt; [\n                    // key 指定覆盖的配置键名\n                    &#039;@app.pools.maindb.resource&#039; =&gt; [\n                        &#039;key&#039;   =&gt; &#039;mysql.resource&#039;, // 第一步创建的配置名称\n                        &#039;group&#039; =&gt; &#039;imi&#039;, // 分组名，仅 Nacos\n                        &#039;type&#039;  =&gt; &#039;json&#039;, // 配置内容类型，我们使用的是 json\n                    ],\n                ],\n            ],\n        ],\n    ],\n]启动服务vendor/bin/imi-swoole swoole/start完美生效！"},{"id":132,"title":"连接池配置","pageTitle":"连接池配置","url":"components/db/config.html","content":"连接池配置目录数据库连接池配置方式已经在连接池里讲过，这里就不重复了，直接说使用方法。连接池适用于 Swoole 环境标准写法：从 imi v1.2.1 版本开始支持&lt;?php\nreturn [\n    &#039;db&#039;    =&gt; [\n        &#039;defaultPool&#039;   =&gt; &#039;alias1&#039;, // 默认连接池\n        &#039;statement&#039;     =&gt;  [\n            &#039;cache&#039; =&gt;  true, // 是否开启 Statement 缓存，默认开启\n            &#039;maxCacheCount&#039; =&gt; 0, // Statement 最大缓存数量，默认为 0 则不限制。会根据最后使用时间来决定移除缓存。\n        ],\n    ],\n    &#039;pools&#039; =&gt; [\n        // 连接池名称\n        &#039;alias1&#039; =&gt; [\n            &#039;pool&#039; =&gt; [\n                // 协程池类名\n                &#039;class&#039;    =&gt;    \\Imi\\Swoole\\Db\\Pool\\CoroutineDbPool::class,\n                // 同步池类名，一般用不着\n                // &#039;class&#039;     =&gt;    \\Imi\\Db\\Pool\\SyncDbPool::class,\n                // 连接池配置\n                &#039;config&#039; =&gt; [\n                    // 池子中最多资源数\n                    // &#039;maxResources&#039; =&gt; 10,\n                    // 池子中最少资源数\n                    // &#039;minResources&#039; =&gt; 2,\n                    // 资源回收时间间隔，单位：秒\n                    // &#039;gcInterval&#039; =&gt; 60,\n                    // 获取资源最大存活时间，单位：秒\n                    // &#039;maxActiveTime&#039; =&gt; 3600,\n                    // 等待资源最大超时时间，单位：毫秒\n                    // &#039;waitTimeout&#039; =&gt; 3000,\n                    // 心跳时间间隔，单位：秒\n                    // &#039;heartbeatInterval&#039; =&gt; null,\n                    // 当获取资源时，是否检查状态\n                    // &#039;checkStateWhenGetResource&#039; =&gt; true,\n                    // 每次获取资源最长使用时间，单位：秒；为 null 则不限制\n                    // &#039;maxUsedTime&#039; =&gt; null,\n                    // 资源创建后最大空闲回收时间，单位：秒；为 null 则不限制\n                    // &#039;maxIdleTime&#039; =&gt; null,\n                    // 当前请求上下文资源检查状态间隔，单位：支持小数的秒；为 null 则不限制\n                    // &#039;requestResourceCheckInterval&#039; =&gt; 30,\n                    // 负载均衡-轮询\n                    // &#039;resourceConfigMode&#039; =&gt; ResourceConfigMode::ROUND_ROBIN,\n                    // 负载均衡-随机\n                    // &#039;resourceConfigMode&#039; =&gt; ResourceConfigMode::RANDOM,\n                ],\n            ],\n            // 连接池资源配置\n            &#039;resource&#039; =&gt; [\n                &#039;host&#039; =&gt; &#039;127.0.0.1&#039;,\n                &#039;username&#039; =&gt; &#039;root&#039;,\n                &#039;password&#039; =&gt; &#039;root&#039;,\n                &#039;database&#039; =&gt; &#039;database&#039;,\n                &#039;prefix&#039;   =&gt; &#039;&#039;, // 表前缀\n                // &#039;port&#039;    =&gt; &#039;3306&#039;,\n                // &#039;timeout&#039; =&gt; &#039;建立连接超时时间&#039;,\n                // &#039;charset&#039; =&gt; &#039;&#039;,\n                // 使用 hook pdo 驱动（缺省默认）\n                // &#039;dbClass&#039; =&gt; &#039;PdoMysqlDriver&#039;,\n                // 使用 hook mysqli 驱动\n                // &#039;dbClass&#039; =&gt; &#039;MysqliDriver&#039;,\n                // 使用 Swoole MySQL 驱动\n                // &#039;dbClass&#039; =&gt; &#039;SwooleMysqlDriver&#039;,\n                // 数据库连接后，执行初始化的 SQL\n                // &#039;initSqls&#039; =&gt; [\n                //     &#039;select 1&#039;,\n                //     &#039;select 2&#039;,\n                // ],\n            ],\n            // uri 写法\n            // &#039;resource&#039;  =&gt;  [\n            //     &#039;tcp://192.168.0.222/?username=root&amp;password=root&amp;database=db_test&amp;timeout=60&#039;,\n            //     &#039;tcp://192.168.0.222/?username=root&amp;password=root&amp;database=db_test&amp;timeout=60&#039;,\n            // ],\n            // &#039;resource&#039;  =&gt;  &#039;tcp://192.168.0.222/?username=root&amp;password=root&amp;database=db_test&amp;timeout=60;tcp://192.168.0.222/?username=root&amp;password=root&amp;database=db_test&amp;timeout=60&#039;,\n        ],\n        // 从库配置\n        // 原连接池名后加.slave即为从库配置，非必设\n        // 如果配置了，默认查询走从库，增删改走主库\n        // 如果在事务中，默认都走主库\n        &#039;alias1.slave&#039; =&gt; [\n            &#039;pool&#039; =&gt; [\n                // 协程池类名\n                &#039;class&#039;    =&gt;    \\Imi\\Swoole\\Db\\Pool\\CoroutineDbPool::class,\n                // 同步池类名，一般用不着\n                // &#039;class&#039;     =&gt;    \\Imi\\Db\\Pool\\SyncDbPool::class,\n                // 连接池配置\n                &#039;config&#039; =&gt; [\n                    // 池子中最多资源数\n                    // &#039;maxResources&#039; =&gt; 10,\n                    // 池子中最少资源数\n                    // &#039;minResources&#039; =&gt; 2,\n                    // 资源回收时间间隔，单位：秒\n                    // &#039;gcInterval&#039; =&gt; 60,\n                    // 获取资源最大存活时间，单位：秒\n                    // &#039;maxActiveTime&#039; =&gt; 3600,\n                    // 等待资源最大超时时间，单位：毫秒\n                    // &#039;waitTimeout&#039; =&gt; 3000,\n                    // 心跳时间间隔，单位：秒\n                    // &#039;heartbeatInterval&#039; =&gt; null,\n                    // 当获取资源时，是否检查状态\n                    // &#039;checkStateWhenGetResource&#039; =&gt; true,\n                    // 每次获取资源最长使用时间，单位：秒；为 null 则不限制\n                    // &#039;maxUsedTime&#039; =&gt; null,\n                    // 资源创建后最大空闲回收时间，单位：秒；为 null 则不限制\n                    // &#039;maxIdleTime&#039; =&gt; null,\n                    // 当前请求上下文资源检查状态间隔，单位：支持小数的秒；为 null 则不限制\n                    // &#039;requestResourceCheckInterval&#039; =&gt; 30,\n                    // 负载均衡-轮询\n                    // &#039;resourceConfigMode&#039; =&gt; ResourceConfigMode::ROUND_ROBIN,\n                    // 负载均衡-随机\n                    // &#039;resourceConfigMode&#039; =&gt; ResourceConfigMode::RANDOM,\n                ],\n            ],\n            // 连接池资源配置\n            &#039;resource&#039; =&gt; [\n                &#039;host&#039; =&gt; &#039;127.0.0.1&#039;,\n                &#039;username&#039; =&gt; &#039;root&#039;,\n                &#039;password&#039; =&gt; &#039;root&#039;,\n                &#039;database&#039; =&gt; &#039;database&#039;,\n                &#039;prefix&#039;   =&gt; &#039;&#039;, // 表前缀\n                // &#039;port&#039;    =&gt; &#039;3306&#039;,\n                // &#039;timeout&#039; =&gt; &#039;建立连接超时时间&#039;,\n                // &#039;charset&#039; =&gt; &#039;&#039;,\n                // 使用 hook pdo 驱动（缺省默认）\n                // &#039;dbClass&#039; =&gt; &#039;PdoMysqlDriver&#039;,\n                // 使用 hook mysqli 驱动\n                // &#039;dbClass&#039; =&gt; &#039;MysqliDriver&#039;,\n                // 使用 Swoole MySQL 驱动\n                // &#039;dbClass&#039; =&gt; &#039;SwooleMysqlDriver&#039;,\n                // 数据库连接后，执行初始化的 SQL\n                // &#039;initSqls&#039; =&gt; [\n                //     &#039;select 1&#039;,\n                //     &#039;select 2&#039;,\n                // ],\n            ],\n            // uri 写法\n            // &#039;resource&#039;  =&gt;  [\n            //     &#039;tcp://192.168.0.222/?username=root&amp;password=root&amp;database=db_test&amp;timeout=60&#039;,\n            //     &#039;tcp://192.168.0.222/?username=root&amp;password=root&amp;database=db_test&amp;timeout=60&#039;,\n            // ],\n            // &#039;resource&#039;  =&gt;  &#039;tcp://192.168.0.222/?username=root&amp;password=root&amp;database=db_test&amp;timeout=60;tcp://192.168.0.222/?username=root&amp;password=root&amp;database=db_test&amp;timeout=60&#039;,\n        ]\n    ],\n];单例配置用于 php-fpm、Workerman 下&lt;?php\n\nreturn [\n    &#039;db&#039;    =&gt; [\n        &#039;defaultPool&#039;   =&gt; &#039;alias1&#039;, // 默认连接名\n        &#039;statement&#039;     =&gt;  [\n            &#039;cache&#039; =&gt;  true, // 是否开启 statement 缓存，默认开启\n        ],\n        &#039;connections&#039; =&gt; [\n            &#039;alias1&#039; =&gt; [\n                &#039;host&#039; =&gt; &#039;127.0.0.1&#039;,\n                &#039;username&#039; =&gt; &#039;root&#039;,\n                &#039;password&#039; =&gt; &#039;root&#039;,\n                &#039;database&#039; =&gt; &#039;database&#039;,\n                &#039;prefix&#039;   =&gt; &#039;&#039;, // 表前缀\n                // &#039;port&#039;    =&gt; &#039;3306&#039;,\n                // &#039;timeout&#039; =&gt; &#039;建立连接超时时间&#039;,\n                // &#039;charset&#039; =&gt; &#039;&#039;,\n                // 使用 hook pdo 驱动（缺省默认）\n                // &#039;dbClass&#039; =&gt; &#039;PdoMysqlDriver&#039;,\n                // 使用 hook mysqli 驱动\n                // &#039;dbClass&#039; =&gt; &#039;MysqliDriver&#039;,\n                // 使用 Swoole MySQL 驱动\n                // &#039;dbClass&#039; =&gt; &#039;SwooleMysqlDriver&#039;,\n                // 数据库连接后，执行初始化的 SQL\n                // &#039;initSqls&#039; =&gt; [\n                //     &#039;select 1&#039;,\n                //     &#039;select 2&#039;,\n                // ],\n                // 当获取资源时，是否检查状态\n                // &#039;checkStateWhenGetResource&#039; =&gt; true,\n                // 心跳时间间隔，单位：秒\n                // &#039;heartbeatInterval&#039; =&gt; null,\n            ],\n        ],\n    ],\n];"},{"id":133,"title":"数据库操作","pageTitle":"数据库操作","url":"components/db/index.html","content":"数据库操作目录Db 驱动对象操作用于直接执行 SQL// 获取数据库连接实例，每个RequestContext中共用一个\n$db = Db::getInstance();\n// 读库\n$db = Db::getInstance($poolName, QueryType::READ);\n// 写库\n$db = Db::getInstance($poolName, QueryType::WRITE);\n\n// ---\n\n// 执行 SQL 并返回受影响的行数\n// public static function exec(string $sql, array $bindValues = [], ?string $poolName = null, int $queryType = QueryType::WRITE): int\n$rows = Db::exec(&#039;update tb_xxx set age=111 where id=?&#039;, [123]);\n\n// 执行 SQL 返回结果\n// public static function select(string $sql, array $bindValues = [], ?string $poolName = null, int $queryType = QueryType::WRITE): ?IResult\n$result = Db::select(&#039;select * from tb_xxx id=?&#039;, [123]);\nvar_dump($result-&gt;getArray()); // 更多用法参考文档\n\n// 预处理\n$stmt = Db::prepare(&#039;select * from tb_xxx id=?&#039;);\n$stmt-&gt;execute([123]);\nvar_dump($stmt-&gt;fetchAll()); // 更多用法参考文档\n\n// ---\n\n// 获取新的数据库连接实例\n$db = Db::getNewInstance();\n// 读库\n$db = Db::getNewInstance($poolName, QueryType::READ);\n// 写库\n$db = Db::getNewInstance($poolName, QueryType::WRITE);\n// 释放连接，回归连接池，配合 getNewInstance() 使用\nDb::release($db);\n\n// ---\n\n$returnValue = Db::use(function(IDb $db){\n    // 操作 $db\n    return &#039;imi&#039;;\n}); // imi方法/**\n * 打开\n */\npublic function open(): bool;\n\n/**\n * 关闭.\n */\npublic function close(): void;\n\n/**\n * 是否已连接.\n */\npublic function isConnected(): bool;\n\n/**\n * ping 检查是否已连接.\n */\npublic function ping(): bool;\n\n/**\n * 启动一个事务\n */\npublic function beginTransaction(): bool;\n\n/**\n * 提交一个事务\n */\npublic function commit(): bool;\n\n/**\n * 回滚事务\n * 支持设置回滚事务层数，如果不设置则为全部回滚.\n */\npublic function rollBack(?int $levels = null): bool;\n\n/**\n * 获取事务层数.\n */\npublic function getTransactionLevels(): int;\n\n/**\n * 返回错误码\n *\n * @return mixed\n */\npublic function errorCode();\n\n/**\n * 返回错误信息.\n */\npublic function errorInfo(): string;\n\n/**\n * 获取最后一条执行的SQL语句.\n */\npublic function lastSql(): string;\n\n/**\n * 执行一条 SQL 语句，并返回受影响的行数.\n */\npublic function exec(string $sql): int;\n\n/**\n * 批量执行 SQL，返回查询结果.\n */\npublic function batchExec(string $sql): array;\n\n/**\n * 取回一个数据库连接的属性.\n *\n * @param mixed $attribute\n *\n * @return mixed\n */\npublic function getAttribute($attribute);\n\n/**\n * 设置属性.\n *\n * @param mixed $attribute\n * @param mixed $value\n */\npublic function setAttribute($attribute, $value): bool;\n\n/**\n * 检查是否在一个事务内.\n */\npublic function inTransaction(): bool;\n\n/**\n * 返回最后插入行的ID或序列值\n */\npublic function lastInsertId(?string $name = null): string;\n\n/**\n * 返回受上一个 SQL 语句影响的行数.\n */\npublic function rowCount(): int;\n\n/**\n * 准备执行语句并返回一个语句对象\n */\npublic function prepare(string $sql, array $driverOptions = []): \\Imi\\Db\\Interfaces\\IStatement;\n\n/**\n * 执行一条SQL语句，返回一个结果集作为PDOStatement对象\n */\npublic function query(string $sql): \\Imi\\Db\\Interfaces\\IStatement;\n\n/**\n * 获取原对象实例.\n *\n * @return object\n */\npublic function getInstance();\n\n/**\n * Get 事务管理.\n */\npublic function getTransaction(): \\Imi\\Db\\Transaction\\Transaction;\n\n/**\n * 创建查询构建器.\n */\npublic function createQuery(?string $modelClass = null): \\Imi\\Db\\Query\\Interfaces\\IQuery;预处理使用预处理可以防止 SQL 注入。$db = Db::getNewInstance();\n\n$stmt = $db-&gt;prepare(&#039;select ?&#039;); // 预处理问号形式\n$stmt-&gt;execute([1]); // 执行只能传索引数组\n\n$stmt = $db-&gt;prepare(&#039;select :abc&#039;); // 预处理定义参数名\n$stmt-&gt;execute([&#039;:abc&#039; =&gt; 1]); // 执行可以带冒号传参\n$stmt-&gt;execute([&#039;abc&#039; =&gt; 1]); // 执行可以不带冒号传参查询构建器imi 中数据库查询连贯操作都来自于查询器，查询器的创建方式：use Imi\\Db\\Db;\n$query = Db::query();\n$query = Db::query(&#039;mysql2&#039;); // 指定连接池名\n$query = Db::query(&#039;mysql2&#039;, XXXModel::class); // 指定模型名\n$query = Db::query(&#039;mysql2&#039;, XXXModel::class, \\Imi\\Db\\Query\\QueryType::READ); // 从库事务获取连接顺带自动开启/提交/回滚事务：Db::transUse(function(IDb $db){\n\n});\nDb::transUse(function(IDb $db){\n\n}, $poolName, QueryType::WRITE);Db::transUse() 不能在回调中使用模型获取连接后，想要使用某个连接，执行事务操作，自动开启/提交/回滚事务：$db = Db::getInstance();\nDb::trans($db, function(IDb $db){\n\n});可以使用模型使用回调来使用当前上下文中的资源：Db::transContext(function(IDb $db){\n\n});\nDb::transContext(function(IDb $db){\n\n}, $poolName, QueryType::WRITE);可以使用模型手动控制事务：（不推荐）// 开启事务\nDb::getInstance()-&gt;beginTransaction();\n// 提交事务\nDb::getInstance()-&gt;commit();\n// 回滚事务\nDb::getInstance()-&gt;rollBack();自动事务处理：@Transaction 注解，类：Imi\\Db\\Annotation\\Transaction这个注解可以加在任意方法上，在方法调用前开启事务，在方法中抛出异常时回滚事务，方法成功返回时提交事务。@Transaction@Transaction(autoCommit=&quot;自动提交事务true/false，默认为true&quot;)例：use Imi\\Db\\Annotation\\Transaction;\n\n/**\n * @Transaction\n */\npublic function create()\n{\n    // 你的代码，抛异常就回滚，没异常就提交\n}事务类型：如果当前不在事务中则开启事务（默认）@Transaction(type=TransactionType::AUTO)事务嵌套@Transaction(type=TransactionType::NESTING)该方法必须在事务中被调用@Transaction(type=TransactionType::REQUIREMENT)部分回滚：@Transaction(rollbackType=RollbackType::PART, rollbackLevels=&quot;回滚层数，默认为1&quot;)事务监听：监听提交事务：$db = Db::getInstance();\n$db-&gt;getTransaction()-&gt;onTransactionCommit(function($param){\n    $data = $param-&gt;getData();\n    $db = $data[&#039;db&#039;];\n    $level = $data[&#039;level&#039;]; // 第几层事务，支持事务嵌套\n});监听回滚事务：$db = Db::getInstance();\n$db-&gt;getTransaction()-&gt;onTransactionRollback(function($param){\n    $data = $param-&gt;getData();\n    $db = $data[&#039;db&#039;];\n    $level = $data[&#039;level&#039;]; // 第几层事务，支持事务嵌套\n});指定表 (table/from)// 指定表名\nDb::query()-&gt;table(&#039;tb_test&#039;);\n// 指定表名并且设置别名\nDb::query()-&gt;table(&#039;tb_test&#039;, &#039;test&#039;);\n// 指定表名和数据库名\nDb::query()-&gt;table(&#039;tb_test&#039;, null, &#039;db1&#039;);\n// 传入参数原样代入到SQL中\nDb::query()-&gt;tableRaw(&#039;tb_test&#039;);\n\n// 如果连接配置设置了表前缀：tb_\nDb::query()-&gt;table(&#039;test&#039;)-&gt;select(); // select * from tb_test\n\n// 设置表前缀\nDb::query()-&gt;tablePrefix(&#039;&#039;)-&gt;table(&#039;test&#039;)-&gt;select(); // select * from testtable() 和 tableRaw() 也可以使用 from() 和 fromRaw() 代替。指定分区Db::query()-&gt;partition([&#039;a&#039;, &#039;b&#039;]); // 传数组\nDb::query()-&gt;partitionRaw(&#039;`a`,`b`&#039;); // 传 sql支持 MySQL 下的增删改查操作distinct// 结果唯一\nDb::query()-&gt;distinct();\n// 结果不唯一\nDb::query()-&gt;distinct(false);指定字段 (field)// 指定一个字段\nDb::query()-&gt;field(&#039;id&#039;);\n\n// 指定多个字段，也支持设置别名。空格和as都支持\nDb::query()-&gt;field(&#039;id&#039;, &#039;name1 name&#039;, &#039;age1 as age&#039;);\n\n// 和上面的用法等同\nDb::query()-&gt;field([&#039;id&#039;, &#039;name1 name&#039;, &#039;age1 as age&#039;]);\n\n// 传入参数原样代入到SQL中\nDb::query()-&gt;fieldRaw(&#039;id, name1 name, age1 as age&#039;);\n\n// 传入参数原样代入到SQL中，也支持参数绑定（不支持同时使用 ? 和 :xxx）\nDb::query()-&gt;fieldRaw(&#039;id, name1 name, age1 as age, ? as value&#039;, null, [123]);\nDb::query()-&gt;fieldRaw(&#039;id, name1 name, age1 as age, :value as value&#039;, null, [&#039;:value&#039; =&gt; 123]);条件 wherewhere// id = 1\nDb::query()-&gt;where(&#039;id&#039;, &#039;=&#039;, 1);\n\n// id &gt; 1\nDb::query()-&gt;where(&#039;id&#039;, &#039;&gt;&#039;, 1);\n\n// 使用 Raw 原样代入值，例：value = 1 + 2\nDb::query()-&gt;where(&#039;value&#039;, &#039;=&#039;, new \\Imi\\Db\\Query\\Raw(&#039;1 + 2&#039;));\n\n// title like &#039;%test%&#039;\nDb::query()-&gt;where(&#039;title&#039;, &#039;like&#039;, &#039;%test%&#039;);\n\n// id between 1 and 10\nDb::query()-&gt;where(&#039;id&#039;, &#039;between&#039;, [1, 10]);\n\n// id not between 1 and 10\nDb::query()-&gt;where(&#039;id&#039;, &#039;not between&#039;, [1, 10]);\n\n// or id = 1\nDb::query()-&gt;where(&#039;id&#039;, &#039;=&#039;, 1, &#039;or&#039;);\nDb::query()-&gt;orWhere(&#039;id&#039;, &#039;=&#039;, 1);\n\n// JSON 类型字段条件\nDb::query()-&gt;where(&#039;field1-&gt;uid&#039;, &#039;=&#039;, 1);TP 风格 where// select * from `tb_test` where (`id` = 1 or (`id` = 2 ) and `title` like &#039;%test%&#039; and `age` &gt; 18 and (`id` = 2 or (`id` = 3 ) ) )\nDb::query()-&gt;from(&#039;tb_test&#039;)-&gt;whereEx([\n    &#039;id&#039;    =&gt;  1,\n    &#039;or&#039;    =&gt;  [\n        &#039;id&#039;    =&gt;  2,\n    ],\n    &#039;title&#039; =&gt;  [&#039;like&#039;, &#039;%test%&#039;],\n    &#039;age&#039;   =&gt;  [&#039;&gt;&#039;, 18],\n    &#039;and&#039;   =&gt;  [\n        &#039;id&#039;    =&gt;  2,\n        &#039;or&#039;    =&gt;  [\n            &#039;id&#039;    =&gt;  3,\n        ]\n    ]\n]);whereRaw// 传入参数原样代入到SQL中\nDb::query()-&gt;whereRaw(&#039;id &gt;= 1&#039;);\n// 传入参数原样代入到SQL中，并且为or条件\nDb::query()-&gt;whereRaw(&#039;id &gt;= 1&#039;, &#039;or&#039;);\nDb::query()-&gt;orWhereRaw(&#039;id &gt;= 1&#039;);\n\n// 支持参数绑定（不支持同时使用 ? 和 :xxx）\n// 传入参数原样代入到SQL中，并且为or条件\nDb::query()-&gt;whereRaw(&#039;id &gt;= ?&#039;, &#039;or&#039;, [1]);\nDb::query()-&gt;orWhereRaw(&#039;id &gt;= ?&#039;, [1]);\nDb::query()-&gt;whereRaw(&#039;id &gt;= :value&#039;, &#039;or&#039;, [&#039;:value&#039; =&gt; 1]);\nDb::query()-&gt;orWhereRaw(&#039;id &gt;= :value&#039;, [&#039;:value&#039; =&gt; 1]);whereBrackets// where id = 1 or (age &lt; 14)\nDb::query()-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;whereBrackets(function(){\n    // 直接返回字符串\n    return &#039;age &lt; 14&#039;;\n}, &#039;or&#039;);\n// 支持使用 sql 语句: where id = 1 or (age &gt; 10 and age &lt; 14)\nDb::query()-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;whereBrackets(function(){\n    // 直接返回字符串\n    return [\n        \\Imi\\Db\\Query\\Where\\Where::raw(&#039;age &gt; 10&#039;),\n        new \\Imi\\Db\\Query\\Where\\Where(&#039;age&#039;, &#039;&lt;&#039;, 14),\n    ];\n}, &#039;or&#039;);\n// where id = 1 or (age &lt; 14)\nDb::query()-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;whereBrackets(function(){\n    // 直接返回字符串\n    return new \\Imi\\Db\\Query\\Where\\Where(&#039;age&#039;, &#039;&lt;&#039;, 14);\n}, &#039;or&#039;);\nDb::query()-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;orWhereBrackets(function(){\n    // 直接返回字符串\n    return new \\Imi\\Db\\Query\\Where\\Where(&#039;age&#039;, &#039;&lt;&#039;, 14);\n});whereStruct// or age &lt; 14\nDb::query()-&gt;whereStruct(new \\Imi\\Db\\Query\\Where\\Where(&#039;age&#039;, &#039;&lt;&#039;, 14), &#039;or&#039;);\nDb::query()-&gt;orWhereStruct(new \\Imi\\Db\\Query\\Where\\Where(&#039;age&#039;, &#039;&lt;&#039;, 14));其它// or age between 1 and 14\nDb::query()-&gt;whereBetween(&#039;age&#039;, 1, 14, &#039;or&#039;);\nDb::query()-&gt;orWhereBetween(&#039;age&#039;, 1, 14);\n\n// or age not between 1 and 14\nDb::query()-&gt;whereNotBetween(&#039;age&#039;, 1, 14, &#039;or&#039;);\nDb::query()-&gt;orWhereNotBetween(&#039;age&#039;, 1, 14);\n\n// or age in (1,2,3)\nDb::query()-&gt;whereIn(&#039;age&#039;, [1, 2, 3], &#039;or&#039;);\nDb::query()-&gt;orWhereIn(&#039;age&#039;, [1, 2, 3]);\n\n// or age not in (1,2,3)\nDb::query()-&gt;whereNotIn(&#039;age&#039;, [1, 2, 3], &#039;or&#039;);\nDb::query()-&gt;orWhereNotIn(&#039;age&#039;, [1, 2, 3]);\n\n// or age is null\nDb::query()-&gt;whereIsNull(&#039;age&#039;, &#039;or&#039;);\nDb::query()-&gt;orWhereIsNull(&#039;age&#039;);\n\n// or age is not null\nDb::query()-&gt;whereIsNotNull(&#039;age&#039;, &#039;or&#039;);\nDb::query()-&gt;orWhereIsNotNull(&#039;age&#039;);JSON 字段支持看如下代码，data为json类型字段，查询json对象中的member.age为11的记录Db::query()-&gt;where(&#039;data-&gt;member.age&#039;, &#039;=&#039;, 11)-&gt;select();join// select * from tb_test1 left join tb_test2 on tb_test1.aid = tb_test2.bid\nDb::query()-&gt;table(&#039;tb_test1&#039;)-&gt;join(&#039;tb_test2&#039;, &#039;tb_test1.aid&#039;, &#039;=&#039;, &#039;tb_test2.bid&#039;);\n// select * from tb_test1 left join tb_test2 as test2 on tb_test1.aid = test2.bid\nDb::query()-&gt;table(&#039;tb_test1&#039;)-&gt;join(&#039;tb_test2&#039;, &#039;tb_test1.aid&#039;, &#039;=&#039;, &#039;test2.bid&#039;, &#039;test&#039;);\n// select * from tb_test1 right join tb_test2 on tb_test1.aid = tb_test2.bid and tb_test1.age &gt; 14\nDb::query()-&gt;table(&#039;tb_test1&#039;)-&gt;join(&#039;tb_test2&#039;, &#039;tb_test1.aid&#039;, &#039;=&#039;, &#039;tb_test2.bid&#039;, null, new \\Imi\\Db\\Query\\Where\\Where(&#039;tb_test1.age&#039;, &#039;&gt;&#039;, &#039;14&#039;), &#039;right&#039;);\n\n// select * from tb_test1 left join tb_test2 on tb_test1.aid = tb_test2.bid\nDb::query()-&gt;table(&#039;tb_test1&#039;)-&gt;joinRaw(&#039;left join tb_test2 on tb_test1.aid = tb_test2.bid&#039;);\n\n// 支持参数绑定（不支持同时使用 ? 和 :xxx）\n// select * from tb_test1 left join tb_test2 on tb_test1.aid = tb_test2.bid and tb_test2.xxx = ?\nDb::query()-&gt;table(&#039;tb_test1&#039;)-&gt;joinRaw(&#039;left join tb_test2 on tb_test1.aid = tb_test2.bid and tb_test2.xxx = ?&#039;, [123]);\n// select * from tb_test1 left join tb_test2 on tb_test1.aid = tb_test2.bid and tb_test2.xxx = :value\nDb::query()-&gt;table(&#039;tb_test1&#039;)-&gt;joinRaw(&#039;left join tb_test2 on tb_test1.aid = tb_test2.bid and tb_test2.xxx = :value&#039;, [&#039;:value&#039; =&gt; 123]);\n\n// 下面三种用法，第5个参数都支持传Where\n// left join\nDb::query()-&gt;table(&#039;tb_test1&#039;)-&gt;leftJoin(&#039;tb_test2&#039;, &#039;tb_test1.aid&#039;, &#039;=&#039;, &#039;tb_test2.bid&#039;);\n// right join\nDb::query()-&gt;table(&#039;tb_test1&#039;)-&gt;rightJoin(&#039;tb_test2&#039;, &#039;tb_test1.aid&#039;, &#039;=&#039;, &#039;tb_test2.bid&#039;);\n// cross join\nDb::query()-&gt;table(&#039;tb_test1&#039;)-&gt;crossJoin(&#039;tb_test2&#039;, &#039;tb_test1.aid&#039;, &#039;=&#039;, &#039;tb_test2.bid&#039;);order// order by id asc, age desc\nDb::query()-&gt;order(&#039;id&#039;)-&gt;order(&#039;age&#039;, &#039;desc&#039;);\n\n// order by id desc\nDb::query()-&gt;orderRaw(&#039;id desc&#039;);\n\n// order by id desc, 1 asc\nDb::query()-&gt;orderRaw(&#039;id desc, ? asc&#039;, [1]);\n\n// order by id desc, 1 asc\nDb::query()-&gt;orderRaw(&#039;id desc, :value asc&#039;, [&#039;:value&#039; =&gt; 1]);\n\n// JSON 类型参数排序\nDb::query()-&gt;order(&#039;field1-&gt;uid&#039;, &#039;desc&#039;);group by// group by id, name\nDb::query()-&gt;group(&#039;id&#039;, &#039;name&#039;);\n\n// group by sum(id)\nDb::query()-&gt;groupRaw(&#039;sum(id)&#039;);\n\n// group by sum(id), ?\nDb::query()-&gt;groupRaw(&#039;sum(id), ?&#039;, [123]);\n\n// group by sum(id), :value\nDb::query()-&gt;groupRaw(&#039;sum(id), :value&#039;, [&#039;:value&#039; =&gt; 123]);havinghaving()用法同where()havingRaw()用法同whereRaw()havingBrackets()用法同whereBrackets()havingStruct()用法同whereStruct()分页查询// limit 900, 100\nDb::query()-&gt;page(10, 100);\n\n// limit 10, 1\nDb::query()-&gt;offset(10)-&gt;limit(1);\n\n// limit 1\nDb::query()-&gt;limit(1);分页查询带扩展字段查询总记录数、总页数：$page = 1;\n$count = 10;\n$data = Db::query()-&gt;from(&#039;xxxtable&#039;)-&gt;paginate($page, $count);\n// 指定转数组后的字段名\n$data = TDb::query()-&gt;from(&#039;xxxtable&#039;)-&gt;paginate($page, $count, [\n    &#039;field_list&#039; =&gt; &#039;list&#039;,\n    &#039;field_limit&#039; =&gt; &#039;limit&#039;,\n    &#039;field_total&#039; =&gt; &#039;total&#039;,\n    &#039;field_page_count&#039; =&gt; &#039;page_count&#039;,\n]);\n\n$data-&gt;getList(); // 列表数据\n$data-&gt;getTotal(); // 总记录数\n$data-&gt;getLimit(); // $count === 10\n$data-&gt;getPageCount(); // 总页数\n\nvar_dump($data-&gt;toArray()); // 转数组\nvar_dump(json_encode($data)); // 支持序列化\n// 数据格式如下：\n[\n    &#039;list&#039;          =&gt; [],\n    &#039;total&#039;         =&gt; 100,\n    &#039;limit&#039;         =&gt; 10,\n    &#039;page_count&#039;    =&gt; 10,\n]不查询总记录数、总页数：$page = 1;\n$count = 10;\n$data = Db::query()-&gt;from(&#039;xxxtable&#039;)-&gt;paginate($page, $count, [\n    &#039;total&#039; =&gt;  false,\n]);\nvar_dump($data-&gt;toArray()); // 转数组\nvar_dump(json_encode($data)); // 支持序列化\n// 数据格式如下：\n[\n    &#039;list&#039;          =&gt; [],\n    &#039;limit&#039;         =&gt; 10,\n]全局设置转数组后的字段名：配置@app.db.paginate.fields:[\n    &#039;list&#039; =&gt; &#039;list&#039;,\n    &#039;limit&#039; =&gt; &#039;limit&#039;,\n    &#039;total&#039; =&gt; &#039;total&#039;,\n    &#039;pageCount&#039; =&gt; &#039;page_count&#039;,\n]查询执行查询记录查询单行$result = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;select();\n$result-&gt;get(); // 数组\n$result-&gt;get($className); // $className对应的类对象查询多行$result = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;select();\n$result-&gt;getArray(); // 数组内嵌套数组\n$result-&gt;getArray($className); // 数组内嵌套$className对应的类对象\n$result-&gt;getRowCount(); // 获取查询出的记录行数查询一行Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;find();\n\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;find($className); // $className 默认null，可以不填，用途参考数据集 get 方法查询单个值Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;value(&#039;username&#039;);\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;value(&#039;username&#039;, -1); // 当数据查询不到时返回的默认值 -1查询指定列// 查询 username 列并作为数组返回\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;column(&#039;username&#039;);\n// 结果值如下：\n[\n    &#039;username1&#039;,\n    &#039;username2&#039;,\n    &#039;username4&#039;,\n]\n\n// 查询 username 列并返回 id 做下标，username 作为值的数组\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;column(&#039;username&#039;, &#039;id&#039;);\n// 结果值如下：\n[\n    1 =&gt; &#039;username1&#039;,\n    2 =&gt; &#039;username2&#039;,\n    3 =&gt; &#039;username4&#039;,\n]\n\n// 查询 username、password 列并返回 id 做下标的数组\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;column([&#039;username&#039;, &#039;password&#039;], &#039;id&#039;);\n// 结果值如下：\n[\n    1 =&gt; [&#039;username&#039; =&gt; &#039;username1&#039;, &#039;password&#039; =&gt; &#039;123&#039;],\n    2 =&gt; [&#039;username&#039; =&gt; &#039;username2&#039;, &#039;password&#039; =&gt; &#039;456&#039;],\n    3 =&gt; [&#039;username&#039; =&gt; &#039;username3&#039;, &#039;password&#039; =&gt; &#039;789&#039;],\n]构建查询语句构建语句，但不执行$query = Db::query()-&gt;table(&#039;tb_test&#039;);\n$sql = $query-&gt;buildSelectSql(); // 构建 SQL\n$binds = $query-&gt;getBinds(); // 获取预处理绑定的值注意不要重复构建，同一个对象在执行 execute() 前只能构建一次分块查询chunkById利用有序字段进行分段读取，返回符合条件的数据，对于大型数据集结果，可以有效缓解数据库压力，降低应用内存消耗，提升稳定性。参数类型说明limitint每次查询的块大小columnstring用于分块的有序字段，建议是有序且存在索引的数值字段，一般情况下可以利用主键aliasstring用于分块的有序字段的别名，一般情况下跟column是一致的，无须设置，如果定义字段查询结果的别名时可设置该参数orderBystring用于分块的有序字段排序方式指定，支持asc、desc，默认为asc用于查询的字段的值必须是唯一且递增的。该查询方法是不支持用户设置排序的，任何类型的排序都将被重置，仅能通过column指定一个字段的排序方式。对于ORM下使用，由于不是一次性载入全部数据，预加载功能对于每个块都是重复加载的，建议根据实际情况决定是否实现一个缓存查询来替代预加载。// 按 10 条每块遍历全部符合条件的行。\n\nforeach (Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;chunkById(10, &#039;id&#039;) as $result)\n{\n    $list = $result-&gt;getArray(); // select 结果集\n    // 遍历结果集\n    foreach ($list as $row)\n    {\n        var_dump($row);\n    }\n}\n\n// 还有一个更简单的用法\n\nforeach (Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;chunkById(10, &#039;id&#039;)-&gt;each() as $row)\n{\n    var_dump($row);\n}chunkByOffset利用limit进行查询驱动分块，效率与一般分页查询没区别，相对chunkById兼容更多的场景，如果追求性能还是推荐chunkById。参数类型说明limitint每次查询的块大小对于ORM下使用，由于不是一次性载入全部数据，预加载功能对于每个块都是重复加载的，建议根据实际情况决定是否实现一个缓存查询来替代预加载。// 按 10 条每块遍历全部符合条件的行。\n\nforeach (Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;chunkByOffset(10) as $result)\n{\n    $list = $result-&gt;getArray(); // select 结果集\n    // 遍历结果集\n    foreach ($list as $row)\n    {\n        var_dump($row);\n    }\n}\n\n// 还有一个更简单的用法\n\nforeach (Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;chunkByOffset(10)-&gt;each() as $row)\n{\n    var_dump($row);\n}chunkEach该方法已弃用并计划3.0移除，请使用chunkById()-&gt;each()orchunkByOffset()-&gt;each()替代。游标查询游标查询能对于查询大结果集时能有效节约应用内存消耗，对于数据库的消耗与select无差别。对于ORM下使用，由于不是一次性载入全部数据，与预加载功能不兼容，不推荐对于游标查询进行任何的模型关联操作。foreach (Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;cursor() as $data)\n{\n    var_dump($data); // 输出单条查询结果\n}聚合函数// count(*)\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;count();\n\n// count(id)\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;count(&#039;id&#039;);\n\n// sum(id)\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;sum(&#039;id&#039;);\n\n// avg(id)\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;avg(&#039;id&#039;);\n\n// max(id)\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;max(&#039;id&#039;);\n\n// min(id)\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;min(&#039;id&#039;);\n\n// 其它自定义：test(id)\nDb::query()-&gt;table(&#039;tb_test&#039;)-&gt;aggregate(&#039;test&#039;, &#039;id&#039;);插入记录// insert into tb_test(name, age) values(&#039;yurun&#039;, 666)\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;insert([\n    &#039;name&#039;  =&gt;    &#039;yurun&#039;,\n    &#039;age&#039;    =&gt;    666,\n]);\n\n// insert into tb_test values(&#039;yurun&#039;, 666)\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;insert([\n    &#039;yurun&#039;,666,\n]);\n\n// 忽略已存在记录，仅支持 MySQL\n// insert ignore into tb_test values(&#039;yurun&#039;, 666)\n$query = Db::query();\n$query-&gt;getOption()-&gt;options[&#039;ignore&#039;] = true;\n$result = $query-&gt;table(&#039;tb_test&#039;)-&gt;insert([\n    &#039;yurun&#039;,666,\n]);\n\n$result-&gt;isSuccess(); // SQL是否执行成功\n$result-&gt;getLastInsertId(); // 获取最后插入的ID\n$result-&gt;getAffectedRows(); // 获取影响行数构建插入语句构建语句，但不执行$query = Db::query()-&gt;table(&#039;tb_test&#039;);\n$sql = $query-&gt;buildInsertSql([\n    &#039;name&#039;  =&gt;    &#039;yurun&#039;,\n    &#039;age&#039;    =&gt;    666,\n]); // 构建 SQL\n$binds = $query-&gt;getBinds(); // 获取预处理绑定的值注意不要重复构建，同一个对象在执行 execute() 前只能构建一次批量插入$result = Db::query()-&gt;from(&#039;test&#039;)-&gt;batchInsert([\n    [&#039;name&#039;=&gt;&#039;a&#039;],\n    [&#039;name&#039;=&gt;&#039;b&#039;],\n    [&#039;name&#039;=&gt;&#039;c&#039;],\n]);\n\n// 忽略已存在记录，仅支持 MySQL\n$query = Db::query();\n$query-&gt;getOption()-&gt;options[&#039;ignore&#039;] = true;\n$result = $query-&gt;from(&#039;test&#039;)-&gt;batchInsert([\n    [&#039;name&#039;=&gt;&#039;a&#039;],\n    [&#039;name&#039;=&gt;&#039;b&#039;],\n    [&#039;name&#039;=&gt;&#039;c&#039;],\n]);\n\n$result-&gt;isSuccess(); // SQL是否执行成功\n$result-&gt;getAffectedRows(); // 获取影响行数构建批量插入语句构建语句，但不执行$query = Db::query()-&gt;table(&#039;tb_test&#039;);\n$sql = $query-&gt;buildBatchInsertSql([\n    [&#039;name&#039;=&gt;&#039;a&#039;],\n    [&#039;name&#039;=&gt;&#039;b&#039;],\n    [&#039;name&#039;=&gt;&#039;c&#039;],\n]); // 构建 SQL\n$binds = $query-&gt;getBinds(); // 获取预处理绑定的值注意不要重复构建，同一个对象在执行 execute() 前只能构建一次更新记录// update tb_test set name = &#039;yurun&#039;, age = 666 where id = 1\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;update([\n    &#039;name&#039;    =&gt;    &#039;yurun&#039;,\n    &#039;age&#039;    =&gt;    666,\n    // JSON 类型参数\n    &#039;field1-&gt;name&#039;        =&gt; &#039;bbb&#039;, // 修改 name\n    &#039;field1-&gt;list2&#039;       =&gt; [1, 2, 3], // 修改 list2，支持数组、对象\n    &#039;field1-&gt;list1[0].id&#039; =&gt; &#039;2&#039;, // 支持对数组中指定成员、对象属性赋值，支持无限级\n]);\n\n// $result使用方法同上构建更新语句构建语句，但不执行$query = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;where(&#039;id&#039;, &#039;=&#039;, 1);\n$sql = $query-&gt;buildUpdateSql([\n    &#039;name&#039;    =&gt;    &#039;yurun&#039;,\n    &#039;age&#039;    =&gt;    666,\n    // JSON 类型参数\n    &#039;field1-&gt;name&#039;        =&gt; &#039;bbb&#039;, // 修改 name\n    &#039;field1-&gt;list2&#039;       =&gt; [1, 2, 3], // 修改 list2，支持数组、对象\n    &#039;field1-&gt;list1[0].id&#039; =&gt; &#039;2&#039;, // 支持对数组中指定成员、对象属性赋值，支持无限级\n]); // 构建 SQL\n$binds = $query-&gt;getBinds(); // 获取预处理绑定的值注意不要重复构建，同一个对象在执行 execute() 前只能构建一次替换数据// replace into tb_test set id = 1, name = &#039;yurun&#039;, age = 666\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;replace([\n    &#039;id&#039;    =&gt;    1,\n    &#039;name&#039;    =&gt;    &#039;yurun&#039;,\n    &#039;age&#039;    =&gt;    666,\n]);构建替换语句构建语句，但不执行$query = Db::query()-&gt;table(&#039;tb_test&#039;);\n$sql = $query-&gt;buildReplaceSql([\n    &#039;id&#039;    =&gt;    1,\n    &#039;name&#039;    =&gt;    &#039;yurun&#039;,\n    &#039;age&#039;    =&gt;    666,\n]); // 构建 SQL\n$binds = $query-&gt;getBinds(); // 获取预处理绑定的值注意不要重复构建，同一个对象在执行 execute() 前只能构建一次递增/递减// score 递增 1\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)\n                     -&gt;where(&#039;id&#039;, &#039;=&#039;, 1)\n                     -&gt;setFieldInc(&#039;score&#039;)\n                     -&gt;update();\n\n// score 递增 10\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)\n                     -&gt;where(&#039;id&#039;, &#039;=&#039;, 1)\n                     -&gt;setFieldInc(&#039;score&#039;, 10)\n                     -&gt;update();\n\n// score 递减 1\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)\n                     -&gt;where(&#039;id&#039;, &#039;=&#039;, 1)\n                     -&gt;setFieldDec(&#039;score&#039;)\n                     -&gt;update();\n\n// score 递减 10\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)\n                     -&gt;where(&#039;id&#039;, &#039;=&#039;, 1)\n                     -&gt;setFieldDec(&#039;score&#039;, 10)\n                     -&gt;update();update/insert/replace时使用表达式// update tb_test set score = score + 1 where id = 1\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)\n                     -&gt;where(&#039;id&#039;, &#039;=&#039;, 1)\n                     -&gt;setFieldExp(&#039;score&#039;, &#039;score + ?&#039;, [1])\n                     -&gt;update();删除记录// delete from tb_test where id = 1\n$result = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;delete();\n\n// $result使用方法同上构建删除语句构建语句，但不执行$query = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;where(&#039;id&#039;, &#039;=&#039;, 1);\n$sql = $query-&gt;buildDeleteSql(); // 构建 SQL\n$binds = $query-&gt;getBinds(); // 获取预处理绑定的值注意不要重复构建，同一个对象在执行 execute() 前只能构建一次加锁排它锁：use Imi\\Db\\Mysql\\Query\\Lock\\MysqlLock;\nDb::query()-&gt;from(&#039;tb_xxx&#039;)-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;lock(MysqlLock::FOR_UPDATE)-&gt;select()-&gt;get();共享锁：use Imi\\Db\\Mysql\\Query\\Lock\\MysqlLock;\nDb::query()-&gt;from(&#039;tb_xxx&#039;)-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;lock(MysqlLock::SHARED)-&gt;select()-&gt;get();直接执行SQL$result = Db::query()-&gt;execute(&#039;select * from tb_test&#039;));\n\n// $result使用方法同上参数绑定复杂的查询时，难免需要拼接 SQL，这时候就需要参数绑定来防止注入了！// where id = 123\n$result = Db::query()-&gt;whereRaw(&#039;id = ?&#039;)-&gt;bindValue(1, 123);\n$result = Db::query()-&gt;whereRaw(&#039;id = :val&#039;)-&gt;bindValue(&#039;:val&#039;, 123);\n\n// 批量绑定\n$result = Db::query()-&gt;bindValues([\n    &#039;:name&#039;    =&gt;    &#039;yurun&#039;,\n    &#039;:age&#039;    =&gt;    666,\n])-&gt;execute(&#039;select * from tb_test where name = :name and age = :age&#039;);设置/获取 Result 结果集类名$query = Db::query();\n// 获取\nvar_dump($query-&gt;getResultClass());\n\n// 设置\n$query-&gt;setResultClass(\\Imi\\Db\\Query\\Result::class);Result 用法$result = Db::query()-&gt;table(&#039;tb_test&#039;)-&gt;select();是否执行成功$success = $result-&gt;isSuccess(); // true/false获取最后插入的ID用于获取新增记录的自增字段值$lastInsertId = $result-&gt;getLastInsertId(); // int获取影响行数$rows = $result-&gt;getAffectedRows();update 时，如果没有值被改变，可能会返回0返回一行数据返回数组$dataArray = $result-&gt;get();返回对象实例化这个类时，把数组传入构造方法$dataArray = $result-&gt;get(XXXModel::class);返回数组列表成员为数组$list = $result-&gt;getArray();成员为对象$list = $result-&gt;getArray(XXXModel::class);获取一列$ids = Db::query()-&gt;field(&#039;id&#039;)-&gt;select()-&gt;getColumn();\n// 结果格式：[1, 2, 3]获取标量结果$name = Db::query()-&gt;field(&#039;name&#039;)-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;select()-&gt;getScalar();获取记录行数得到取回多少条记录$rowCount = $result-&gt;getRowCount();获取执行的SQL$sql = $result-&gt;getSql();获取结果集$statement = $result-&gt;getStatement(); // \\Imi\\Db\\Interfaces\\IStatement渲染预编译SQL语句主要用于日志或者调试$prepare = &quot;select * from `test1` where `id` = :p1 and `text` = :p2 and `a1` in (:p3,:p4,:p5) and `a2` in (0 = 1)&quot;;\n$bindValues = [\n    &#039;:p1&#039; =&gt; -1,\n    &#039;:p2&#039; =&gt; &#039;abc123&#039;,\n    &#039;:p3&#039; =&gt; 1,\n    &#039;:p4&#039; =&gt; 2,\n    &#039;:p5&#039; =&gt; 3,\n];\n\necho Db::debugSql($prepare, $bindValues);\n// 输出\n// select * from `test1` where `id` = -1 and `text` = &#039;abc123&#039; and `a1` in (1,2,3) and `a2` in (0 = 1)\n\n$prepare = &quot;select * from `test1` where `id` = ? and `text` = ? and `a1` in (?,?) ??&quot;;\n$bindValues = [-1, &#039;abc123&#039;, 1, 2];\n\necho Db::debugSql($prepare, $bindValues);\n// 输出\n// select * from `test1` where `id` = -1 and `text` = &#039;abc123&#039; and `a1` in (1,2) ??"},{"id":130,"title":"MySQL","pageTitle":"MySQL","url":"components/db/mysql.html","content":"MySQL目录驱动类PdoMysqlDriver基于 PDO 实现，支持所有环境，支持 Swoole 协程。MysqliDriver基于 MySQLi 实现，支持所有环境，支持 Swoole 协程。SwooleMysqlDriver只支持 Swoole 环境"},{"id":188,"title":"PostgreSQL","pageTitle":"PostgreSQL","url":"components/db/pgsql.html","content":"PostgreSQL目录需要引入 imi-pgsql 组件：composer require imiphp/imi-pgsql驱动类PdoPgsqlDriver基于 PDO 实现，支持所有环境，不支持 Swoole 协程。SwoolePgsqlDriver基于 Swoole 协程 PostgreSQL 客户端 实现"},{"id":134,"title":"SQL 监听","pageTitle":"SQL 监听","url":"components/db/sqlListener.html","content":"SQL 监听目录说明使用 SQL 监听，你可以记录 SQL 执行日志。要使用 SQL 监听功能，必须先配置启用，并且不推荐在生产环境使用。开启方式是在配置文件中的 beans 中加入：&#039;DbQueryLog&#039; =&gt; [\n    &#039;enable&#039; =&gt; true,\n]事件SQL 执行事件名：IMI.DB.EXECUTE每一个 SQL 语句执行后都会触发该事件。示例：&lt;?php\n\nnamespace Imi\\Test\\Component\\Db\\Listener;\n\nuse Imi\\Bean\\Annotation\\Listener;\nuse Imi\\Db\\Event\\Param\\DbExecuteEventParam;\nuse Imi\\Event\\EventParam;\nuse Imi\\Event\\IEventListener;\nuse Imi\\Log\\Log;\n\n/**\n * @Listener(&quot;IMI.DB.EXECUTE&quot;)\n */\nclass DbExecuteListener implements IEventListener\n{\n    /**\n     * 事件处理方法.\n     *\n     * @param DbExecuteEventParam $e\n     *\n     * @return void\n     */\n    public function handle(EventParam $e): void\n    {\n        if ($e-&gt;throwable)\n        {\n            // 记录 SQL 语句\n            // Log::error(sprintf(&#039;[%s] %s&#039;, $e-&gt;throwable-&gt;getMessage(), $e-&gt;sql));\n            // 记录 SQL 语句，占位符替换为真实参数\n            Log::error(sprintf(&#039;[%s] %s&#039;, $e-&gt;throwable-&gt;getMessage(), \\Imi\\Db::debugSql($e-&gt;sql, $e-&gt;bindValues ?? [])));\n        }\n        else\n        {\n            Log::info(sprintf(&#039;[%ss] %s&#039;, round($e-&gt;time, 3), $e-&gt;sql));\n        }\n    }\n}准备 SQL 语句事件名：IMI.DB.PREPARE每一个 SQL 语句准备后都会触发该事件。示例：&lt;?php\n\nnamespace Imi\\Test\\Component\\Db\\Listener;\n\nuse Imi\\Bean\\Annotation\\Listener;\nuse Imi\\Db\\Event\\Param\\DbPrepareEventParam;\nuse Imi\\Event\\EventParam;\nuse Imi\\Event\\IEventListener;\nuse Imi\\Log\\Log;\n\n/**\n * @Listener(&quot;IMI.DB.PREPARE&quot;)\n */\nclass DbPrepareListener implements IEventListener\n{\n    /**\n     * 事件处理方法.\n     *\n     * @param DbPrepareEventParam $e\n     *\n     * @return void\n     */\n    public function handle(EventParam $e): void\n    {\n        if ($e-&gt;throwable)\n        {\n            // 记录 SQL 语句\n            Log::error(sprintf(&#039;[%s] %s&#039;, $e-&gt;throwable-&gt;getMessage(), $e-&gt;sql));\n        }\n        else\n        {\n            Log::info(sprintf(&#039;[prepare] %s&#039;, $e-&gt;sql));\n        }\n    }\n}"},{"id":19,"title":"事件监听","pageTitle":"事件监听","url":"components/event/index.html","content":"事件监听目录imi 框架提供了强大的事件机制，它可以让你在特定的时刻执行某些操作。事件机制的核心是事件触发器和事件监听器。在 imi 框架中，事件触发器通常是一个具体的操作，而事件监听器则是响应某些事件的具体操作。事件机制的主要优势在于它可以让你在不改变原有代码的情况下，扩展应用的功能。全局事件监听全局事件注解监听全局事件&lt;?php\nnamespace Imi\\Listener;\n\nuse Imi\\Event\\EventParam;\nuse Imi\\Event\\IEventListener;\nuse Imi\\Bean\\Annotation\\Listener;\n\n/**\n * @Listener(eventName=&quot;IMI.INITED&quot;, priority=PHP_INT_MAX)\n */\nclass Init implements IEventListener\n{\n    /**\n     * 事件处理方法\n     * @param EventParam $e\n     * @return void\n     */\n    public function handle(EventParam $e)\n    {\n        // ...\n    }\n}首先需要定义一个类，类名和位置无所谓。类必须实现IEventListener接口和public function handle(EventParam $e): void方法。然后在类上写@Listener注解。注解参数说明：eventName 要监听的事件名称priority 事件触发后执行的优先级，数字越大越先执行，同样大执行顺序不一定one 设为 true 事件仅触发一次，默认为 false代码监听除了使用注解，你还可以写代码手动监听use Imi\\Event\\Event;\n\nEvent::on(&#039;事件名&#039;, function(){\n    // 事件回调\n});\n\n$priority = 0;\nEvent::on(&#039;事件名&#039;, function(){\n    // 事件回调\n}, $priority);\n\n// 监听只触发一次\nEvent::one(&#039;事件名&#039;, function(){});\n\n// 取消事件\nEvent::off(&#039;事件名&#039;, $callable);on()、one()、off() 方法还支持传入多个事件：Event::on([&#039;e1&#039;, &#039;e2&#039;], function(){\n    // 事件回调\n});取消事件所有监听：Event::off(&#039;事件名&#039;);\nEvent::off([&#039;事件名1&#039;, &#039;事件名2&#039;]);自定义事件use Imi\\Event\\Event;\n\nEvent::trigger(&#039;事件名称&#039;, &#039;传入事件回调的数据&#039;, &#039;目标对象&#039;, &#039;参数类，默认为EventParam::class&#039;);局部事件局部事件就是在某个类实例的事件。监听局部事件注解监听局部事件以imi/src/Server/Http/Listener/BeforeRequest.php为例&lt;?php\nnamespace Imi\\Swoole\\Server\\Http\\Listener;\n\nuse Imi\\Bean\\Annotation\\ClassEventListener;\nuse Imi\\Swoole\\Server\\Event\\Param\\RequestEventParam;\nuse Imi\\Swoole\\Server\\Event\\Listener\\IRequestEventListener;\n\n/**\n * request事件前置处理\n * @ClassEventListener(className=&quot;Imi\\Swoole\\Server\\Http\\Server&quot;,eventName=&quot;request&quot;,priority=PHP_INT_MAX)\n */\nclass BeforeRequest implements IRequestEventListener\n{\n    /**\n     * 事件处理方法\n     * @param RequestEventParam $e\n     * @return void\n     */\n    public function handle(RequestEventParam $e): void\n    {\n        // ...\n    }\n}首先需要定义一个类，类名和位置无所谓。类必须实现对应接口和handle()方法，每个类的事件定义不同。然后在类上写@ClassEventListener注解。注解参数如下：className类名eventName要监听的事件名称priority事件触发后执行的优先级，数字越大越先执行，同样大执行顺序不一定代码监听局部事件$object-&gt;on(&#039;事件名&#039;, function(){\n    // 事件回调\n});\n\n$priority = 0;\n$object-&gt;on(&#039;事件名&#039;, function(){\n    // 事件回调\n}, $priority);\n\n// 监听只触发一次\n$object-&gt;one(&#039;事件名&#039;, function(){});\n\n// 取消事件\n$object-&gt;off(&#039;事件名&#039;, $callable);\n自定义触发事件$object-&gt;trigger(&#039;事件名称&#039;, &#039;传入事件回调的数据&#039;, &#039;目标对象&#039;, &#039;参数类，默认为EventParam::class&#039;);"},{"id":170,"title":"门面 (Facade)","pageTitle":"门面 (Facade)","url":"components/facade/index.html","content":"门面 (Facade)目录imi 现已支持门面 (Facade) 特性，支持为Bean对象提供一个静态调用方法的类。示例假设有这么一个类：&lt;?php\nnamespace Imi\\Test\\Component\\Facade;\n\nuse Imi\\Bean\\Annotation\\Bean;\n\n/**\n * @Bean(&quot;FacadeA&quot;)\n */\nclass A\n{\n    public function add($a, $b)\n    {\n        return $a + $b;\n    }\n\n}定义 Facade 类：&lt;?php\nnamespace Imi\\Test\\Component\\Facade;\n\nuse Imi\\Facade\\BaseFacade;\nuse Imi\\Facade\\Annotation\\Facade;\n\n/**\n * @Facade(&quot;FacadeA&quot;)\n * @method mixed add($a, $b)\n */\nclass FacadeA extends BaseFacade\n{\n\n}继承 Imi\\Facade\\BaseFacade 类，然后使用@Facade注解类定义绑定到哪个类。使用：use Imi\\Test\\Component\\Facade\\FacadeA;\nFacadeA::add(1, 2); // 3@Facade 注解class Facade extends Base\n{\n    /**\n     * 只传一个参数时的参数名\n     * @var string|null\n     */\n    protected ?string $defaultFieldName = &#039;class&#039;;\n\n    /**\n     * 类名，支持 Bean 名\n     *\n     * @var string\n     */\n    public $class;\n\n    /**\n     * 为 true 时，使用当前请求上下文的 Bean 对象\n     *\n     * @var boolean\n     */\n    public $request = false;\n\n    /**\n     * 实例化参数\n     *\n     * @var array\n     */\n    public $args = [];\n\n}Facade 生成器查看帮助：imi-xxx generate/facade -h"},{"id":52,"title":"热更新","pageTitle":"热更新","url":"components/hotupdate/index.html","content":"热更新目录由于 imi 基于 Swoole 和 Workerman 常驻内存，PHP 热更新的传统方式并不适用。为了解决这个问题，imi 提供了热更新的解决方案，支持业务代码的动态加载和更新，方便开发调试和部署。同时，imi 保持了应用的稳定性和可靠性，支持平滑重启和进程管理。有了热更新的支持，开发者可以在不停止服务的情况下，实时地更新代码并查看效果，大大提高了开发效率和调试体验。请不要在生产环境使用热更新，可能会产生意料之外的问题配置imi 默认开启了热更新，如果需要关闭或者个性化设置请看下文：热更新通过配置文件中的beans节配置。详见下面的注释：&#039;hotUpdate&#039;    =&gt;    [\n    // &#039;status&#039;    =&gt; false, // 关闭热更新去除注释，不设置即为开启，建议生产环境关闭\n\n    // --- 文件修改时间监控 ---\n    // &#039;monitorClass&#039; =&gt; \\Imi\\HotUpdate\\Monitor\\FileMTime::class,\n    // &#039;timespan&#039;     =&gt; 1, // 检测时间间隔，单位：秒\n\n    // --- Inotify 扩展监控 ---\n    // &#039;monitorClass&#039; =&gt; \\Imi\\HotUpdate\\Monitor\\Inotify::class,\n    // &#039;timespan&#039;     =&gt; 0, // 检测时间间隔，单位：秒，使用扩展建议设为0性能更佳\n\n    // &#039;includePaths&#039; =&gt; [], // 要包含的路径数组\n    // &#039;excludePaths&#039; =&gt; [], // 要排除的路径数组，支持通配符*\n    // &#039;defaultPath&#039;  =&gt; [], // 设为数组则覆盖默认的监控路径\n    // &#039;process&#039;      =&gt; false, // 允许热更新的进程，true：全部进程，false：不允许重启，array: 指定进程允许重启\n],认情况下，imi 采用文件修改时间来监控代码变化并实现热更新。但是建议在可行的情况下安装 Inotify 扩展以提高性能。注意，如果你的项目所在目录的文件系统是共享目录或者映射目录，请不要使用 Inotify 模式。"},{"id":73,"title":"404处理","pageTitle":"404处理","url":"components/httpserver/404.html","content":"404处理目录当没有匹配的路由，这时候可能会需要404处理。框架默认的404处理为状态码设为404，如果需要自定义处理，需要编写自定义处理类。指定默认处理器配置文件中：return [\n    &#039;beans&#039;    =&gt;  [\n        &#039;HttpNotFoundHandler&#039; =&gt; [\n            // 指定默认处理器\n            &#039;handler&#039; =&gt; \\xxx\\HttpNotFoundHandler::class,\n        ],\n    ],\n];编写处理器如下代码所示，实现IHttpNotFoundHandler接口，handle()方法返回值为Response对象。&lt;?php\nuse Imi\\Util\\Http\\Consts\\StatusCode;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Imi\\Server\\Http\\Error\\IHttpNotFoundHandler;\nuse Imi\\Server\\Http\\Message\\Contract\\IHttpRequest;\nuse Imi\\Server\\Http\\Message\\Contract\\IHttpResponse;\n\nclass HttpNotFoundHandler implements IHttpNotFoundHandler\n{\n    public function handle(RequestHandlerInterface $requesthandler, IHttpRequest $request, IHttpResponse $response): IHttpResponse\n    {\n        return $response-&gt;withStatus(StatusCode::NOT_FOUND);\n    }\n}"},{"id":63,"title":"AOP 拦截请求","pageTitle":"AOP 拦截请求","url":"components/httpserver/aop.html","content":"AOP 拦截请求目录在 imi 中更加推荐使用 AOP 来拦截请求。AOPAOP（Aspect-Oriented Programming 面向切面编程）是一种在运行时， 动态地将一段代码片段（切面）切入到指定类、类的指定方法（切入点）等位置， 从而改变其原有的行为的编程思想。可以在不改变原有逻辑的基础上， 增加一些额外的功能，例如日志记录，性能统计，安全控制，事务处理，异常处理等。 详细介绍请见：https://doc.imiphp.com/v2.1/components/aop/index.htmlDemo&lt;?php\nnamespace ImiApp\\ApiServer\\Aop;\n\nuse Imi\\RequestContext;\nuse Imi\\Aop\\Annotation\\Around;\nuse Imi\\Aop\\Annotation\\Aspect;\nuse Imi\\Aop\\Annotation\\PointCut;\nuse Imi\\Aop\\AroundJoinPoint;\nuse Imi\\Util\\Http\\Consts\\MediaType;\nuse Imi\\Util\\Http\\Consts\\ResponseHeader;\n\n/**\n * 拦截控制器动作请求 Demo\n * \n * @Aspect\n */\nclass Fuck\n{\n    /**\n     * 直接获取 Response 对象，强行输出\n     * \n     * @PointCut(\n     *         allow={\n     *             &quot;ImiApp\\ApiServer\\Controller\\IndexController::fuck1&quot;,\n     *         }\n     * )\n     * @Around\n     *\n     * @return void\n     */\n    public function fuck1(AroundJoinPoint $joinPoint)\n    {\n        /** @var \\Imi\\Server\\Http\\Message\\Response $response */\n        $response = RequestContext::get(&#039;response&#039;);\n        $response-&gt;withHeader(ResponseHeader::CONTENT_TYPE, MediaType::APPLICATION_JSON_UTF8)\n                 -&gt;getBody()-&gt;write(json_encode([\n                    &#039;result&#039; =&gt; &#039;fuck1&#039;,\n                 ]));\n        $response-&gt;send();\n        // 如果需要执行原方法，可以去掉注释\n        // $returnValue = $joinPoint-&gt;proceed();\n        // 执行原方法，获取返回值（方法返回值是引用返回时）\n        // $returnValue = $joinPoint-&gt;proceed(null, true);\n\n        // return $returnValue; // 返回原返回值\n    }\n\n    /**\n     * 强行修改返回值\n     * \n     * @PointCut(\n     *         allow={\n     *             &quot;ImiApp\\ApiServer\\Controller\\IndexController::fuck2&quot;,\n     *         }\n     * )\n     * @Around\n     *\n     * @return void\n     */\n    public function fuck2(AroundJoinPoint $joinPoint)\n    {\n        // 如果需要执行原动作方法，可以去掉注释\n        // $returnValue = $joinPoint-&gt;proceed();\n        // 执行原方法，获取返回值（方法返回值是引用返回时）\n        // $returnValue = $joinPoint-&gt;proceed(null, true);\n\n        // return $returnValue; // 返回原返回值\n\n        // 强行修改返回值\n        return [\n            &#039;result&#039; =&gt; &#039;fuck2&#039;,\n        ];\n    }\n}"},{"id":"645b0aa9caa4b2.58695578","title":"","pageTitle":"","url":"components/httpserver/config.html","content":""},{"id":60,"title":"控制器","pageTitle":"控制器","url":"components/httpserver/controller.html","content":"控制器目录所有的请求都会打进控制器，我们开发项目时候，处理请求基本都是在控制器里做。如下代码所示，一个最简单的控制器代码。基本控制器&lt;?php\nnamespace Test;\n\nuse Imi\\Controller\\HttpController;\nuse Imi\\Server\\Http\\Route\\Annotation\\Route;\nuse Imi\\Server\\Http\\Route\\Annotation\\Action;\nuse Imi\\Server\\Http\\Route\\Annotation\\Controller;\n\n/**\n * 一个简单的控制器\n * @Controller\n */\nclass Index extends HttpController\n{\n    /**\n     * 一个动作\n     * @Action\n     * @Route(url=&quot;/&quot;)\n     */\n    public function index()\n    {\n        $this-&gt;response-&gt;getBody()-&gt;write(&#039;hello imi!&#039;);\n        return $this-&gt;response;\n    }\n}访问地址：http://localhost:{port}/输出内容：hello imi!Swoole 中的禁忌用法控制器是单例的，Swoole 环境下运行不适合赋值取值静态变量、类属性。&lt;?php\nnamespace Test;\n\nuse Imi\\Controller\\HttpController;\nuse Imi\\Server\\Http\\Route\\Annotation\\Route;\nuse Imi\\Server\\Http\\Route\\Annotation\\Action;\nuse Imi\\Server\\Http\\Route\\Annotation\\Controller;\n\n/**\n * 一个简单的控制器\n * @Controller\n */\nclass Index extends HttpController\n{\n    private $id;\n\n    public function __construct()\n    {\n        // 这个是有问题的，只会在第一次请求时候执行\n        $this-&gt;id = $this-&gt;request-&gt;get(&#039;id&#039;);\n    }\n}属性$server详见：https://doc.imiphp.com/v2.1/core/server.html$request请求信息对象，可以用于获取参数、请求头等，遵循 PSR-7 标准。$response响应对象，遵循 PSR-7 标准。直接对该对象调用 withXXX() 无效，需要如下使用才可。操作后赋值：public function action()\n{\n    $this-&gt;response = $this-&gt;response-&gt;withStatus(404);\n}操作后返回：public function action()\n{\n    return $this-&gt;response-&gt;withStatus(404);\n}或者可以直接使用 setXXX()：public function action()\n{\n    $this-&gt;response-&gt;setStatus(404);\n}"},{"id":78,"title":"跨域和 OPTIONS 请求","pageTitle":"跨域和 OPTIONS 请求","url":"components/httpserver/cros.html","content":"跨域和 OPTIONS 请求目录imi 框架内置了一个 OptionsMiddleware 中间件，用于解决使用 application/json 请求时，浏览器会先发送一个 OPTIONS 请求。并且可以解决跨域头问题。类名：\\Imi\\Server\\Http\\Middleware\\OptionsMiddleware别名：OptionsMiddleware中间件使用方法：https://doc.imiphp.com/v2.1/components/httpserver/middleware.html参数设置一般来讲，默认的配置足以满足绝大部分场景。如果有特殊需求，你可以在服务器配置中的 beans.OptionsMiddleware 中配置该中间件的参数。下面给出的是默认参数值：[\n    &#039;beans&#039; =&gt;  [\n        &#039;OptionsMiddleware&#039; =&gt;  [\n            // 设置允许的 Origin，为 null 时允许所有，为数组时允许多个\n            &#039;allowOrigin&#039;       =&gt;  null,\n            // 允许的请求头\n            &#039;allowHeaders&#039;      =&gt;  &#039;Authorization, Content-Type, Accept, Origin, If-Match, If-Modified-Since, If-None-Match, If-Unmodified-Since, X-Requested-With, X-Id, X-Token, Cookie&#039;,\n            // 允许的跨域请求头\n            &#039;exposeHeaders&#039;     =&gt;  &#039;Authorization, Content-Type, Accept, Origin, If-Match, If-Modified-Since, If-None-Match, If-Unmodified-Since, X-Requested-With, X-Id, X-Token, Cookie&#039;,\n            // 允许的请求方法\n            &#039;allowMethods&#039;      =&gt;  &#039;GET, POST, PATCH, PUT, DELETE&#039;,\n            // 是否允许跨域 Cookie\n            &#039;allowCredentials&#039;  =&gt;  &#039;true&#039;,\n            // 当请求为 OPTIONS 时，是否中止后续中间件和路由逻辑，一般建议设为 true\n            &#039;optionsBreak&#039;      =&gt;  true,\n        ],\n    ],\n]Nginx 配置如果你不希望在 imi 里做跨域处理，也可以使用 Nginx 来配置：# 跨域\n# * 就是允许全部，你也可以指定\nadd_header &#039;Access-Control-Allow-Origin&#039; &#039;*&#039;;\n# 你还可以加入其它想要的请求方式\nadd_header &#039;Access-Control-Allow-Methods&#039; &#039;GET, POST, OPTIONS&#039;;\n# 你还可以加入你想要允许的请求头\nadd_header &#039;Access-Control-Allow-Headers&#039; &#039;authorization,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#039;;\nif ($request_method = &#039;OPTIONS&#039;) {\n    return 204;\n}"},{"id":72,"title":"错误异常处理","pageTitle":"错误异常处理","url":"components/httpserver/error.html","content":"错误异常处理目录当程序出现错误或者异常时，我们一般会希望在开发时输出报错信息，在生产环境时隐藏详细的信息。在 imi 中，提供了 Http 服务的错误异常默认处理器支持。默认 Http 错误处理器：Imi\\Server\\Http\\Error\\JsonErrorHandler指定默认处理器配置文件中：return [\n    &#039;beans&#039;    =&gt; [\n        &#039;HttpErrorHandler&#039; =&gt; [\n            // 指定默认处理器\n            &#039;handler&#039; =&gt; \\Imi\\Server\\Http\\Error\\JsonErrorHandler::class,\n        ],\n    ],\n];默认处理器参数设置return [\n    &#039;beans&#039; =&gt; [\n    \\Imi\\Server\\Http\\Error\\JsonErrorHandler::class =&gt; [\n            // debug 为 false时也显示错误信息\n            &#039;releaseShow&#039; =&gt; false,\n            // 取消继续抛出异常，也不会记录日志\n            &#039;cancelThrow&#039; =&gt; true,\n            // 异常时响应的 Http Code，默认 null，不设置\n            &#039;httpCode&#039;    =&gt; 500,\n        ],\n    ],\n];编写处理器如下代码所示，实现IErrorHandler接口，handle()方法返回值为true时则取消继续抛出异常。&lt;?php\nnamespace Imi\\Server\\Http\\Error;\n\nuse Imi\\App;\nuse Imi\\RequestContext;\nuse Imi\\Server\\View\\Annotation\\View;\nuse Imi\\Util\\Format\\Json;\nuse Imi\\Util\\Http\\Consts\\MediaType;\nuse Imi\\Util\\Http\\Consts\\RequestHeader;\nuse Imi\\Server\\Http\\Error\\IErrorHandler;\n\nclass JsonErrorHandler implements IErrorHandler\n{\n    /**\n     * debug 为 false时也显示错误信息.\n     */\n    protected bool $releaseShow = false;\n\n    /**\n     * 取消继续抛出异常.\n     */\n    protected bool $cancelThrow = false;\n\n    protected View $viewAnnotation;\n\n    public function __construct()\n    {\n        $this-&gt;viewAnnotation = new View();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function handle(\\Throwable $throwable): bool\n    {\n        if ($this-&gt;releaseShow || App::isDebug())\n        {\n            $data = [\n                &#039;message&#039;   =&gt; $throwable-&gt;getMessage(),\n                &#039;code&#039;      =&gt; $throwable-&gt;getCode(),\n                &#039;file&#039;      =&gt; $throwable-&gt;getFile(),\n                &#039;line&#039;      =&gt; $throwable-&gt;getLine(),\n                &#039;trace&#039;     =&gt; explode(\\PHP_EOL, $throwable-&gt;getTraceAsString()),\n            ];\n        }\n        else\n        {\n            $data = [\n                &#039;success&#039; =&gt; false,\n                &#039;message&#039; =&gt; &#039;error&#039;,\n            ];\n        }\n        $requestContext = RequestContext::getContext();\n        /** @var \\Imi\\Server\\View\\Handler\\Json $jsonView */\n        $jsonView = $requestContext[&#039;server&#039;]-&gt;getBean(&#039;JsonView&#039;);\n        $jsonView-&gt;handle($this-&gt;viewAnnotation, null, $data, $requestContext[&#039;response&#039;] ?? null)-&gt;send();\n\n        return $this-&gt;cancelThrow;\n    }\n}"},{"id":77,"title":"Http2","pageTitle":"Http2","url":"components/httpserver/http2.html","content":"Http2目录imi v1.0.20 新增支持开发 Http2 服务。具体开发方法和 Http、WebSocket 类似。需要除了需要加配置外，请求响应对象是使用 Http 的对象。并且可以像开发 WebSocket 一样使用请求上下文存储数据，因为 Http2 是以全双工长连接的方式工作的。仅支持 Swoole配置方法在项目 config.php 中的服务器配置中加入：&#039;configs&#039;   =&gt;  [\n    &#039;open_http2_protocol&#039;   =&gt;  true,\n    // 下面是启用 https，如果需要就配置\n    // &#039;ssl_cert_file&#039;     =&gt;  &#039;/server.crt&#039;,\n    // &#039;ssl_key_file&#039;      =&gt;  &#039;/server.key&#039;,\n],主服务器：// 主服务器配置\n&#039;mainServer&#039;    =&gt;    [\n    // 指定服务器命名空间\n    &#039;namespace&#039;    =&gt;  &#039;ImiDemo\\HttpDemo\\MainServer&#039;,\n    // 服务器类型(http/WebSocket/TcpServer/UdpServer)\n    &#039;type&#039;      =&gt;  \\Imi\\Swoole\\Server\\Type::HTTP,\n    // 监听的IP地址，可选\n    &#039;host&#039;      =&gt;  &#039;0.0.0.0&#039;,\n    // 监听的端口\n    &#039;port&#039;        =&gt;    8080,\n    // 参考 swoole mode，可选\n    &#039;mode&#039;        =&gt;    SWOOLE_BASE,\n    // 参考 swoole sockType，可选\n    &#039;sockType&#039;    =&gt;    SWOOLE_SOCK_TCP,\n    // 服务器配置，参数用法同\\Swoole\\Server-&gt;set($configs)\n    &#039;configs&#039;    =&gt;    [\n        &#039;reactor_num&#039;        =&gt; 8,\n        &#039;worker_num&#039;        =&gt; 8,\n        &#039;task_worker_num&#039;    =&gt; 16,\n        &#039;open_http2_protocol&#039;   =&gt;  true, // 启用 http2\n    ],\n],子服务器：[\n    // 子服务器（端口监听）配置\n    &#039;subServers&#039;    =&gt;    [\n        // 子服务器别名\n        &#039;alias1&#039;    =&gt;    [\n            // 指定服务器命名空间\n            &#039;namespace&#039;    =&gt;    &#039;ImiDemo\\HttpDemo\\MainServer&#039;,\n            // 服务器类型(http/WebSocket/TcpServer/UdpServer)\n            &#039;type&#039;        =&gt;    \\Imi\\Swoole\\Server\\Type::HTTP,\n            // 监听的IP地址，可选\n            &#039;host&#039;        =&gt;    &#039;0.0.0.0&#039;,\n            // 监听的端口\n            &#039;port&#039;        =&gt;    8080,\n            // 参考 swoole sockType，可选\n            &#039;sockType&#039;    =&gt;    SWOOLE_SOCK_TCP,\n            // 服务器配置，参数用法同\\Swoole\\Server-&gt;set($configs)\n            &#039;configs&#039;    =&gt;    [\n                &#039;open_http2_protocol&#039;   =&gt;  true, // 启用 http2\n            ],\n        ],\n    ],\n]其它用法参考 Http、WebSocket 即可。"},{"id":195,"title":"JWT","pageTitle":"JWT","url":"components/httpserver/jwt.html","content":"JWT目录介绍在 imi 框架中非常方便地接入 jwtGithub: https://github.com/imiphp/imi-jwtimi v1 使用 1.0 版本imi v2 使用 2.0 版本imi-jwt 基于 lcobucci/jwt 开发，如有更多问题请查阅文档：https://lcobucci-jwt.readthedocs.io/en/latest/Composer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-jwt&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入本组件\n        &#039;jwt&#039;    =&gt;  &#039;Imi\\JWT&#039;,\n    ],\n]配置配置 @app.beans：[\n    &#039;JWT&#039;   =&gt;  [\n        &#039;list&#039;  =&gt;  [\n            // a 为名称，可以自定义，以下被注释的项为非必设，一般有默认值\n            &#039;a&#039; =&gt;  [\n                // &#039;signer&#039;    =&gt;  &#039;Hmac&#039;,      // 签名者，可选：Ecdsa/Hmac/Rsa\n                // &#039;algo&#039;      =&gt;  &#039;Sha256&#039;,    // 算法，可选：Sha256/Sha384/Sha512\n                // &#039;dataName&#039;  =&gt;  &#039;data&#039;,      // 自定义数据字段名，放你需要往token里丢的数据\n                // &#039;audience&#039;  =&gt;  null,        // 接收，非必须\n                // &#039;subject&#039;   =&gt;  null,        // 主题，非必须\n                &#039;expires&#039;   =&gt;  86400,        // 超时秒数\n                // &#039;issuer&#039;    =&gt;  null,        // 发行人，非必须\n                // &#039;notBefore&#039; =&gt;  null,        // 实际日期必须大于等于本值\n                // &#039;issuedAt&#039;  =&gt;  true,        // JWT 发出时间。设为 true 则为当前时间；设为 false 不设置；其它值则直接写入\n                // &#039;id&#039;        =&gt;  null,        // Token id\n                // &#039;headers&#039;   =&gt;  [],          // 头\n                // 自定义获取 token 回调，返回值为 Token。默认从 Header Authorization 中获取。\n                // &#039;tokenHandler&#039;  =&gt;  null,\n                &#039;privateKey&#039;    =&gt;  &#039;123456&#039;,// 私钥\n                &#039;publicKey&#039;     =&gt;  &#039;123456&#039;,// 公钥\n            ],\n        ],\n    ],\n]生成 Token简单生成：use Imi\\JWT\\Facade\\JWT;\n// 你需要往token里丢的数据\n$data = [\n    &#039;memberId&#039;  =&gt;  19260817,\n];\n$token = JWT::getToken($data); // Token 对象\n$tokenContent = $token-&gt;toString(); // Token 字符串指定名称：use Imi\\JWT\\Facade\\JWT;\n// 你需要往token里丢的数据\n$data = [\n    &#039;memberId&#039;  =&gt;  19260817,\n];\n$token = JWT::getToken($data, &#039;a&#039;); // Token 对象\n$tokenContent = $token-&gt;toString(); // Token 字符串自定义处理：use Imi\\JWT\\Facade\\JWT;\n// 你需要往token里丢的数据\n$data = [\n    &#039;memberId&#039;  =&gt;  19260817,\n];\n$token = JWT::getToken($data, &#039;a&#039;, function(\\Lcobucci\\JWT\\Builder $builder){\n    // 可以针对该对象做一些操作\n    $builder-&gt;withClaim(&#039;aaa&#039;, &#039;bbb&#039;);\n}); // Token 对象\n$tokenContent = $token-&gt;toString(); // Token 字符串验证 Token验证 Token 不通过会抛出异常：\\Imi\\JWT\\Exception\\InvalidTokenException手动验证：&lt;?php\n$token = \\Imi\\JWT\\Facade\\JWT::parseToken(&#039;token字符串&#039;); // 使用默认名称验证\n$token = \\Imi\\JWT\\Facade\\JWT::parseToken(&#039;token字符串&#039;, &#039;a&#039;); // 指定名称验证\n$token = \\Imi\\JWT\\Facade\\JWT::parseToken(&#039;token字符串&#039;, &#039;a&#039;, true); // 获取时自带验证\n// 下面是手动验证\n\\Imi\\JWT\\Facade\\JWT::validate(null, $token); // 使用默认名称验证\n\\Imi\\JWT\\Facade\\JWT::validate(&#039;a&#039;, $token); // 指定名称验证注解验证：&lt;?php\nnamespace Imi\\JWT\\Test\\Test;\n\nuse Imi\\Bean\\Annotation\\Bean;\nuse Imi\\JWT\\Annotation\\JWTValidation;\n\n/**\n * @Bean(&quot;A&quot;)\n */\nclass A\n{\n    /**\n     * @JWTValidation(tokenParam=&quot;token&quot;, dataParam=&quot;data&quot;)\n     *\n     * @param \\Lcobucci\\JWT\\Token $token\n     * @param \\stdClass $data\n     * @return array\n     */\n    public function test($token = null, $data = null)\n    {\n        return [$token, $data];\n    }\n\n}@JWTValidation:JWT 验证注解属性名称说明nameJWT 配置名称id验证 ID。为 null 则使用配置中的值验证；为 false 则不验证issuer验证发行人。为 null 则使用配置中的值验证；为 false 则不验证audience验证接收。为 null 则使用配置中的值验证；为 false 则不验证subject验证主题。为 null 则使用配置中的值验证；为 false 则不验证tokenParamToken 对象注入的参数名称dataParam数据注入的参数名称Rsa配置配置 @app.beans：打开Git Bash Here 用openssl生成私匙文件：openssl genrsa -out pri_key.pem 2048根据私匙文件生成公匙：openssl rsa -in pri_key.pem -pubout -out pub_key.pem复制文件内容到配置上[\n    &#039;JWT&#039;   =&gt;  [\n        &#039;list&#039;  =&gt;  [\n            // a 为名称，可以自定义，以下被注释的项为非必设，一般有默认值\n            &#039;b&#039; =&gt;  [\n                &#039;signer&#039;    =&gt;  &#039;Rsa&#039;,      // 签名者，可选：Ecdsa/Hmac/Rsa\n                &#039;algo&#039;      =&gt;  &#039;Sha256&#039;,    // 算法，可选：Sha256/Sha384/Sha512\n                // &#039;dataName&#039;  =&gt;  &#039;data&#039;,      // 自定义数据字段名，放你需要往token里丢的数据\n                // &#039;audience&#039;  =&gt;  null,        // 接收，非必须\n                // &#039;subject&#039;   =&gt;  null,        // 主题，非必须\n                &#039;expires&#039;   =&gt;  86400,        // 超时秒数\n                // &#039;issuer&#039;    =&gt;  null,        // 发行人，非必须\n                // &#039;notBefore&#039; =&gt;  null,        // 实际日期必须大于等于本值\n                // &#039;issuedAt&#039;  =&gt;  true,        // JWT 发出时间。设为 true 则为当前时间；设为 false 不设置；其它值则直接写入\n                // &#039;id&#039;        =&gt;  null,        // Token id\n                // &#039;headers&#039;   =&gt;  [],          // 头\n                // 自定义获取 token 回调，返回值为 Token。默认从 Header Authorization 中获取。\n                // &#039;tokenHandler&#039;  =&gt;  null,\n                &#039;privateKey&#039;    =&gt;  &#039;-----BEGIN RSA PRIVATE KEY-----\nMIICXwIBAAKBgQDXj+GqRbpV2n2H1iOdnXwtvv6K+W7g9VqCQv7cf/DobqOH8cA7\n8jjsujk51ovklZl5q7NR/sr4se9ghYH3QecLKKeMZeSQh+4LJubdkAbv+0Wmig/Y\niAGTtJrK55OfVoVAJeCrMLERWPHvpnLBF/VoCjy0PwuExVEpA6dwqiD0xQIDAQAB\nAoGBALeTLNdZMmrS+3ym/QXJjGtY8GViLu8dg8rTS0B1JLCNKG8pjlB+48OWhA2h\njNlKHb3kX35AwpIw1m8Yw6nSUfM6uN0rL86IaHx6OzpB5ltWodXmHISATYcZ9Xn7\n5+dKRqpGPW5QR7N8lPrHGRN69o74bT4X7DVyZzsdfjgOna0xAkEA7GVmUjVFUg7B\n8KsypQKwDXF5kMNoC3CSjdQTBgSYXNjo1kQjBGoDgPlcEhbV0Ishw4z7sGdxnvkc\nid4KbnkwrwJBAOlwLsFDn7eXmVcmRb7s2enXkUdfp8gXzg57VFcxZ5UML1P6vilH\nF4LpJjqtluZGbvA7oD3dkaks7POkt0mgxssCQQDaB2fI+KL33O6Y530tXf48V+WU\nU/W5X1l8ABaPnVtdfx24yV02rASRRuvZL0CDOF+quXRFrhLIWeAtdCJQ4+u3AkEA\ngVHGdQZTas+vARqQtM5dgjALqXCScETPwDIObSdPbMCNT4au5gseOUWUChm0aOlH\n+AnwIZWnZgMfWXI8n6tTtQJBAKGVtbVsmwZN+5UDLziwWR6VLcZCzymocbJZ/PGi\ne49lnvOMZXg+9uLaQBiKCUqftQXaaFKj06hox6+25Rw1T0g=\n-----END RSA PRIVATE KEY-----\n&#039;,// 私钥\n                &#039;publicKey&#039;     =&gt;  &#039;-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDXj+GqRbpV2n2H1iOdnXwtvv6K\n+W7g9VqCQv7cf/DobqOH8cA78jjsujk51ovklZl5q7NR/sr4se9ghYH3QecLKKeM\nZeSQh+4LJubdkAbv+0Wmig/YiAGTtJrK55OfVoVAJeCrMLERWPHvpnLBF/VoCjy0\nPwuExVEpA6dwqiD0xQIDAQAB\n-----END PUBLIC KEY-----&#039;,// 公钥\n            ],\n        ],\n    ],\n]"},{"id":76,"title":"最大请求执行时间","pageTitle":"最大请求执行时间","url":"components/httpserver/maxExecuteTime.html","content":"最大请求执行时间目录在 php-fpm 中有 max_execution_time 这个选项，用来限定请求最大执行时间。imi 提供了一个中间件，用以支持设置最大请求执行时间，如果超时可以做提前返回结果的处理。仅支持 Swoole使用方法启用在服务器配置 beans 节中配置中间件ExecuteTimeoutMiddleware：[\n    &#039;HttpDispatcher&#039;    =&gt;    [\n        &#039;middlewares&#039;    =&gt;    [\n            &#039;ExecuteTimeoutMiddleware&#039;,\n        ],\n    ],\n]超时时间设置在服务器配置 beans 节中配置中间件ExecuteTimeoutMiddleware：[\n    &#039;ExecuteTimeoutMiddleware&#039; =&gt;  [\n        &#039;maxExecuteTime&#039;    =&gt;  3000, // 最长执行时间，单位：毫秒\n        &#039;handler&#039;           =&gt;  \\Imi\\Server\\Http\\Error\\ExecuteTimeoutHandler::class,\n    ],\n]上面的 handler 为 imi 内置的处理器，会返回一个错误状态码。自定义超时处理器定义一个类，实现 Imi\\Server\\Http\\Error\\IExecuteTimeoutHandler接口。实现方法：public function handle(Request $request, Response $response)目前 Swoole 不允许强行停止正在执行的协程，所以只是提前响应内容，而并不是中断任务执行，请知晓。"},{"id":64,"title":"中间件","pageTitle":"中间件","url":"components/httpserver/middleware.html","content":"中间件目录imi 框架遵循 PSR-7、PSR-15 标准，使用中间件来实现路由。中间件可以对整个请求和响应过程进行自定义处理imi 的路由匹配、执行动作、响应输出，都是依赖中间件实现，必要的时候你甚至可以把 imi 内置实现替换掉注意！最好不要在中间件中使用类属性，可能会造成冲突！定义中间件实现接口：Psr\\Http\\Server\\MiddlewareInterface方法：public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface先执行其它中间件：$response = $handler-&gt;handle($request);use Imi\\Bean\\Annotation\\Bean;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\n\n/**\n * @Bean\n */\nclass TestMiddleware implements MiddlewareInterface\n{\n    /**\n     * 处理方法\n     * @param ServerRequestInterface $request\n     * @param RequestHandlerInterface $handler\n     * @return ResponseInterface\n     */\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface\n    {\n        // 前置处理\n        \n        // 先执行其它中间件\n        $response = $handler-&gt;handle($request);\n        \n        // 后置处理\n        \n        return $response;\n    }\n}全局中间件return [\n    &#039;beans&#039;    =&gt;    [\n        // 中间件\n        &#039;HttpDispatcher&#039;    =&gt;    [\n            &#039;middleware&#039; =&gt; true, // 默认启用中间件，一旦设为 false，无论是全局还是局部中间件都不生效，可以提升性能\n            &#039;middlewares&#039;    =&gt;    [\n                // 中间件\n                \\Imi\\Server\\Session\\Middleware\\HttpSessionMiddleware::class,\n            ],\n        ],\n    ],\n];局部中间件注解使用class Index extends HttpController\n{\n    /**\n     * PHP 原生模版引擎演示\n     * 访问：http://127.0.0.1:8080/\n     * \n     * @Action\n     * @Route(url=&quot;/&quot;)\n     * @View(template=&quot;index&quot;)\n     * \n     * 单个中间件，浏览器 F12 看Response Header：\n     * @Middleware(\\ImiDemo\\HttpDemo\\Middlewares\\PoweredBy::class)\n     * @return void\n     */\n    public function index()\n    {\n        return [\n            &#039;title&#039;        =&gt;    &#039;hello imi&#039;,\n            &#039;content&#039;    =&gt;    &#039;imi is very six&#039;,\n        ];\n    }\n\n    /**\n     * 无@View注解，不用写代码，也可以渲染模版\n     * 访问：http://127.0.0.1:8080/Index/test\n     * \n     * @Action\n     * \n     * 多个中间件，浏览器 F12 看Response Header：\n     * @Middleware({\n     * \\ImiDemo\\HttpDemo\\Middlewares\\PoweredBy::class,\n     * \\ImiDemo\\HttpDemo\\Middlewares\\Test::class\n     * })\n     * \n     * @return void\n     */\n    public function test()\n    {\n\n    }\n}如上代码，index()方法中的@Middleware是设置单个。test()方法中的是设置多个中间件。具体请看imi-demo项目代码。中间件分组服务器 config.php：return [\n    &#039;middleware&#039;    =&gt;  [\n        &#039;groups&#039;    =&gt;  [\n            // 组名\n            &#039;test&#039;  =&gt;  [\n                // 中间件列表\n                \\Imi\\Test\\HttpServer\\ApiServer\\Middleware\\Middleware4::class,\n            ],\n        ],\n    ],\n];使用：@Middleware(&quot;@test&quot;)注入修改核心动作中间件服务器 config.php:[\n    &#039;beans&#039; =&gt;  [\n        &#039;ActionWrapMiddleware&#039;  =&gt;  [\n            &#039;actionMiddleware&#039;  =&gt;  &#039;自定义&#039;,\n        ],\n    ],\n]"},{"id":62,"title":"请求类","pageTitle":"请求类","url":"components/httpserver/request.html","content":"请求类目录imi 中的 Request 对象，可以用于获取参数、请求头等，遵循 PSR-7 标准。PSR-7: https://www.php-fig.org/psr/psr-7/imi 在 PSR-7 基础上，为所有 withXXX 方法都加上了 setXXX 用法，方便快捷无心智负担。获取 Request 对象控制器$this-&gt;request;请求上下文/** @var \\Imi\\Server\\Http\\Message\\Contract\\IHttpRequest $request */\n$request = \\Imi\\RequestContext::get(&#039;request&#039;);请求上下文代理/** @var \\Imi\\Server\\Http\\Message\\Contract\\IHttpRequest $request */\n$request = \\Imi\\Server\\Http\\Message\\Proxy\\RequestProxy::__getProxyInstance();操作 Request 对象通常可以先获取 Request 对象，然后再调用对象的方法。另外，你也可以直接通过请求上下文代理类，在任意地方使用，调用方式是静态方法调用：\\Imi\\Server\\Http\\Message\\Proxy\\RequestProxy::post(&#039;id&#039;);获取 GET 参数public function get($name = null, $default = null)当$name为null时，返回全部获取 POST 参数public function post($name = null, $default = null)获取 REQUEST 参数request 数据包含 get/post/cookiepublic function request($name = null, $default = null)当$name为null时，返回全部获取 JSON/XML 传参数据public function getParsedBody()返回值是数组或对象获取请求 Body$body = $this-&gt;request-&gt;getBody();\n// 获取数据内容\n// 方法一\n$data = $body-&gt;getContents();\n// 方法二\n$data = (string) $body;是否存在 GET 参数public function hasGet($name)是否存在 POST 参数public function hasPost($name)是否存在 REQUEST 参数request 数据包含 get/post/cookiepublic function hasRequest($name)获取所有 Cookiepublic function getCookieParams()获取 Cookie 值public function getCookie($name, $default = null)获取所有请求头public function getHeaders()请求头是否存在，不区分大小写public function hasHeader($name)获取请求头，不区分大小写，支持同名，返回数组public function getHeader($name)获取请求头，不区分大小写，支持同名，返回字符串public function getHeaderLine($name)获取请求方法 (GET/POST等)public function getMethod()获取 HTTP 协议版本public function getProtocolVersion()获取请求地址public function getUri()协议会根据当前服务器是否启用 ssl 判断，支持协议：http/https/ws/wssURI结构[scheme:]//[user-info@]host[:port][/path][?query][#fragment]当请求通过nginx转发时，此方法目前暂时无法正确判断scheme可在nginx配置location中添加 proxy_set_header X-Forwarded-Proto $scheme;通过获取请求头$this-&gt;request-&gt;getHeaderLine(&#039;x-forwarded-proto&#039;);来获取对应的scheme获取 Swoole 服务器对象public function getServerInstance(): \\Imi\\Swoole\\Server\\Http\\Server获取 Workerman 的 Worker 对象public function getWorker(): \\Workerman\\Worker获取 Workerman 的 http 请求对象public function getWorkermanRequest(): \\Workerman\\Protocols\\Http\\Request获取 Workerman 的连接对象public function getConnection(): \\Workerman\\Connection\\TcpConnection获取上传的文件public function getUploadedFiles()返回值为Imi\\Server\\Http\\Message\\UploadedFile数组简单示例：foreach ($request-&gt;getUploadedFiles() as $k =&gt; $file)\n{\n    if (0 === $file-&gt;getError())\n    {\n        $file-&gt;moveTo(&#039;上传文件保存路径&#039;);\n    }\n    else\n    {\n        throw new \\RuntimeException(sprintf(&#039;上传文件失败，错误码：%s&#039;, $file-&gt;getError()));\n    }\n    // 获取临时文件名\n    $tmpFileName = $file-&gt;getTmpFileName();\n}获取 Server 信息var_dump($this-&gt;request-&gt;getServerParams());\nvar_dump($this-&gt;request-&gt;getServerParam(&#039;path_info&#039;));输出：array(11) {\n  [&quot;request_method&quot;]=&gt;\n  string(3) &quot;GET&quot;\n  [&quot;request_uri&quot;]=&gt;\n  string(47) &quot;/xxx.html&quot;\n  [&quot;path_info&quot;]=&gt;\n  string(47) &quot;/xxx.html&quot;\n  [&quot;request_time&quot;]=&gt;\n  int(1538010416)\n  [&quot;request_time_float&quot;]=&gt;\n  float(1538010417.6185)\n  [&quot;server_port&quot;]=&gt;\n  int(8080)\n  [&quot;remote_port&quot;]=&gt;\n  int(62687)\n  [&quot;remote_addr&quot;]=&gt;\n  string(9) &quot;127.0.0.1&quot;\n  [&quot;master_time&quot;]=&gt;\n  int(1538010416)\n  [&quot;server_protocol&quot;]=&gt;\n  string(8) &quot;HTTP/1.1&quot;\n  [&quot;server_software&quot;]=&gt;\n  string(18) &quot;swoole-http-server&quot;\n}\nstring(47) &quot;/xxx.html&quot;获取客户端IP地址客户端直连服务端的情况下$address = $this-&gt;request-&gt;getClientAddress();\n$address-&gt;getAddress(); // ip\n$address-&gt;getPort(); // 端口\necho $address; // ip:端口若使用nginx转发到服务端情况下需在nginx配置location中添加proxy_set_header X-Real-IP $remote_addr;$address = $this-&gt;request-&gt;getHeaderLine(&#039;x-real-ip&#039;);获取 Swoole Request 对象/** @var \\Swoole\\Http\\Request $swooleRequest */\n$swooleRequest = $this-&gt;request-&gt;getSwooleRequest();绑定请求参数到控制器方法参数RequestParam 注解imi v2.1.27 引入的新注解。@RequestParam 注解的 name 是指定参数来源。你可以使用$get、$post、$body、$headers、$cookie、$session后面跟上.参数名指定参数，其中$get和$post自然不用多说，这$body的用处就是，比如参数是以json为body传给你的，他会自动给你json_decode，你用$body就可以指定了。@RequestParam 注释注解写法支持写在方法上。#[RequestParam()] PHP 原生注解写法支持写在方法和方法参数上。写在方法参数上时，无需指定 param 参数。required 表示是否为必选参数，默认为 true。default 表示默认值，当 required 为 false 时有效，默认值是 null。代码示例：/**\n * @Action\n *\n * @RequestParam(name=&quot;$get.id&quot;, param=&quot;id2&quot;)\n * @RequestParam(name=&quot;$get.id3&quot;, param=&quot;id3&quot;, required=false, default=&quot;imi 666&quot;)\n */\npublic function requestParam1(int $id, int $id2, string $id3): array\n{\n    return [\n        &#039;id&#039;  =&gt; $id,\n        &#039;id2&#039; =&gt; $id2,\n        &#039;id3&#039; =&gt; $id3,\n    ];\n}\n\n/**\n * @Action\n */\npublic function requestParam2(\n    int $id,\n    #[RequestParam(name: &#039;$get.id&#039;)]\n    int $id2,\n    #[RequestParam(name: &#039;$get.id3&#039;, required: false, default: &#039;imi niubi&#039;)]\n    string $id3\n    ): array {\n    return [\n        &#039;id&#039;  =&gt; $id,\n        &#039;id2&#039; =&gt; $id2,\n        &#039;id3&#039; =&gt; $id3,\n    ];\n}ExtractData 注解将在 imi 3.0 中废弃，推荐使用 RequestParam 注解。代码示例：/**\n * http参数验证测试\n * \n * @Action\n * \n * @ExtractData(name=&quot;$get.id&quot;, to=&quot;id&quot;)\n * @ExtractData(name=&quot;$get.name&quot;, to=&quot;name&quot;)\n * @ExtractData(name=&quot;$get.age&quot;, to=&quot;age&quot;)\n *\n * @return void\n */\npublic function httpValidation($id, $name, $age)\n{\n    return compact(&#039;id&#039;, &#039;name&#039;, &#039;age&#039;);\n}"},{"id":66,"title":"响应类","pageTitle":"响应类","url":"components/httpserver/response.html","content":"响应类目录imi 中的 Response 对象，可以用于响应内容，遵循 PSR-7 标准。PSR-7: https://www.php-fig.org/psr/psr-7/imi 在 PSR-7 基础上，为所有 withXXX 方法都加上了 setXXX 用法，方便快捷无心智负担。获取 Response 对象控制器$this-&gt;response;请求上下文/** @var \\Imi\\Server\\Http\\Message\\Contract\\IHttpResponse $response */\n$response = \\Imi\\RequestContext::get(&#039;response&#039;);请求上下文代理/** @var \\Imi\\Server\\Http\\Message\\Contract\\IHttpResponse $response */\n$response = \\Imi\\Server\\Http\\Message\\Proxy\\ResponseProxy::__getProxyInstance();操作 Response 对象通常可以先获取 Response 对象，然后再调用对象的方法。另外，你也可以直接通过请求上下文代理类，在任意地方使用，调用方式是静态方法调用：\\Imi\\Server\\Http\\Message\\Proxy\\ResponseProxy::setStatus(404);重定向public function redirect($url, $status = StatusCode::FOUND)$status 是状态码，默认302，可以使用StatusCode::XXX常量设置Cookiepublic function withCookie($key, $value, $expire = 0, $path = &#039;/&#039;, $domain = &#039;&#039;, $secure = false, $httponly = false)发送所有响应数据public function send()发送文件，一般用于文件下载/**\n * 发送文件，一般用于文件下载.\n *\n * @param string      $filename       要发送的文件名称，文件不存在或没有访问权限sendfile会失败\n * @param string|null $contentType    Content-Type 响应头，不填则自动识别\n * @param string|null $outputFileName 下载文件名，不填则自动识别，如：123.zip\n * @param int         $offset         上传文件的偏移量，可以指定从文件的中间部分开始传输数据。此特性可用于支持断点续传。\n * @param int         $length         发送数据的尺寸，默认为整个文件的尺寸\n *\n * @return static\n */\npublic function sendFile(string $filename, ?string $contentType = null, ?string $outputFileName = null, int $offset = 0, int $length = 0): self例：/**\n * @Action\n */\npublic function downloadFile()\n{\n    $this-&gt;response-&gt;sendFile(__FILE__); // 下载当前文件，实际上你可以指定服务器上的文件\n}发送图片一般可用于二维码场景/**\n * @Action\n */\npublic function image()\n{\n    // 生成图片\n    $img = imagecreatetruecolor(256, 256);\n    $color = imagecolorallocate($img, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));\n    imagefill($img, 0, 0, $color);\n\n    // 生成图片二进制到变量\n    ob_start();\n    imagejpeg($img);\n    $imgContent = ob_get_clean();\n\n    // 输出响应头和图片二进制内容\n    $this-&gt;response-&gt;setHeader(\\Imi\\Util\\Http\\Consts\\ResponseHeader::CONTENT_TYPE, \\Imi\\Util\\Http\\Consts\\MediaType::IMAGE_JPEG)\n                    -&gt;getBody()-&gt;write($imgContent);\n    return $this-&gt;response;\n}响应头是否可写public function isHeaderWritable()响应主体是否可写public function isBodyWritable()获取swoole响应对象public function getSwooleResonse(): \\Swoole\\Http\\Response获取对应的服务器public function getServerInstance(): \\Imi\\Swoole\\Server\\Contract\\ISwooleServer设置状态码public function withStatus($code, $reasonPhrase = &#039;&#039;)设置返回头public function withHeader($name, $value)$reponse-&gt;withHeader(&#039;test&#039;, &#039;v1&#039;);\n$reponse-&gt;withHeader(&#039;test&#039;, [&#039;v2&#039;, &#039;v3&#039;]);\n// 最终header中test为v2,v3添加返回头public function withAddedHeader($name, $value)$reponse-&gt;withAddedHeader(&#039;test&#039;, &#039;v1&#039;);\n$reponse-&gt;withAddedHeader(&#039;test&#039;, [&#039;v2&#039;, &#039;v3&#039;]);\n// 最终header中test为v1,v2,v3获取 Trailer 列表public function getTrailers(): arrayTrailer 仅 Http2 中使用Trailer 是否存在public function hasTrailer(string $name): bool获取 Trailer 值public function getTrailer(string $name): ?string设置 Trailer 返回新对象public function withTrailer(string $name, string $value): self设置 Trailerpublic function setTrailer(string $name, string $value): self获取 Swoole Response 对象/** @var \\Swoole\\Http\\Response $swooleResponse */\n$swooleResponse = $this-&gt;response-&gt;getSwooleResponse();获取 Workerman 的 http 响应对象public function getWorkermanResponse(): \\Workerman\\Protocols\\Http\\Response"},{"id":69,"title":"RESTful","pageTitle":"RESTful","url":"components/httpserver/restful.html","content":"RESTful目录使用 imi 提供的路由请求方法判断，可以实现 RESTful 风格的 api 开发。RESTful 风格控制器示例 (query/find/create/update/delete)：&lt;?php\nnamespace ImiDemo\\HttpDemo\\MainServer\\Controller;\n\nuse Imi\\Controller\\HttpController;\nuse Imi\\Server\\View\\Annotation\\View;\nuse Imi\\Server\\Http\\Route\\Annotation\\Route;\nuse Imi\\Server\\Http\\Route\\Annotation\\Action;\nuse Imi\\Server\\Http\\Route\\Annotation\\Controller;\n\n/**\n * @Controller(prefix=&quot;/rest&quot;)\n */\nclass Rest extends HttpController\n{\n    /**\n     * query\n     * \n     * @Action\n     * @Route(url=&quot;&quot;, method={&quot;GET&quot;})\n     * @return void\n     */\n    public function query()\n    {\n        return [1, 2, 3];\n    }\n    \n    /**\n     * find\n     * \n     * @Action\n     * @Route(url=&quot;./{id}&quot;, method={&quot;GET&quot;})\n     * \n     * @param int $id\n     * @return void\n     */\n    public function find($id)\n    {\n        return [\n            &#039;id&#039;    =&gt;    $id,\n        ];\n    }\n\n    /**\n     * create\n     * \n     * @Action\n     * @Route(url=&quot;&quot;, method={&quot;POST&quot;})\n     * @return void\n     */\n    public function create()\n    {\n        return [\n            &#039;operation&#039;    =&gt;    &#039;create&#039;,\n            &#039;postData&#039;    =&gt;    $this-&gt;request-&gt;getParsedBody(),\n            &#039;success&#039;    =&gt;    true,\n        ];\n    }\n\n    /**\n     * update\n     * \n     * @Action\n     * @Route(url=&quot;./{id}&quot;, method={&quot;PUT&quot;})\n     * \n     * @param int $id\n     * @return void\n     */\n    public function update($id)\n    {\n        return [\n            &#039;id&#039;        =&gt;    $id,\n            &#039;operation&#039;    =&gt;    &#039;update&#039;,\n            &#039;success&#039;    =&gt;    true,\n        ];\n    }\n\n    /**\n     * delete\n     * \n     * @Action\n     * @Route(url=&quot;./{id}&quot;, method={&quot;DELETE&quot;})\n     * \n     * @param int $id\n     * @return void\n     */\n    public function delete($id)\n    {\n        return [\n            &#039;id&#039;        =&gt;    $id,\n            &#039;operation&#039;    =&gt;    &#039;delete&#039;,\n            &#039;success&#039;    =&gt;    true,\n        ];\n    }\n}"},{"id":59,"title":"路由","pageTitle":"路由","url":"components/httpserver/route.html","content":"路由目录定义路由规则，让 imi 可以根据请求，导航到你写的控制器里。启用路由服务器配置文件中加入中间件：return [\n    &#039;beans&#039; =&gt;  [\n        &#039;HttpDispatcher&#039;    =&gt;  [\n            &#039;middlewares&#039;   =&gt;  [\n                \\Imi\\Server\\Http\\Middleware\\RouteMiddleware::class,\n            ],\n        ],\n    ],\n];通过配置注入形式，实现非常灵活的配置，你甚至可以自己另外实现路由中间件，而不用被框架自带的中间件所影响，用哪些中间件都在你的掌控之中！路由配置return [\n    &#039;beans&#039; =&gt; [\n        &#039;HttpRoute&#039; =&gt; [\n            // 全局忽略 URL 路由大小写\n            &#039;ignoreCase&#039;     =&gt; false,\n            // 全局支持智能尾部斜杠，无论是否存在都匹配\n            &#039;autoEndSlash&#039;   =&gt; false,\n        ],\n    ],\n];注解说明@Controller类名：\\Imi\\Server\\Http\\Route\\Annotation\\Controller注释目标：类表明一个类是控制器类属性名称说明prefix动作配置的访问地址前缀，如果动作配置的访问地址规则以/开始，则本属性无效server指定当前控制器允许哪些服务器使用。支持字符串或数组，默认为 null 则不限制。主服务器名是:main@Route类名：\\Imi\\Server\\Http\\Route\\Annotation\\Route注释目标：方法指定路由规则属性名称说明url请求地址规则。以/开头则忽视@Controller中的prefix为空或以./开头则在@Controller中的prefix后加上路由定义支持代入{name}形式占位符，匹配出来的值可以作为参数传入动作支持正则写法：{id:\\d+}method如果设置了method，则请求方法必须在method列表中才可以进到动作。支持字符串和数组。如：&quot;GET&quot;或{&quot;GET&quot;, &quot;POST&quot;}domain判断域名，只有符合条件才允许访问。支持字符串和数组，支持{name}形式占位符，可以作为参数传入动作paramsGet判断GET参数，只有符合条件才允许访问。可以是字符串或数组。id=100必须包含id，并且值为100id!=100或id&lt;&gt;100必须包含id，并且值不为100id必须包含id参数!id必须不包含id参数[&quot;id&quot; =&gt; &quot;\\d+&quot;]支持正则paramsPost判断POST参数，用法同paramsGetparamsBody判断 JSON、XML 参数，用法同paramsGetparamsBodyMultiLevelJSON、XML参数条件支持以 . 作为分隔符，支持多级参数获取，默认为trueheader判断请求头，用法同paramsGetrequestMime请求的mime类型判断判断请求头中的Content-Type中是否包含这些mime类型之一支持字符串和字符串数组ignoreCase忽略请求地址大小写null-取HttpRoute中默认值true-忽略大小写false-严格判断autoEndSlash智能尾部斜杠，无论是否存在都匹配null-取HttpRoute中默认值true-忽略大小写false-严格判断@Action类名：\\Imi\\Server\\Http\\Route\\Annotation\\Action注释目标：方法表明一个方法是动作属性：无如下代码所示，一个最简单的控制器+路由注解代码。&lt;?php\nnamespace Test;\n\nuse Imi\\Controller\\HttpController;\nuse Imi\\Server\\Http\\Route\\Annotation\\Route;\nuse Imi\\Server\\Http\\Route\\Annotation\\Action;\nuse Imi\\Server\\Http\\Route\\Annotation\\Controller;\n\n/**\n * 一个简单的控制器\n * @Controller\n */\nclass Index extends HttpController\n{\n    /**\n     * 一个动作\n     * @Action\n     * @Route(url=&quot;/&quot;)\n     */\n    public function index()\n    {\n        $this-&gt;response-&gt;getBody()-&gt;write(&#039;hello imi!&#039;);\n        return $this-&gt;response;\n    }\n}访问地址：http://localhost:{port}/输出内容：hello imi!获取当前路由解析结果 (routeResult)$routeResult = RequestContext::get(&#039;routeResult&#039;);$routeResult 定义：/**\n * 路由ID.\n */\npublic int $id = 0;\n\n/**\n * 路由配置项.\n *\n * @var \\Imi\\Server\\Http\\Route\\RouteItem\n */\npublic RouteItem $routeItem;\n\n/**\n * 参数.\n */\npublic array $params = [];\n\n/**\n * 回调.\n *\n * @var callable\n */\npublic $callable;$routeResult-&gt;routeItem 定义：/**\n * 注解.\n */\npublic Route $annotation;\n\n/**\n * 回调.\n *\n * @var callable\n */\npublic $callable;\n\n/**\n * 中间件列表.\n */\npublic array $middlewares = [];\n\n/**\n * WebSocket 配置.\n *\n * @var WSConfig\n */\npublic ?WSConfig $wsConfig = null;\n\n/**\n * 其它配置项.\n */\npublic array $options = [];\n\n/**\n * 视图注解.\n */\npublic View $view;\n\n/**\n * 视图配置注解.\n */\npublic ?BaseViewOption $viewOption = null;"},{"id":70,"title":"Session","pageTitle":"Session","url":"components/httpserver/session.html","content":"Session目录imi 的 Http Session 目前内嵌支持文件和 Redis 两种存储方式，当然你也可以自行扩展更多存储方式。如果想要启用 Session，需要在配置文件中进行设置。配置在服务器配置文件中：return [\n    &#039;beans&#039;    =&gt;    [\n        &#039;SessionManager&#039;    =&gt;    [\n            // 指定 Session 存储驱动类\n            &#039;handlerClass&#039;    =&gt;    \\Imi\\Server\\Session\\Handler\\File::class,\n        ],\n        &#039;SessionConfig&#039;    =&gt;    [\n            // session 名称，默认为imisid\n            &#039;name&#039;    =&gt;    &#039;imisid&#039;,\n            // 每次请求完成后触发垃圾回收的概率，默认为1%，可取值0~1.0，概率为0%~100%\n            &#039;gcProbability&#039;    =&gt;    0.01,\n            // 最大存活时间，默认30天，单位秒\n            &#039;maxLifeTime&#039;=&gt;    86400 * 30,\n            // session 前缀\n            &#039;prefix&#039; =&gt; null,\n        ],\n        &#039;SessionCookie&#039;    =&gt;    [\n            // 是否启用 Cookie\n            &#039;enable&#039;    =&gt;  true,\n            // Cookie 的生命周期，以秒为单位。\n            &#039;lifetime&#039;    =&gt;    0,\n            // 此 cookie 的有效路径。 on the domain where 设置为“/”表示对于本域上所有的路径此 cookie 都可用。\n            &#039;path&#039;        =&gt;    &#039;/&#039;,\n            // Cookie 的作用域。 例如：“www.php.net”。 如果要让 cookie 在所有的子域中都可用，此参数必须以点（.）开头，例如：“.php.net”。\n            &#039;domain&#039;    =&gt;    &#039;&#039;,\n            // 设置为 TRUE 表示 cookie 仅在使用安全链接时可用。\n            &#039;secure&#039;    =&gt;    false,\n            // 设置为 TRUE 表示 PHP 发送 cookie 的时候会使用 httponly 标记。\n            &#039;httponly&#039;    =&gt;    false,\n        ],\n        // 配置中间件\n        &#039;HttpDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                // Session 中间件\n                \\Imi\\Server\\Session\\Middleware\\HttpSessionMiddleware::class,\n            ],\n        ],\n    ],\n];其中每一种存储方式还有特别的配置项，请看下文。文件服务器配置文件-&gt;beans中加入：&#039;beans&#039;    =&gt;    [\n    &#039;SessionFile&#039;    =&gt;    [\n        &#039;savePath&#039;    =&gt;    &#039;Session文件存储路径&#039;,\n    ]\n]文件 Session 未来不支持分布式，推荐使用 Redis！Redis&#039;beans&#039;    =&gt;    [\n    &#039;SessionRedis&#039;    =&gt;    [\n        // Redis连接池名称\n        &#039;poolName&#039;    =&gt;    &#039;&#039;,\n        // Redis中存储的key前缀，可以用于多系统session的分离\n        // &#039;keyPrefix&#039;    =&gt;    &#039;imi:&#039;,\n    ]\n]Session 存储序列化方式配置根据你选用的存储驱动类，配置在对应的节里，下面以文件驱动演示&#039;beans&#039;    =&gt;    [\n    &#039;SessionFile&#039;    =&gt;    [\n        &#039;formatHandlerClass&#039;    =&gt;    \\Imi\\Util\\Format\\PhpSerialize::class,\n    ]\n]可以选用的序列化类：JSON:\\Imi\\Util\\Format\\Json::classPHP序列化:\\Imi\\Util\\Format\\PhpSerialize::classPHP Session 序列化:\\Imi\\Util\\Format\\PhpSession::class （兼容 php-fpm 默认的 Session 存储格式）使用引入 Session 类use Imi\\Server\\Session\\Session;读取// 获取值\nSession::get(&#039;aaa&#039;);\n// 获取值，如果不存在则返回默认值\nSession::get(&#039;aaa&#039;, &#039;default value&#039;);\n// 获取$session[&#039;a&#039;][&#039;b&#039;]的值\nSession::get(&#039;a.b&#039;);\n// 获取$session[前缀][&#039;aaa&#039;]的值，前缀在配置文件中设置\nSession::get(&#039;@.aaa&#039;);写入Session::set($name, $value)删除Session::delete($name)读取并删除Session::once($name, $default = false)清空数据清空数据是数据没了，文件、key还在Session::clear();销毁数据销毁数据是文件、key都没了，当前 session 也关闭了Session::destroy();自定义 Session ID 获取方式config.php:[\n    &#039;beans&#039;    =&gt;    [\n        \\Imi\\Server\\Session\\Middleware\\HttpSessionMiddleware::class =&gt; [\n            &#039;sessionIdHandler&#039;    =&gt;    function(\\Imi\\Server\\Http\\Message\\Request $request){\n                // 举例，比如希望从 header 中获取\n                return $request-&gt;getHeaderLine(&#039;X-Session-ID&#039;);\n            },\n        ],\n    ],\n]其它开启：public function start(?string $sessionId = null): void关闭：public function close(): void保存：public function save(): void保存并关闭：public function commit(): void是否已开启：public function isStart()尝试垃圾回收：public function tryGC(): void垃圾回收：public function gc(): void获取 Session name：public function getName(): string获取 Session id：public function getId(): string获取 Session 处理器：public function getHandler(): \\Imi\\Server\\Session\\Handler\\ISessionHandler获取 Session 配置：public function getConfig(): \\Imi\\Server\\Session\\SessionConfig是否修改了 Session 数据：public function isChanged(): bool当前是否是新的会话：public function isNewSession(): bool"},{"id":68,"title":"SSE","pageTitle":"SSE","url":"components/httpserver/sse.html","content":"SSE目录SSE 介绍SSE 是一种服务端主动向客户端（浏览器）推送数据的技术。大名鼎鼎的 ChatGPT 的 API 接口就用了这项技术，实现逐字返回的打字机效果。服务端向客户端发送一个响应头：Content-Type: text/event-stream然后服务端按如下格式发送数据：: 注释\ndata: 数据\\n\nevent: 事件\\n\nid: id值\\n\nretry: 重试时间间隔，单位：秒\\n\\n其中每一行都是非必传项，每一行必须以 \\n 结尾\\n\\n 代表一次推送的结束环境支持名称是否支持备注Swoole✔ Workerman✔ php-fpm✔ RoadRunner✖暂时无法实现使用示例use Imi\\Server\\Http\\Message\\Emitter\\SseEmitter;\nuse Imi\\Server\\Http\\Message\\Emitter\\SseMessageEvent;\n\n/**\n * SSE.\n *\n * @Action\n */\npublic function sse(): void\n{\n    $this-&gt;response-&gt;setResponseBodyEmitter(new class() extends SseEmitter {\n        protected function task(): void\n        {\n            $handler = $this-&gt;getHandler();\n            // 模拟推送数据\n            foreach (range(1, 100) as $i)\n            {\n                // 推送数据\n                $handler-&gt;send((string) new SseMessageEvent((string) $i));\n                usleep(10000);\n            }\n        }\n    });\n}SseMessageEventImi\\Server\\Http\\Message\\Emitter\\SseMessageEvent 类是 SSE 推送事件类，构造方法参数如下：public function __construct(\n    ?string $data = null,\n    ?string $event = null,\n    ?string $id = null,\n    ?int $retry = null,\n    ?string $comment = null\n)"},{"id":75,"title":"超全局变量","pageTitle":"超全局变量","url":"components/httpserver/superGlobals.html","content":"超全局变量目录一般来讲，在非 PHP-FPM 项目中，你是无法使用 $_GET、$_POST等超全局变量的。自 imi v1.0.15 版本开始支持，启用方法：在项目配置文件的 beans 中加入：[\n    &#039;SuperGlobals&#039;  =&gt;  [\n        &#039;enable&#039;    =&gt;  true,\n    ],\n]"},{"id":"645b0aa9cf6e67.84421139","title":"","pageTitle":"","url":"components/httpserver/tcp-fu-wu-qi.html","content":""},{"id":74,"title":"HTTP 验证器","pageTitle":"HTTP 验证器","url":"components/httpserver/validation.html","content":"HTTP 验证器目录请先阅读 验证器 章节，HTTP 验证器基于验证器扩展，基本使用方式相似。@HttpValidation首先，HTTP 验证器是@HttpValidation注解，它只能写在方法上。写了这个注解，在action方法调用前会触发验证，验证失败同样的抛出异常验证注解@Required等验证注解的name属性用法跟验证器章节中说明的略有不同。你可以使用$get、$post、$body、$headers、$cookie、$session、$this后面跟上.参数名指定参数，其中get和post自然不用多说，这body的用处就是，比如参数是以json为body传给你的，他会自动给你json_decode，你用$body就可以指定了。$this 代表是当前控制器对象。在 HTTP 验证器场景下，不推荐在验证注解上指定 default 参数，而是应该直接给方法参数加上默认值。@ExtractData还有一个@ExtractData注解，它可以把get/post/body中的参数导出到action方法的参数中。@ExtractData注解可以独立使用，不依赖@HttpValidation注解，但只能在控制器中使用。示例/**\n * http参数验证测试\n * \n * @Action\n * \n * @HttpValidation\n * \n * @Required(name=&quot;$get.id&quot;, message=&quot;用户ID为必传参数&quot;)\n * @Integer(name=&quot;$get.id&quot;, min=1, message=&quot;用户ID不符合规则&quot;)\n * @Required(name=&quot;$get.name&quot;, message=&quot;用户姓名为必传参数&quot;)\n * @Text(name=&quot;$get.name&quot;, min=2, message=&quot;用户姓名长度不得少于2位&quot;)\n * @Required(name=&quot;$get.age&quot;)\n * \n * @ExtractData(name=&quot;$get.id&quot;, to=&quot;id&quot;)\n * @ExtractData(name=&quot;$get.name&quot;, to=&quot;name&quot;)\n * @ExtractData(name=&quot;$get.age&quot;, to=&quot;age&quot;)\n *\n * @return void\n */\npublic function httpValidation($id, $name, $age = -1)\n{\n    return compact(&#039;id&#039;, &#039;name&#039;, &#039;age&#039;);\n}"},{"id":67,"title":"视图","pageTitle":"视图","url":"components/httpserver/view.html","content":"视图目录在前面讲到的例子中，几乎都是直接对$response进行操作，然而实际上很少需要对其直接操作的情况。在 imi 中可以使用视图来决定响应内容和格式，包括JSON、XML、模版渲染在内的 imi 认为都是视图，视图可以直接通过注解来设置。&lt;?php\nnamespace Test;\n\nuse Imi\\Controller\\HttpController;\nuse Imi\\Server\\Http\\Route\\Annotation\\Route;\nuse Imi\\Server\\Http\\Route\\Annotation\\Action;\nuse Imi\\Server\\Http\\Route\\Annotation\\Controller;\nuse Imi\\Server\\View\\Annotation\\HtmlView;\nuse Imi\\Server\\View\\Annotation\\View;\n\n/**\n * 一个简单的控制器\n * @Controller\n * @View(renderType=&quot;json&quot;)\n * @HtmlView(baseDir=&quot;index/&quot;)\n */\nclass Index extends HttpController\n{\n       /**\n        * 一个动作\n        * @Action\n        * @Route(url=&quot;/&quot;)\n        * @View(renderType=&quot;html&quot;)\n        * @HtmlView(template=&quot;index&quot;)\n        */\n        public function index()\n        {\n            $this-&gt;response-&gt;getBody()-&gt;write(&#039;hello imi!&#039;);\n            return $this-&gt;response;\n        }\n}如上代码所示，@View和@HtmlView注解可以写在类和方法的注释中。@HtmlView注解的baseDir属性是模板基础路径，/开头为绝对路径。类注解代表针对所有动作设定的视图配置，在单个方法上写注解，会覆盖类注解对应的配置。json/**\n * @Action\n * @View(renderType=&quot;json&quot;)\n */\npublic function index()\n{\n    // 数组\n    $jsonData = [\n        &#039;id&#039;    =&gt;    1,\n        &#039;name&#039;    =&gt;    &#039;imi&#039;,\n    ];\n    // 对象\n    // $jsonData = new stdClass;\n    // $jsonData-&gt;name = &#039;imi&#039;;\n    return $jsonData;\n}可选配置return [\n    &#039;beans&#039;        =&gt;    [\n        &#039;JsonView&#039;    =&gt;    [\n            // json_encode 的参数值配置\n            &#039;options&#039;    =&gt;    \\JSON_THROW_ON_ERROR | \\JSON_UNESCAPED_SLASHES | \\JSON_UNESCAPED_UNICODE,\n            &#039;depth&#039;        =&gt;    512,\n        ]\n    ]\n];xml/**\n * @Action\n * @View(renderType=&quot;xml&quot;)\n */\npublic function index()\n{\n    // DOMDocument\n    $xml = new \\DOMDocument();\n    $xml-&gt;loadXML($xmlString);\n    \n    // SimpleXMLElement\n    $xml = \\simplexml_load_string($xmlString);\n    \n    return $xml;\n}模版渲染必选配置return [\n    &#039;beans&#039;        =&gt;    [\n        &#039;HtmlView&#039;    =&gt;    [\n            &#039;templatePath&#039;    =&gt;    &#039;模版文件根路径&#039;,\n            // 支持的模版文件扩展名，优先级按先后顺序\n            // &#039;fileSuffixs&#039;        =&gt;    [\n                &#039;tpl&#039;,\n                &#039;html&#039;,\n                &#039;php&#039;\n            ],\n        ]\n    ]\n];使用方式通过注解配置/**\n * @Action\n * @View(renderType=&quot;html&quot;)\n * @HtmlView(template=&quot;a/b&quot;)\n */\npublic function index()\n{\n    return [\n        &#039;content&#039;    =&gt;    &#039;hello imi&#039;,\n    ];\n}语句动态渲染/**\n * @Action\n */\npublic function index()\n{\n    return $this-&gt;__render(&#039;a/b&#039;, [\n        &#039;content&#039;    =&gt;    &#039;hello imi&#039;,\n    ]);\n}模版文件模版基础路径/a/b.html&lt;?=$content?&gt;运行结果：hello imiimi 没有造模版引擎的轮子，是因为现在 PHP 渲染 HTML 的场景越来越少，如果有需要也可以自己集成其它开源模版引擎。其它在控制器-动作中，除了返回数据，你还可以直接返回$this-&gt;response，如：$this-&gt;response-&gt;getBody()-&gt;write(&#039;hello world&#039;);\nreturn $this-&gt;response;你还可以直接返回@View的注解类实例：return new \\Imi\\Server\\View\\Annotation\\View([\n    &#039;template&#039;    =&gt;    &#039;index&#039;,\n    &#039;renderType&#039;=&gt;    &#039;html&#039;,\n    &#039;data&#039;        =&gt;    [\n        &#039;name&#039;    =&gt;    &#039;imi&#039;,\n    ],\n]);"},{"id":203,"title":"InfluxDB","pageTitle":"InfluxDB","url":"components/influxdb.html","content":"InfluxDB目录InfluxDB 是一个开源的时间序列数据库，没有外部依赖性。它对记录指标、事件和执行分析很有用。项目地址：https://github.com/influxdata/influxdbimi-influxdb：https://github.com/imiphp/imi-influxdb目前 imi 仅支持 InfluxDB &lt; 1.8安装composer require imiphp/imi-influxdb:~2.1.0使用说明InfluxDB 连接管理配置连接config.php：[\n    &#039;influxDB&#039;  =&gt; [\n        &#039;clients&#039;   =&gt; [\n            // default 是连接名称，可以随意更改\n            &#039;default&#039;   =&gt; [\n                &#039;host&#039;              =&gt; &#039;127.0.0.1&#039;, // 主机名\n                &#039;port&#039;              =&gt; 8086, // 端口\n                &#039;username&#039;          =&gt; &#039;&#039;, // 用户名\n                &#039;password&#039;          =&gt; &#039;&#039;, // 密码\n                &#039;defaultDatabase&#039;   =&gt; &#039;&#039;, // 默认数据库名\n                &#039;ssl&#039;               =&gt; false, // 是否启用 SSL\n                &#039;verifySSL&#039;         =&gt; false, // 是否验证 SSL 证书\n                &#039;timeout&#039;           =&gt; 0, // 超时时间\n                &#039;connectTimeout&#039;    =&gt; 0, // 连接超时时间\n                &#039;path&#039;              =&gt; &#039;/&#039;, // 请求路径前缀\n                &#039;createDatabase&#039;    =&gt; true, // 当数据库不存在时，自动创建数据库\n            ],\n        ],\n        &#039;default&#039;   =&gt; &#039;default&#039;, // 默认连接名\n    ],\n]TDengine InfluxDB 所需修改的配置：// 连接配置一定要设置这几项\n[\n    &#039;port&#039;              =&gt; 6041,\n    &#039;path&#039;              =&gt; &#039;/influxdb/v1/&#039;,\n    &#039;createDatabase&#039;    =&gt; false,\n    &#039;username&#039;          =&gt; &#039;root&#039;,\n    &#039;password&#039;          =&gt; &#039;taosdata&#039;,\n]获取客户端对象use Imi\\InfluxDB\\InfluxDB;\n\n$client = InfluxDB::getClient(); // 获取默认客户端\n$client = InfluxDB::getClient(&#039;default&#039;); // 获取指定名称客户端获取数据库对象use Imi\\InfluxDB\\InfluxDB;\n\n$db = InfluxDB::getDatabase(); // 获取默认数据库名的对象\n$db = InfluxDB::getDatabase(&#039;dbname&#039;); // 获取指定数据库名的对象\n$db = InfluxDB::getDatabase(null, &#039;default&#039;); // 指定客户端名称使用数据库对象$db = InfluxDB::getDatabase();\n$db-&gt;query(); // SQL 查询\n$db-&gt;writePoints(); // 写入数据详细用法请参考：https://github.com/influxdata/influxdb-phpInfluxDB ORM详细用法请参考：https://github.com/Yurunsoft/influxdb-orm"},{"id":187,"title":"imi 组件列表一览","pageTitle":"imi 组件列表一览","url":"components/list.html","content":"imi 组件列表一览目录官方组件PostgreSQLMQTTRPCgRPCHprose消息队列AMQPKafkaJWT权限控制Smarty 模版引擎限流跨进程变量共享雪花算法发号器Swagger API 文档生成Swoole TrackerInfluxDBTDengine优秀的第三方组件权限控制 (phpben/imi-auth)注册中心 (phpben/imi-config-center)模块化路由 (phpben/imi-module-route)ThinkPHP6 验证器 (phpben/imi-validate)优秀的开源项目后台管理框架 (phpben/imi-admin)"},{"id":175,"title":"AtomicLock","pageTitle":"AtomicLock","url":"components/lock/atomic.html","content":"AtomicLock目录AtomicLock 是单机进程锁，会阻塞。使用前需要配置 Atomic。注意！会阻塞当前进程，不建议在 worker 进程中使用！类：Imi\\Swoole\\Lock\\Handler\\AtomicBean 名：AtomicLock可配置参数/**\n * 锁的唯一 ID\n *\n * @var string\n */\nprotected $id;\n\n/**\n * 等待锁超时时间，单位：毫秒，0为不限制\n * \n * @var int\n */\nprotected $waitTimeout = 3000;\n\n/**\n * 锁超时时间，单位：毫秒\n * \n * @var int\n */\nprotected $lockExpire = 3000;\n\n/**\n * 配置的 Atomic 名称\n *\n * @var string\n */\npublic $atomicName;\n\n/**\n * 同时获得锁的数量\n * \n * @var int\n */\npublic $quantity = 1;\n\n/**\n * 执行超时抛出异常\n *\n * @var bool\n */\npublic $timeoutException = false;\n\n/**\n * 解锁失败抛出异常\n *\n * @var bool\n */\npublic $unlockException = false;\n配置示例// 锁\n&#039;lock&#039;  =&gt;[\n    &#039;list&#039;  =&gt;  [\n        &#039;atomic&#039; =&gt;  [\n            &#039;class&#039; =&gt;  &#039;AtomicLock&#039;,\n            &#039;options&#039;   =&gt;  [\n                &#039;atomicName&#039;    =&gt;  &#039;atomicLock&#039;,\n            ],\n        ],\n    ],\n],"},{"id":173,"title":"锁","pageTitle":"锁","url":"components/lock/index.html","content":"锁目录锁（Lock），在并发处理，防止冲突的场景非常常用。在 imi 中，你可以使用注解，或者自己实例化Lock类来实现加锁处理。除了内置的锁驱动外，你可以实现Imi\\Lock\\Handler\\ILockHandler接口，来实现其他方式的锁。配置用法需要在配置中预定义配置说明// 锁\n&#039;lock&#039;  =&gt;[\n    &#039;list&#039;  =&gt;  [\n        // 锁 ID =&gt; 配置\n        &#039;redis&#039; =&gt;  [\n            &#039;class&#039; =&gt;  &#039;RedisLock&#039;, // Handler 类 Bean 名或完整类名\n            &#039;options&#039;   =&gt;  [\n                // Handler 类所需配置\n                &#039;poolName&#039;  =&gt;  &#039;redis_test&#039;,\n            ],\n        ],\n    ],\n],使用说明顺序用法：use Imi\\Lock\\Lock;\n$lockId = &#039;&#039;; // 你定义的ID\nif(Lock::lock($lockId))\n{\n    try {\n        // 干一些事情\n    } catch(\\Throwable $th) {\n        throw $th;\n    } finally {\n        Lock::unlock($lockId);\n    }\n}回调用法（无需手动释放锁）：$result = Lock::lock($lockId, function(){\n    // 执行任务\n}, function(){\n    // return 非null则不执行任务\n    // 一般用于防止缓存击穿\n    // 这个回调可以不传\n});\nif($result)\n{\n    // 加锁并执行成功\n}\nelse\n{\n    // 加锁失败\n}获取 Handler 对象：$lock = Lock::getInstance($lockId);\n$lock-&gt;lock(); // 使用方法参考下面的“实例化使用方法”注解使用@Lockable无需在配置中预定义支持参数：/**\n * 锁ID\n * 支持{id}、{data.name}形式，代入参数\n * 如果为null，则使用类名+方法名+全部参数，序列化后hash\n *\n * @var string|null\n */\npublic $id;\n\n/**\n * 锁类型，如：RedisLock\n * 为null则使用默认锁类型（@currentServer.lock.defaultType）\n *\n * @var string|null\n */\npublic $type;\n\n/**\n * 等待锁超时时间，单位：毫秒，0为不限制\n * \n * @var int\n */\npublic $waitTimeout = 3000;\n\n/**\n * 锁超时时间，单位：毫秒\n * \n * @var int\n */\npublic $lockExpire = 3000;\n\n/**\n * 锁初始化参数\n *\n * @var array\n */\npublic $options = [];\n\n/**\n * 当获得锁后执行的回调。该回调返回非 null 则不执行加锁后的方法，本回调的返回值将作为返回值\n * 一般用于防止缓存击穿，获得锁后再做一次检测\n * 如果为{&quot;$this&quot;, &quot;methodName&quot;}格式，$this将会被替换为当前类，方法必须为 public 或 protected\n * \n * @var callable\n */\npublic $afterLock;\n\n/**\n * 允许注解引用配置文件中相同锁id的配置\n * 当该选项为真且声明`LockId`情况下，将尝试从配置文件加载相同`id`的配置，但仍然以注解定义的值为首选值。\n * \n * @var bool\n */\npublic $useConfig = true;\n\n/**\n * 执行超时抛出异常。\n * \n * @var bool\n */\npublic $timeoutException = false;\n\n/**\n * 解锁失败抛出异常。\n * \n * @var bool\n */\npublic $unlockException = false;用法示例最简单的锁：只指定id，其它全部默认值@Lockable(id=&quot;锁ID&quot;)定义执行任务前的操作：class Test\n{\n    /**\n     * @Lockable(id=&quot;锁ID&quot;, afterLock={&quot;$this&quot;, &quot;check&quot;})\n     */\n    public function index()\n    {\n        return 1;\n    }\n\n    protected function check()\n    {\n        return 2;\n    }\n\n    /**\n     * @Lockable(id=&quot;锁ID&quot;, afterLock={&quot;$this&quot;, &quot;check2&quot;})\n     */\n    public function index2()\n    {\n        return 3;\n    }\n\n    protected function check2()\n    {\n        \n    }\n}\n\n$result = App::getBean(&#039;Test&#039;)-&gt;index();\necho $result, PHP_EOL; // 2\n\n$result = App::getBean(&#039;Test&#039;)-&gt;index2();\necho $result, PHP_EOL; // 3实例化使用方法无需在配置中预定义顺序用法$redisLock = new \\Imi\\Lock\\Handler\\Redis(&#039;锁ID&#039;, [\n    &#039;poolName&#039;  =&gt; &#039;redis&#039;, // Redis 连接池名称，默认取redis.default配置\n    &#039;db&#039;        =&gt;  null, // Redis 几号库，为null或不配置则使用连接池中的设置\n    &#039;waitSleepTime&#039; =&gt;  20, // 获得锁每次尝试间隔，单位：毫秒\n    &#039;keyPrefix&#039; =&gt;  &#039;imi:lock:&#039;, // Redis key 前置\n]);\n\nif($redisLock-&gt;lock())\n{\n    // 加锁后的处理\n\n    // 解锁\n    $redisLock-&gt;unlock();\n}\nelse\n{\n    // 加锁失败的处理\n}回调用法$redisLock = new \\Imi\\Lock\\Handler\\Redis(&#039;锁ID&#039;, [\n    &#039;poolName&#039;  =&gt; &#039;redis&#039;, // Redis 连接池名称，默认取redis.default配置\n    &#039;db&#039;        =&gt;  null, // Redis 几号库，为null或不配置则使用连接池中的设置\n    &#039;waitSleepTime&#039; =&gt;  20, // 获得锁每次尝试间隔，单位：毫秒\n    &#039;keyPrefix&#039; =&gt;  &#039;imi:lock:&#039;, // Redis key 前置\n]);\n\n// 执行后自动解锁\n$result = $redisLock-&gt;lock(function(){\n    // 执行任务\n}, function(){\n    // return 非null则不执行任务\n    // 一般用于防止缓存击穿\n});\n\nif($result)\n{\n    // 加锁并执行成功\n}\nelse\n{\n    // 加锁失败\n}"},{"id":174,"title":"RedisLock","pageTitle":"RedisLock","url":"components/lock/redis.html","content":"RedisLock目录RedisLock 是支持分布式的锁。使用前需要配置 Redis 进程池。类：Imi\\Lock\\Handler\\RedisBean 名：RedisLock可配置参数/**\n * 锁的唯一 ID\n *\n * @var string\n */\nprotected $id;\n\n/**\n * 等待锁超时时间，单位：毫秒，0为不限制\n * \n * @var int\n */\nprotected $waitTimeout = 3000;\n\n/**\n * 锁超时时间，单位：毫秒\n * \n * @var int\n */\nprotected $lockExpire = 3000;\n\n/**\n * Redis 连接池名称\n *\n * @var string\n */\npublic $poolName;\n\n/**\n * Redis 几号库\n *\n * @var integer\n */\npublic $db = 0;\n\n/**\n * 获得锁每次尝试间隔，单位：毫秒\n * \n * @var int\n */\npublic $waitSleepTime = 20;\n\n/**\n * Redis key\n *\n * @var string\n */\npublic $key;\n\n/**\n * Redis key 前置\n *\n * @var string\n */\npublic $keyPrefix = &#039;imi:lock:&#039;;\n\n/**\n * 执行超时抛出异常\n *\n * @var bool\n */\npublic $timeoutException = false;\n\n/**\n * 解锁失败抛出异常\n *\n * @var bool\n */\npublic $unlockException = false;\n配置示例// 锁\n&#039;lock&#039;  =&gt;[\n    &#039;list&#039;  =&gt;  [\n        &#039;redis&#039; =&gt;  [\n            &#039;class&#039; =&gt;  &#039;RedisLock&#039;,\n            &#039;options&#039;   =&gt;  [\n                &#039;poolName&#039;  =&gt;  &#039;redis_test&#039;,\n            ],\n        ],\n    ],\n],"},{"id":168,"title":"日志","pageTitle":"日志","url":"components/log/index.html","content":"日志目录imi 中的缓存，符合PSR-3规范。使用时需要先配置驱动和实例。允许有多个同类型处理器实例，每个实例单独设置要处理的日志等级，非常灵活。imi v2.x 开始采用了 monolog 作为日志组件，废弃了 v1 中的配置方式，改用全新的配置方式，请知悉！配置// 日志配置\n&#039;logger&#039; =&gt; [\n    // &#039;default&#039; =&gt; &#039;imi&#039;, // 默认 channel\n    &#039;async&#039; =&gt; false, // 是否启用异步日志，仅 Swoole 模式有效，可以有效提升大量日志记录时的接口响应速度\n    &#039;asyncQueueLength&#039; =&gt; 1024, // 异步日志队列长度\n    &#039;channels&#039; =&gt; [\n        &#039;imi&#039; =&gt; [\n            &#039;handlers&#039; =&gt; [\n                // 命令行配置，仅 Swoole、Workerman 推荐\n                [\n                    &#039;class&#039;     =&gt; \\Imi\\Log\\Handler\\ConsoleHandler::class,\n                    // &#039;env&#039; =&gt; [&#039;swoole&#039;], // 允许的运行环境，只有是数组内的运行环境才有效，默认为 null 则不限制\n                    // 日志 Handler 构造方法参数，具体参数详见该类构造方法\n                    &#039;construct&#039; =&gt; [\n                        &#039;level&#039;  =&gt; \\Imi\\Log\\MonoLogger::DEBUG, // 开发调试环境\n                        // &#039;level&#039;  =&gt; \\Imi\\Log\\MonoLogger::INFO,  // 生产环境\n                        &#039;bubble&#039; =&gt; true,\n                    ],\n                    &#039;formatter&#039; =&gt; [\n                        &#039;class&#039;     =&gt; \\Imi\\Log\\Formatter\\ConsoleLineFormatter::class,\n                        &#039;construct&#039; =&gt; [\n                            &#039;format&#039;                     =&gt; null,\n                            &#039;dateFormat&#039;                 =&gt; &#039;Y-m-d H:i:s&#039;,\n                            &#039;allowInlineLineBreaks&#039;      =&gt; true,\n                            &#039;ignoreEmptyContextAndExtra&#039; =&gt; true,\n                        ],\n                    ],\n                ],\n                // 文件日志配置\n                [\n                    // 日志 Handler 类名\n                    &#039;class&#039;     =&gt; \\Monolog\\Handler\\RotatingFileHandler::class,\n                    // 日志 Handler 构造方法参数，具体参数详见该类构造方法\n                    &#039;construct&#039; =&gt; [\n                        &#039;filename&#039; =&gt; dirname(__DIR__) . &#039;/logs/log.log&#039;,\n                        &#039;level&#039;  =&gt; \\Imi\\Log\\MonoLogger::DEBUG, // 开发调试环境\n                        // &#039;level&#039;  =&gt; \\Imi\\Log\\MonoLogger::INFO,  // 生产环境\n                        &#039;bubble&#039;   =&gt; true,\n                    ],\n                    // Formatter\n                    &#039;formatter&#039; =&gt; [\n                        // Formatter 类名\n                        &#039;class&#039;     =&gt; \\Monolog\\Formatter\\LineFormatter::class,\n                        // Formatter 构造方法参数\n                        &#039;construct&#039; =&gt; [\n                            &#039;dateFormat&#039;                 =&gt; &#039;Y-m-d H:i:s&#039;,\n                            &#039;allowInlineLineBreaks&#039;      =&gt; true,\n                            &#039;ignoreEmptyContextAndExtra&#039; =&gt; true,\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    &#039;logger&#039; =&gt; &#039;设置 Logger 类，需继承 \\Imi\\Log\\MonoLogger，一般无需设置&#039;,\n],结合上面的配置示例，可以支持所有 Monolog 的 Handler 和 Formatter，你也可以编写自定义的类。使用use Imi\\Log\\Log;\nuse Imi\\Log\\LogLevel;\n\nLog::log(LogLevel::INFO, &#039;日志内容&#039;);\n// 第三个参数可选传入数据，也可代入上面的变量\nLog::log(LogLevel::INFO, &#039;日志内容&#039;, []);\n\n// 第三个参数可选传入数据，也可代入上面的变量\nLog::emergency(&#039;日志内容&#039;, []);\n\nLog::alert(&#039;日志内容&#039;);\nLog::critical(&#039;日志内容&#039;);\nLog::error(&#039;日志内容&#039;);\nLog::warning(&#039;日志内容&#039;);\nLog::notice(&#039;日志内容&#039;);\nLog::info(&#039;日志内容&#039;);\nLog::debug(&#039;日志内容&#039;);直接记录异常日志：try {\n    throw new \\RuntimeException(&#039;test&#039;);\n} catch(\\Throwable $th) {\n    \\Imi\\Log\\Log::error($th);\n}"},{"id":185,"title":"宏定义","pageTitle":"宏定义","url":"components/macro.html","content":"宏定义目录支持在 imi 框架中使用宏定义。支持在 PHP 代码中使用类似 C/C++ 中的宏，进行代码预编译。可以方便兼容不同版本和环境下运行的 PHP 代码。在一些场景可以通过预定义常量，来提升性能，减少运行时判断。本组件基于 Yurunsoft/php-macro 组件，该组件由宇润主导开发。这是 imi v2.1.0 引入的实验性新特性Composer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-macro&quot;: &quot;~2.1.0&quot;\n    }\n}支持的宏文件格式支持的文件名：*.php、*.macro.php:需要在文件中任意位置顶格加入代码：# macro该代码不加不生效A.php 执行时，会在相同目录生成处理后的 A.php.macro.php。.macro:需要创建同名的 .php 文件，如 A.php，内容为空即可。再创建 A.macro 编写 PHP 代码。执行时，会在相同目录生成处理后的 A.macro.php。常量宏：#define、#const、#ifdef、#ifndef例子：#ifndef IN_SWOOLE\n    # define IN_SWOOLE extension_loaded(&#039;swoole&#039;)\n#endif\n#ifdef IN_SWOOLE\n#if IN_SWOOLE\n\\Co\\run(function(){\n    echo &#039;hello world&#039;;\n});\n#endif\n#endif注意：使用宏定义的常量，仅在生成代码时有效，运行时无效条件语句宏：#if、#else、#elif、#endif例子：&lt;?php\n#if version_compare(\\PHP_VERSION, &#039;8.0&#039;, &#039;&gt;=&#039;)\nfunction test(): string|false\n#else\n/**\n * @return string|false\n */\nfunction test()\n#endif\n{\n    return &#039;hello world&#039;;\n}PHP &gt;= 8.0 环境下生成的代码：&lt;?php\nfunction test(): string|false\n{\n    return &#039;hello world&#039;;\n}PHP &lt; 8.0 环境下生成的代码：&lt;?php\n/**\n * @return string|false\n */\nfunction test()\n{\n    return &#039;hello world&#039;;\n}"},{"id":219,"title":"服务指标监控","pageTitle":"服务指标监控","url":"components/meter/index.html","content":"服务指标监控目录在微服务中，我们需要监控一些数据指标，来保证系统的正常运行和告警。imi 接入了服务指标监控能力，提供了 imi-meter 组件作为抽象。一般都会结合 Grafana 实现图形化。支持的中间件： Prometheus InfluxDB TDengine……"},{"id":221,"title":"InfluxDB","pageTitle":"InfluxDB","url":"components/meter/influxdb.html","content":"InfluxDB目录InfluxDB 是一个开源的时间序列数据库，没有外部依赖性。它对记录指标、事件和执行分析很有用。项目地址：https://github.com/influxdata/influxdbimi-influxdb：https://github.com/imiphp/imi-influxdb目前 imi 仅支持 InfluxDB &lt; 1.8说明imi 支持将服务指标监控的数据写入 InfluxDB。安装composer require imiphp/imi-influxdb:~2.1.0使用说明imi-influxdb 基础配置和使用说明详见：https://doc.imiphp.com/v2.1/components/influxdb.html服务指标监控仅支持 Swoole、Workerman。支持 TDengine InfluxDB 协议写入。安装所需组件composer require imiphp/imi-meter:~2.1.0配置配置监控指标：@app.beans：[\n    &#039;MeterRegistry&#039; =&gt; [\n        &#039;driver&#039;  =&gt; \\Imi\\InfluxDB\\Meter\\InfluxDBMeterRegistry::class,\n        &#039;options&#039; =&gt; [\n            &#039;database&#039;   =&gt; null, // 使用的数据库名，可以设为null使用连接中配置的数据库名\n            &#039;clientName&#039; =&gt; null, // 连接客户端名称，可以设为null使用默认客户端名称\n            &#039;batch&#039;      =&gt; 1000, // 单次推送的记录数量\n            &#039;interval&#039;   =&gt; 0, // 推送时间周期，单位：秒，默认为0不启用推送，如希望监控生效，请设置一个合理的数值。\n            // 所有标签如设为空字符串或 null 则忽略该标签\n            &#039;resultTag&#039; =&gt; &#039;result&#039;, // 标签名-结果\n            &#039;exceptionTag&#039; =&gt; &#039;exception&#039;, // 标签名-异常类名\n            &#039;instanceTag&#039; =&gt; &#039;instance&#039;, // 标签名-实例\n            &#039;workerTag&#039; =&gt; &#039;worker&#039;, // 标签名-WorkerId\n            &#039;instance&#039; =&gt; &#039;imi&#039;, // 当前实例名称，每个实例要设置不同\n        ],\n    ],\n]TDengine InfluxDB 所需修改的配置：// 连接配置一定要设置这几项\n[\n    &#039;port&#039;              =&gt; 6041,\n    &#039;path&#039;              =&gt; &#039;/influxdb/v1/&#039;,\n    &#039;createDatabase&#039;    =&gt; false,\n    &#039;username&#039;          =&gt; &#039;root&#039;,\n    &#039;password&#039;          =&gt; &#039;taosdata&#039;,\n]使用内置监控连接池监控@app.beans：// 连接池监控\n&#039;PoolMonitor&#039; =&gt; [\n    &#039;enable&#039;         =&gt; true, // 启用\n    // &#039;pools&#039;       =&gt; null, // 监控的连接池名称数组。如果为 null 则代表监控所有连接池\n    // &#039;interval&#039;    =&gt; 10, // 上报时间间隔，单位：秒\n    // &#039;countKey&#039;    =&gt; &#039;pool_count&#039;, // 连接总数量键名\n    // &#039;usedKey&#039;     =&gt; &#039;pool_used&#039;, // 忙碌连接数量键名\n    // &#039;freeKey&#039;     =&gt; &#039;pool_free&#039;, // 空间连接数量键名\n    // &#039;workerIdTag&#039; =&gt; &#039;worker_id&#039;, // 工作进程 ID 标签名\n    // &#039;poolNameTag&#039; =&gt; &#039;pool_name&#039;, // 连接池标签名\n],Swoole 服务器指标监控@app.beans：// Swoole 服务器指标监控\n&#039;SwooleServerMonitor&#039; =&gt; [\n    &#039;enable&#039;         =&gt; true, // 启用\n    // 要监控的指标名称数组\n    // 详见：https://wiki.swoole.com/#/server/methods?id=stats\n    // 格式1：stats() 指标名称 =&gt; 实际指标名称\n    // 格式2：stats() 指标名称同时作为实际指标名称\n    &#039;stats&#039;          =&gt; [\n        &#039;connection_num&#039; =&gt; &#039;swoole_connection&#039;,\n        &#039;request_count&#039;  =&gt; &#039;swoole_request_count&#039;,\n        &#039;coroutine_num&#039;  =&gt; &#039;swoole_coroutine_num&#039;,\n        &#039;coroutine_num&#039;,\n    ],\n    // &#039;interval&#039;    =&gt; 10, // 上报时间间隔，单位：秒\n    // &#039;workerIdTag&#039; =&gt; &#039;worker_id&#039;, // 工作进程 ID 标签名\n],注解@Counted类名：\\Imi\\Meter\\Annotation\\Counted计数统计，适合只累加，不减少的统计数据类型。例如：访问次数统计。参数名类型默认值描述namestringimi.counted指标名称recordFailuresOnlyfalsebool是否只在抛出异常时记录tagsarray[]标签，键值数组descriptionstring 描述optionsarray[]额外参数，每个驱动不同@Gauged类名：\\Imi\\Meter\\Annotation\\Gauged适合数字有上下波动的统计。例如：CPU 占用率统计。参数名类型默认值描述namestringimi.counted指标名称recordFailuresOnlyfalsebool是否只在抛出异常时记录tagsarray[]标签，键值数组descriptionstring 描述valuestring/float{returnValue}写入的值；{returnValue} 表示方法返回值；{returnValue.xxx} 表示方法返回值的属性值；{params.0} 表示方法参数值；{params.0.xxx} 表示方法参数值的属性值；也可以是固定的 float 值operationint\\Imi\\Meter\\Enum\\GaugeOperation::SET操作类型。设置GaugeOperation::SET；增加GaugeOperation::INCREMENT；减少GaugeOperation::DECREMENToptionsarray[]额外参数，每个驱动不同@Timed类名：\\Imi\\Meter\\Annotation\\Timed耗时统计。例如：方法执行耗时参数名类型默认值描述namestringimi.counted指标名称tagsarray[]标签，键值数组descriptionstring 描述baseTimeUnitint\\Imi\\Meter\\Enum\\TimeUnit::NANO_SECOND基础时间单位，默认纳秒，可以使用 \\Imi\\Meter\\Enum\\TimeUnit::XXX 常量设置。optionsarray[]额外参数，每个驱动不同@Histogram类名：\\Imi\\Meter\\Annotation\\Histogram柱状图，一般人用不懂，如无特殊需求可以无视。参数名类型默认值描述namestringimi.counted指标名称tagsarray[]标签，键值数组descriptionstring 描述bucketsarray[]桶，例如：[100, 500, 1000]baseTimeUnitint\\Imi\\Meter\\Enum\\TimeUnit::NANO_SECOND基础时间单位，默认纳秒，可以使用 \\Imi\\Meter\\Enum\\TimeUnit::XXX 常量设置。valuestring/float{returnValue}写入的值；{returnValue} 表示方法返回值；{returnValue.xxx} 表示方法返回值的属性值；{params.0} 表示方法参数值；{params.0.xxx} 表示方法参数值的属性值；也可以是固定的 float 值optionsarray[]额外参数，每个驱动不同@Summary类名：\\Imi\\Meter\\Annotation\\Summary采样点分位图，一般人用不懂，如无特殊需求可以无视。参数名类型默认值描述namestringimi.counted指标名称tagsarray[]标签，键值数组descriptionstring 描述percentilearray[]百分位数，例如：[0.01, 0.5, 0.99]baseTimeUnitint\\Imi\\Meter\\Enum\\TimeUnit::NANO_SECOND基础时间单位，默认纳秒，可以使用 \\Imi\\Meter\\Enum\\TimeUnit::XXX 常量设置。valuestring/float{returnValue}写入的值；{returnValue} 表示方法返回值；{returnValue.xxx} 表示方法返回值的属性值；{params.0} 表示方法参数值；{params.0.xxx} 表示方法参数值的属性值；也可以是固定的 float 值optionsarray[]额外参数，每个驱动不同代码示例：use Imi\\Meter\\Annotation\\Gauged;\nuse Imi\\Meter\\Annotation\\Histogram;\nuse Imi\\Meter\\Annotation\\Summary;\nuse Imi\\Meter\\Annotation\\Timed;\nuse Imi\\Meter\\Enum\\TimeUnit;\n\n/**\n * @Gauged(name=&quot;test_memory_usage&quot;, description=&quot;memory usage&quot;, tags={&quot;workerId&quot;=&quot;{returnValue.workerId}&quot;}, value=&quot;{returnValue.memory}&quot;)\n */\npublic function recordMemoryUsage(): array\n{\n    return [\n        &#039;workerId&#039; =&gt; Worker::getWorkerId(),\n        &#039;memory&#039;   =&gt; memory_get_usage(),\n    ];\n}\n\n/**\n * @Timed(name=&quot;test_timed&quot;, description=&quot;memory usage&quot;, baseTimeUnit=TimeUnit::MILLI_SECONDS)\n */\npublic function testTimed(): int\n{\n    $ms = mt_rand(10, 1000);\n    usleep($ms * 1000);\n\n    return $ms;\n}\n\n/**\n * @Timed(name=&quot;test_timed_histogram&quot;, description=&quot;memory usage&quot;, baseTimeUnit=TimeUnit::MILLI_SECONDS, options={&quot;histogram&quot;=true})\n */\npublic function testTimedHistogram(): int\n{\n    $ms = mt_rand(10, 1000);\n    usleep($ms * 1000);\n\n    return $ms;\n}\n\n/**\n * @Histogram(name=&quot;test_histogram&quot;, baseTimeUnit=TimeUnit::MILLI_SECONDS)\n */\npublic function testHistogram(): int\n{\n    return mt_rand(10, 1000);\n}\n\n/**\n * @Summary(name=&quot;test_summary&quot;, baseTimeUnit=TimeUnit::MILLI_SECONDS)\n */\npublic function testSummary(): int\n{\n    return mt_rand(10, 1000);\n}手动操作use \\Imi\\Meter\\Facade\\MeterRegistry;\nuse \\Imi\\Meter\\Enum\\TimeUnit;\n\n$description = &#039;我是描述&#039;;\n$tags = [&#039;result&#039; =&gt; &#039;success&#039;];\n\n// counter\nMeterRegistry::getDriverInstance()-&gt;counter(&#039;testCounterManual&#039;, $tags, $description)-&gt;increment();\n\n// gauge\nMeterRegistry::getDriverInstance()-&gt;gauge(&#039;testGaugeManual&#039;, $tags, $description)-&gt;record(114514);\n\n// timer\n$timer = MeterRegistry::getDriverInstance()-&gt;timer(&#039;testTimedManual&#039;, $tags, $description, TimeUnit::MILLI_SECONDS);\n$timerSample = $timer-&gt;start();\nusleep(mt_rand(10, 1000) * 1000);\n$timerSample-&gt;stop($timer);\n\n// timer Histogram\n$timer = MeterRegistry::getDriverInstance()-&gt;timer(&#039;testTimedHistogramManual&#039;, $tags, $description, TimeUnit::MILLI_SECONDS, [\n    &#039;histogram&#039; =&gt; true,\n]);\n$timerSample = $timer-&gt;start();\nusleep(mt_rand(10, 1000) * 1000); // 你的耗时代码\n$timerSample-&gt;stop($timer);\n\n// Histogram\n$value = 114514;\nMeterRegistry::getDriverInstance()-&gt;histogram(&#039;testHistogramManual&#039;, $tags, $description)-&gt;record($value);\n\n// Summary\n$value = 114514;\nMeterRegistry::getDriverInstance()-&gt;summary(&#039;testHistogramManual&#039;, $tags, $description)-&gt;record($value);"},{"id":220,"title":"Prometheus","pageTitle":"Prometheus","url":"components/meter/prometheus.html","content":"Prometheus目录Prometheus 是云原生计算基金会的一个项目，是一个系统和服务监控系统。它以给定的时间间隔从配置的目标收集指标，评估规则表达式，显示结果，并能在观察到指定条件时触发警报。普罗米修斯区别于其他指标和监控系统的特点是。多维数据模型（时间序列由指标名称和一组键/值维度定义）PromQL，一种强大而灵活的查询语言，以利用这种维度不依赖分布式存储；单个服务器节点是自主的用于收集时间序列的HTTP拉动模型通过中间网关支持批量作业的时间序列推送通过服务发现或静态配置来发现目标支持多种模式的图形和仪表盘制作支持分层和水平联合项目地址：https://github.com/prometheus/prometheusimi-prometheus：https://github.com/imiphp/imi-prometheus安装composer require imiphp/imi-prometheus:~2.1.0使用说明普罗米修斯组件只支持以实例为单位上报，不支持以 Worker 进程为单位。配置首先需要配置 Redis 连接，可以参考文档，这里不再赘述。配置监控指标：@app.beans：[\n    &#039;MeterRegistry&#039; =&gt; [\n        &#039;driver&#039;  =&gt; \\Imi\\Prometheus\\PrometheusMeterRegistry::class,\n        &#039;options&#039; =&gt; [\n            &#039;adapter&#039; =&gt; [\n                &#039;class&#039;   =&gt; \\Imi\\Prometheus\\Storage\\Redis::class,\n                &#039;options&#039; =&gt; [\n                    // &#039;poolName&#039; =&gt; null, // 连接池名称，如果为 null 则使用默认 Redis 连接池\n                    // &#039;prefix&#039; =&gt; &#039;PROMETHEUS_&#039;, // 键名前缀\n                ],\n            ],\n            // 所有标签如设为空字符串或 null 则忽略该标签\n            &#039;resultTag&#039; =&gt; &#039;result&#039;, // 标签名-结果\n            &#039;exceptionTag&#039; =&gt; &#039;exception&#039;, // 标签名-异常类名\n            &#039;instanceTag&#039; =&gt; &#039;instance&#039;, // 标签名-实例\n            &#039;workerTag&#039; =&gt; &#039;worker&#039;, // 标签名-WorkerId\n            &#039;instance&#039; =&gt; &#039;imi&#039;, // 当前实例名称，每个实例要设置不同\n        ],\n    ],\n]使用内置监控连接池监控@app.beans：// 连接池监控\n&#039;PoolMonitor&#039; =&gt; [\n    &#039;enable&#039;         =&gt; true, // 启用\n    // &#039;pools&#039;       =&gt; null, // 监控的连接池名称数组。如果为 null 则代表监控所有连接池\n    // &#039;interval&#039;    =&gt; 10, // 上报时间间隔，单位：秒\n    // &#039;countKey&#039;    =&gt; &#039;pool_count&#039;, // 连接总数量键名\n    // &#039;usedKey&#039;     =&gt; &#039;pool_used&#039;, // 忙碌连接数量键名\n    // &#039;freeKey&#039;     =&gt; &#039;pool_free&#039;, // 空间连接数量键名\n    // &#039;workerIdTag&#039; =&gt; &#039;worker_id&#039;, // 工作进程 ID 标签名\n    // &#039;poolNameTag&#039; =&gt; &#039;pool_name&#039;, // 连接池标签名\n],Swoole 服务器指标监控@app.beans：// Swoole 服务器指标监控\n&#039;SwooleServerMonitor&#039; =&gt; [\n    &#039;enable&#039;         =&gt; true, // 启用\n    // 要监控的指标名称数组\n    // 详见：https://wiki.swoole.com/#/server/methods?id=stats\n    // 格式1：stats() 指标名称 =&gt; 实际指标名称\n    // 格式2：stats() 指标名称同时作为实际指标名称\n    &#039;stats&#039;          =&gt; [\n        &#039;connection_num&#039; =&gt; &#039;swoole_connection&#039;,\n        &#039;request_count&#039;  =&gt; &#039;swoole_request_count&#039;,\n        &#039;coroutine_num&#039;  =&gt; &#039;swoole_coroutine_num&#039;,\n        &#039;coroutine_num&#039;,\n    ],\n    // &#039;interval&#039;    =&gt; 10, // 上报时间间隔，单位：秒\n    // &#039;workerIdTag&#039; =&gt; &#039;worker_id&#039;, // 工作进程 ID 标签名\n],注解@Counted类名：\\Imi\\Meter\\Annotation\\Counted计数统计，适合只累加，不减少的统计数据类型。例如：访问次数统计。参数名类型默认值描述namestringimi.counted指标名称recordFailuresOnlyfalsebool是否只在抛出异常时记录tagsarray[]标签，键值数组descriptionstring 描述optionsarray[]额外参数，每个驱动不同@Gauged类名：\\Imi\\Meter\\Annotation\\Gauged适合数字有上下波动的统计。例如：CPU 占用率统计。参数名类型默认值描述namestringimi.counted指标名称recordFailuresOnlyfalsebool是否只在抛出异常时记录tagsarray[]标签，键值数组descriptionstring 描述valuestring/float{returnValue}写入的值；{returnValue} 表示方法返回值；{returnValue.xxx} 表示方法返回值的属性值；{params.0} 表示方法参数值；{params.0.xxx} 表示方法参数值的属性值；也可以是固定的 float 值operationint\\Imi\\Meter\\Enum\\GaugeOperation::SET操作类型。设置GaugeOperation::SET；增加GaugeOperation::INCREMENT；减少GaugeOperation::DECREMENToptionsarray[]额外参数，每个驱动不同@Timed类名：\\Imi\\Meter\\Annotation\\Timed耗时统计。例如：方法执行耗时参数名类型默认值描述namestringimi.counted指标名称tagsarray[]标签，键值数组descriptionstring 描述baseTimeUnitint\\Imi\\Meter\\Enum\\TimeUnit::NANO_SECOND基础时间单位，默认纳秒，可以使用 \\Imi\\Meter\\Enum\\TimeUnit::XXX 常量设置。optionsarray[]额外参数，每个驱动不同options 在普罗米修斯的特定配置：[\n    &#039;histogram&#039; =&gt; true, // 设置为柱状图，否则默认为 Summary\n    &#039;buckets&#039; =&gt; [], // 桶，仅柱状图\n    &#039;maxAgeSeconds&#039; =&gt; 600, // Summary 最大生存时间\n    &#039;percentile&#039; =&gt; [], // Summary 百分位\n]@Histogram类名：\\Imi\\Meter\\Annotation\\Histogram柱状图，一般人用不懂，如无特殊需求可以无视。参数名类型默认值描述namestringimi.counted指标名称tagsarray[]标签，键值数组descriptionstring 描述bucketsarray[]桶，例如：[100, 500, 1000]baseTimeUnitint\\Imi\\Meter\\Enum\\TimeUnit::NANO_SECOND基础时间单位，默认纳秒，可以使用 \\Imi\\Meter\\Enum\\TimeUnit::XXX 常量设置。valuestring/float{returnValue}写入的值；{returnValue} 表示方法返回值；{returnValue.xxx} 表示方法返回值的属性值；{params.0} 表示方法参数值；{params.0.xxx} 表示方法参数值的属性值；也可以是固定的 float 值optionsarray[]额外参数，每个驱动不同@Summary类名：\\Imi\\Meter\\Annotation\\Summary采样点分位图，一般人用不懂，如无特殊需求可以无视。参数名类型默认值描述namestringimi.counted指标名称tagsarray[]标签，键值数组descriptionstring 描述percentilearray[]百分位数，例如：[0.01, 0.5, 0.99]baseTimeUnitint\\Imi\\Meter\\Enum\\TimeUnit::NANO_SECOND基础时间单位，默认纳秒，可以使用 \\Imi\\Meter\\Enum\\TimeUnit::XXX 常量设置。valuestring/float{returnValue}写入的值；{returnValue} 表示方法返回值；{returnValue.xxx} 表示方法返回值的属性值；{params.0} 表示方法参数值；{params.0.xxx} 表示方法参数值的属性值；也可以是固定的 float 值optionsarray[]额外参数，每个驱动不同代码示例：use Imi\\Meter\\Annotation\\Gauged;\nuse Imi\\Meter\\Annotation\\Histogram;\nuse Imi\\Meter\\Annotation\\Summary;\nuse Imi\\Meter\\Annotation\\Timed;\nuse Imi\\Meter\\Enum\\TimeUnit;\n\n/**\n * @Gauged(name=&quot;test_memory_usage&quot;, description=&quot;memory usage&quot;, tags={&quot;workerId&quot;=&quot;{returnValue.workerId}&quot;}, value=&quot;{returnValue.memory}&quot;)\n */\npublic function recordMemoryUsage(): array\n{\n    return [\n        &#039;workerId&#039; =&gt; Worker::getWorkerId(),\n        &#039;memory&#039;   =&gt; memory_get_usage(),\n    ];\n}\n\n/**\n * @Timed(name=&quot;test_timed&quot;, description=&quot;memory usage&quot;, baseTimeUnit=TimeUnit::MILLI_SECONDS, options={&quot;quantiles&quot;={0.1, 0.5, 0.99}})\n */\npublic function testTimed(): int\n{\n    $ms = mt_rand(10, 1000);\n    usleep($ms * 1000);\n\n    return $ms;\n}\n\n/**\n * @Timed(name=&quot;test_timed_histogram&quot;, description=&quot;memory usage&quot;, baseTimeUnit=TimeUnit::MILLI_SECONDS, options={&quot;histogram&quot;=true, &quot;buckets&quot;={50, 100, 300, 600, 800, 1000}})\n */\npublic function testTimedHistogram(): int\n{\n    $ms = mt_rand(10, 1000);\n    usleep($ms * 1000);\n\n    return $ms;\n}\n\n/**\n * @Histogram(name=&quot;test_histogram&quot;, baseTimeUnit=TimeUnit::MILLI_SECONDS, buckets={50, 100, 300, 600, 800, 1000})\n */\npublic function testHistogram(): int\n{\n    return mt_rand(10, 1000);\n}\n\n/**\n * @Summary(name=&quot;test_summary&quot;, baseTimeUnit=TimeUnit::MILLI_SECONDS, percentile={0.1, 0.5, 0.99})\n */\npublic function testSummary(): int\n{\n    return mt_rand(10, 1000);\n}手动操作use \\Imi\\Meter\\Facade\\MeterRegistry;\nuse \\Imi\\Meter\\Enum\\TimeUnit;\n\n\n$description = &#039;我是描述&#039;;\n$tags = [&#039;result&#039; =&gt; &#039;success&#039;];\n\n// counter\nMeterRegistry::getDriverInstance()-&gt;counter(&#039;testCounterManual&#039;, $tags, $description)-&gt;increment();\n\n// gauge\nMeterRegistry::getDriverInstance()-&gt;gauge(&#039;testGaugeManual&#039;, $tags, $description)-&gt;record(114514);\n\n// timer\n$timer = MeterRegistry::getDriverInstance()-&gt;timer(&#039;testTimedManual&#039;, $tags, $description, TimeUnit::MILLI_SECONDS);\n$timerSample = $timer-&gt;start();\nusleep(mt_rand(10, 1000) * 1000);\n$timerSample-&gt;stop($timer);\n\n// timer Histogram\n$timer = MeterRegistry::getDriverInstance()-&gt;timer(&#039;testTimedHistogramManual&#039;, $tags, $description, TimeUnit::MILLI_SECONDS, [\n    &#039;histogram&#039; =&gt; true,\n    &#039;buckets&#039;   =&gt; [100, 500, 1500],\n]);\n$timerSample = $timer-&gt;start();\nusleep(mt_rand(10, 1000) * 1000); // 你的耗时代码\n$timerSample-&gt;stop($timer);\n\n// Histogram\n$value = 114514;\n$buckets = [100, 500, 1500];\nMeterRegistry::getDriverInstance()-&gt;histogram(&#039;testHistogramManual&#039;, $tags, $description, $buckets)-&gt;record($value);\n\n// Summary\n$value = 114514;\n$percentile = [0.1, 0.5, 0.99];\nMeterRegistry::getDriverInstance()-&gt;summary(&#039;testHistogramManual&#039;, $tags, $description, $percentile)-&gt;record($value);清除 Redis 驱动存储数据如果你的同名指标，修改了 tags，那么必须清理存储数据，否则会报错。vendor/bin/imi-swoole prometheus/wipe"},{"id":222,"title":"TDengine","pageTitle":"TDengine","url":"components/meter/tdengine.html","content":"TDengine目录TDengine 是一款开源、高性能、云原生的时序数据库，且针对物联网、车联网、工业互联网、金融、IT 运维等场景进行了优化。TDengine 的代码，包括集群功能，都在 GNU AGPL v3.0 下开源。除核心的时序数据库功能外，TDengine 还提供缓存、数据订阅、流式计算等其它功能以降低系统复杂度及研发和运维成本。项目地址：https://github.com/taosdata/TDengine说明imi 支持将服务指标监控的数据写入 TDengine。支持的协议： TDengine Schemaless（开发中） InfluxDB 兼容接口更多写入协议支持开发中……使用InfluxDB 兼容接口这个写入方式主要依赖 imi-influxdb，文档请移步：https://doc.imiphp.com/v2.1/components/meter/influxdb.html在 InfluxDB 配置基础上，只需要做如下修改，即可兼容 TDengine：// 连接配置一定要设置这几项\n[\n    &#039;port&#039;              =&gt; 6041,\n    &#039;path&#039;              =&gt; &#039;/influxdb/v1/&#039;,\n    &#039;createDatabase&#039;    =&gt; false,\n    &#039;username&#039;          =&gt; &#039;root&#039;,\n    &#039;password&#039;          =&gt; &#039;taosdata&#039;,\n]"},{"id":208,"title":"AMQP","pageTitle":"AMQP","url":"components/mq/amqp.html","content":"AMQP目录介绍支持在 imi 框架中使用 支持 AMQP 协议的消息队列，如：RabbitMQ支持消息发布和消费Github: https://github.com/imiphp/imi-amqpComposer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-amqp&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用说明可以参考 example 目录示例，包括完整的消息发布和消费功能。在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入组件\n        &#039;AMQP&#039;   =&gt;  &#039;Imi\\AMQP&#039;,\n    ],\n]连接池配置：（Swoole）[\n    &#039;pools&#039;    =&gt;    [\n        &#039;rabbit&#039;    =&gt;  [\n            &#039;pool&#039;    =&gt;    [\n                &#039;class&#039;        =&gt;    \\Imi\\AMQP\\Pool\\AMQPCoroutinePool::class,\n                &#039;config&#039;    =&gt;    [\n                    &#039;maxResources&#039;      =&gt; 10,\n                    &#039;minResources&#039;      =&gt; 1,\n                    &#039;heartbeatInterval&#039; =&gt; 30, // 连接池心跳时间，推荐设置\n                ],\n            ],\n            &#039;resource&#039;    =&gt;    [\n                &#039;host&#039;            =&gt; &#039;127.0.0.1&#039;,\n                &#039;port&#039;            =&gt; 5672,\n                &#039;user&#039;            =&gt; &#039;guest&#039;,\n                &#039;password&#039;        =&gt; &#039;guest&#039;,\n                &#039;keepalive&#039;       =&gt; false, // 截止 Swoole 4.8 还有兼容问题，所以必须设为 false，不影响使用\n                &#039;connectionClass&#039; =&gt; \\PhpAmqpLib\\Connection\\AMQPStreamConnection::class,\n            ]\n        ],\n    ]\n]连接配置：（Workerman）&#039;amqp&#039; =&gt; [\n    &#039;connections&#039; =&gt; [\n        &#039;rabbit&#039;    =&gt; [\n            &#039;host&#039;      =&gt; &#039;127.0.0.1&#039;,\n            &#039;port&#039;      =&gt; 5672,\n            &#039;user&#039;      =&gt; &#039;guest&#039;,\n            &#039;password&#039;  =&gt; &#039;guest&#039;,\n        ],\n    ],\n],默认连接池：[\n    &#039;beans&#039; =&gt;  [\n        &#039;AMQP&#039;  =&gt;  [\n            &#039;defaultPoolName&#039;   =&gt;  &#039;rabbit&#039;,\n        ],\n    ],\n]队列组件支持本组件额外实现了 imiphp/imi-queue 的接口，可以用 Queue 组件的 API 进行调用。只需要将队列驱动配置为：KafkaQueueDriver配置示例：[\n    &#039;beans&#039; =&gt;  [\n        &#039;AutoRunProcessManager&#039; =&gt;  [\n            &#039;processes&#039; =&gt;  [\n                // 加入队列消费进程，非必须，你也可以自己写进程消费\n                &#039;QueueConsumer&#039;,\n            ],\n        ],\n        &#039;imiQueue&#039;  =&gt; [\n            // 默认队列\n            &#039;default&#039;   =&gt; &#039;QueueTest1&#039;,\n            // 队列列表\n            &#039;list&#039;  =&gt; [\n                // 队列名称\n                &#039;QueueTest1&#039; =&gt; [\n                    // 使用的队列驱动\n                    &#039;driver&#039;        =&gt; &#039;AMQPQueueDriver&#039;,\n                    // 消费协程数量\n                    &#039;co&#039;            =&gt; 1,\n                    // 消费进程数量；可能会受进程分组影响，以同一组中配置的最多进程数量为准\n                    &#039;process&#039;       =&gt; 1,\n                    // 消费循环尝试 pop 的时间间隔，单位：秒（仅使用消费者类时有效）\n                    &#039;timespan&#039;      =&gt; 0.1,\n                    // 进程分组名称\n                    &#039;processGroup&#039;  =&gt; &#039;a&#039;,\n                    // 自动消费\n                    &#039;autoConsumer&#039;  =&gt; true,\n                    // 消费者类\n                    &#039;consumer&#039;      =&gt; &#039;TestConsumer&#039;,\n                    // 驱动类所需要的参数数组\n                    &#039;config&#039;        =&gt; [\n                        // AMQP 连接池名称\n                        &#039;poolName&#039;      =&gt; &#039;rabbit&#039;,\n                        // Redis 连接池名称\n                        &#039;redisPoolName&#039; =&gt; &#039;redis&#039;,\n                        // Redis 键名前缀\n                        &#039;redisPrefix&#039;   =&gt; &#039;QueueTest1:&#039;,\n                        // 可选配置：\n                        // 支持消息删除功能，依赖 Redis\n                        &#039;supportDelete&#039; =&gt; true,\n                        // 支持消费超时队列功能，依赖 Redis，并且自动增加一个队列\n                        &#039;supportTimeout&#039; =&gt; true,\n                        // 支持消费失败队列功能，自动增加一个队列\n                        &#039;supportFail&#039; =&gt; true,\n                        // 循环尝试 pop 的时间间隔，单位：秒\n                        &#039;timespan&#039;  =&gt; 0.03,\n                        // 本地缓存的队列长度。由于 AMQP 不支持主动pop，而是主动推送，所以本地会有缓存队列，这个队列不宜过大。\n                        &#039;queueLength&#039;   =&gt; 16,\n                        // 消息类名\n                        &#039;message&#039;   =&gt; \\Imi\\AMQP\\Queue\\JsonAMQPMessage::class,\n                    ],\n                ],\n            ],\n        ],\n    ]\n]消费者类写法，与imi-queue组件用法一致。AMQP 消费发布这个写法仅 AMQP 有效，其它消息队列不能这么写。优点是可以完美利用 AMQP 特性，适合需要个性化定制的用户。连接配置项属性名称说明host主机port端口user用户名vhostvhost，默认/insistinsistloginMethod默认AMQPLAINloginResponseloginResponselocale默认en_USconnectionTimeout连接超时readWriteTimeout读写超时keepalivekeepalive，默认falseheartbeat心跳时间。如果不设置的情况，设置了连接池的心跳，就会设置为该值的 2 倍，否则设为0channelRpcTimeout频道 RPC 超时时间，默认0.0sslProtocolssl 协议，默认null消息定义继承 Imi\\AMQP\\Message 类，可在构造方法中对属性修改。根据需要可以覆盖实现setBodyData、getBodyData方法，实现自定义的消息结构。&lt;?php\nnamespace ImiApp\\AMQP\\Test2;\n\nuse Imi\\AMQP\\Message;\n\nclass TestMessage2 extends Message\n{\n    /**\n     * 用户ID\n     *\n     * @var int\n     */\n    private $memberId;\n\n    /**\n     * 内容\n     *\n     * @var string\n     */\n    private $content;\n\n    public function __construct()\n    {\n        parent::__construct();\n        $this-&gt;routingKey = &#039;imi-2&#039;;\n        $this-&gt;format = \\Imi\\Util\\Format\\Json::class;\n    }\n\n    /**\n     * 设置主体数据\n     *\n     * @param mixed $data\n     * @return self\n     */\n    public function setBodyData($data)\n    {\n        foreach($data as $k =&gt; $v)\n        {\n            $this-&gt;$k = $v;\n        }\n    }\n\n    /**\n     * 获取主体数据\n     *\n     * @return mixed\n     */\n    public function getBodyData()\n    {\n        return [\n            &#039;memberId&#039;  =&gt;  $this-&gt;memberId,\n            &#039;content&#039;   =&gt;  $this-&gt;content,\n        ];\n    }\n\n    /**\n     * Get 用户ID\n     *\n     * @return int\n     */ \n    public function getMemberId()\n    {\n        return $this-&gt;memberId;\n    }\n\n    /**\n     * Set 用户ID\n     *\n     * @param int $memberId  用户ID\n     *\n     * @return self\n     */ \n    public function setMemberId(int $memberId)\n    {\n        $this-&gt;memberId = $memberId;\n\n        return $this;\n    }\n\n    /**\n     * Get 内容\n     *\n     * @return string\n     */ \n    public function getContent()\n    {\n        return $this-&gt;content;\n    }\n\n    /**\n     * Set 内容\n     *\n     * @param string $content  内容\n     *\n     * @return self\n     */ \n    public function setContent(string $content)\n    {\n        $this-&gt;content = $content;\n\n        return $this;\n    }\n\n}属性列表：名称说明默认值bodyData消息主体内容，非字符串null properties属性[&#039;content_type&#039;  =&gt; &#039;text/plain&#039;, &#039;delivery_mode&#039; =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT,] routingKey路由键空字符串 format如果设置了，发布的消息是编码后的bodyData，同理读取时也会解码。实现了Imi\\Util\\Format\\IFormat的格式化类。支持Json、PhpSerializenull mandatorymandatory标志位false immediateimmediate标志位false ticketticketnull 发布者定义必选注解：@Publisher可选注解：@Queue、@Exchange、@Connection不配置 @Connection 注解，可以从连接池中获取连接&lt;?php\nnamespace ImiApp\\AMQP\\Test;\n\nuse Imi\\Bean\\Annotation\\Bean;\nuse Imi\\AMQP\\Annotation\\Queue;\nuse Imi\\AMQP\\Base\\BasePublisher;\nuse Imi\\AMQP\\Annotation\\Consumer;\nuse Imi\\AMQP\\Annotation\\Exchange;\nuse Imi\\AMQP\\Annotation\\Publisher;\nuse Imi\\AMQP\\Annotation\\Connection;\n\n/**\n * @Bean(&quot;TestPublisher&quot;)\n * @Connection(host=&quot;127.0.0.1&quot;, port=5672, user=&quot;guest&quot;, password=&quot;guest&quot;)\n * @Publisher(tag=&quot;tag-imi&quot;, queue=&quot;queue-imi-1&quot;, exchange=&quot;exchange-imi&quot;, routingKey=&quot;imi-1&quot;)\n * @Queue(name=&quot;queue-imi-1&quot;, routingKey=&quot;imi-1&quot;)\n * @Exchange(name=&quot;exchange-imi&quot;)\n */\nclass TestPublisher extends BasePublisher\n{\n\n}发布消息// 实例化构建消息\n$message = new \\ImiApp\\AMQP\\Test2\\TestMessage2;\n$message-&gt;setMemberId(1);\n$message-&gt;setContent(&#039;imi niubi&#039;);\n\n// 发布消息\n/** @var \\ImiApp\\AMQP\\Test\\TestPublisher $testPublisher */\n$testPublisher = \\Imi\\RequestContext::getBean(&#039;TestPublisher&#039;);\n// 请勿使用 App::getBean()、@Inject 等全局单例注入\n// $testPublisher = App::getBean(&#039;TestPublisher&#039;);\n$testPublisher-&gt;publish($message);消费者定义必选注解：@Consumer可选注解：@Queue、@Exchange、@Connection不配置 @Connection 注解，可以从连接池中获取连接&lt;?php\nnamespace ImiApp\\AMQP\\Test;\n\nuse Imi\\Redis\\Redis;\nuse Imi\\Bean\\Annotation\\Bean;\nuse Imi\\AMQP\\Annotation\\Queue;\nuse Imi\\AMQP\\Base\\BaseConsumer;\nuse Imi\\AMQP\\Contract\\IMessage;\nuse Imi\\AMQP\\Annotation\\Consumer;\nuse Imi\\AMQP\\Annotation\\Exchange;\nuse Imi\\AMQP\\Enum\\ConsumerResult;\nuse Imi\\AMQP\\Annotation\\Connection;\n\n/**\n * 启动一个新连接消费\n * \n * @Bean(&quot;TestConsumer&quot;)\n * @Connection(host=&quot;127.0.0.1&quot;, port=5672, user=&quot;guest&quot;, password=&quot;guest&quot;)\n * @Consumer(tag=&quot;tag-imi&quot;, queue=&quot;queue-imi-1&quot;, message=\\ImiApp\\AMQP\\Test\\TestMessage::class)\n */\nclass TestConsumer extends BaseConsumer\n{\n    /**\n     * 消费任务\n     *\n     * @param \\ImiApp\\AMQP\\Test\\TestMessage $message\n     */\n    protected function consume(IMessage $message): int\n    {\n        var_dump(__CLASS__, $message-&gt;getBody(), get_class($message));\n        Redis::set(&#039;imi-amqp:consume:1:&#039; . $message-&gt;getMemberId(), $message-&gt;getBody());\n        return ConsumerResult::ACK;\n    }\n\n}\n消费消息随服务启动的消费进程只会启动一个进程，适合量少的场景。适合IO密集型场景。首先定义进程：&lt;?php\nnamespace ImiApp\\Process;\n\nuse Imi\\Swoole\\Process\\BaseProcess;\nuse Imi\\Aop\\Annotation\\Inject;\nuse Imi\\Swoole\\Process\\Annotation\\Process;\n\n/**\n * @Process(name=&quot;TestProcess&quot;)\n */\nclass TestProcess extends BaseProcess\n{\n    /**\n     * @Inject(&quot;TestConsumer&quot;)\n     *\n     * @var \\ImiApp\\AMQP\\Test\\TestConsumer\n     */\n    protected $testConsumer;\n\n    /**\n     * @Inject(&quot;TestConsumer2&quot;)\n     *\n     * @var \\ImiApp\\AMQP\\Test2\\TestConsumer2\n     */\n    protected $testConsumer2;\n\n    public function run(\\Swoole\\Process $process): void\n    {\n        // 启动消费者\n        go(function(){\n            do {\n                $this-&gt;testConsumer-&gt;run();\n            } while(true);\n        });\n        go(function(){\n            do {\n                $this-&gt;testConsumer2-&gt;run();\n            } while(true);\n        });\n    }\n\n}然后在项目配置@app.beans中配置消费进程[\n    &#039;AutoRunProcessManager&#039; =&gt;  [\n        &#039;processes&#039; =&gt;  [\n            &#039;TestProcess&#039;\n        ],\n    ],\n]启动进程池消费适合计算密集型场景、消费量非常多的场景。进程池写法参考：https://doc.imiphp.com/v2.1/components/process-pool/swoole.html启动消费者写法参考上面的即可。注解说明@Publisher发布者注解属性名称说明queue队列名称exchange交换机名称routingKey路由键@Consumer消费者注解属性名称说明tag消费者标签queue队列名称exchange交换机名称routingKey路由键message消息类名，默认：Imi\\AMQP\\Messagemandatorymandatory标志位immediateimmediate标志位ticketticket@Queue队列注解属性名称说明name队列名称routingKey路由键passive被动模式，默认falsedurable消息队列持久化，默认trueexclusive独占，默认falseautoDelete自动删除，默认falsenowait是否非阻塞，默认falsearguments参数ticketticket@Exchange交换机注解属性名称说明name交换机名称type类型可选：direct、fanout、topic、headerspassive被动模式，默认falsedurable消息队列持久化，默认trueautoDelete自动删除，默认falseinternal设置是否为rabbitmq内部使用, true表示是内部使用, false表示不是内部使用nowait是否非阻塞，默认falsearguments参数ticketticket@Connection连接注解属性名称说明poolName不为 null 时，无视其他属性，直接用该连接池配置。默认为null，如果host、port、user、password都未设置，则获取默认的连接池。host主机port端口user用户名vhostvhost，默认/insistinsistloginMethod默认AMQPLAINloginResponseloginResponselocale默认en_USconnectionTimeout连接超时readWriteTimeout读写超时keepalivekeepalive，默认falseheartbeat心跳时间，默认0channelRpcTimeout频道 RPC 超时时间，默认0.0sslProtocolssl 协议，默认null"},{"id":209,"title":"Kafka","pageTitle":"Kafka","url":"components/mq/kafka.html","content":"Kafka目录介绍支持在 imi 框架中使用 Kafka 客户端支持消息发布和消费本组件基于 龙之言 组织的 longlang/phpkafka 组件，该组件由宇润主导开发。Composer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-kafka&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用说明可以参考 example 目录示例，包括完整的消息发布和消费功能。在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入组件\n        &#039;Kafka&#039;   =&gt;  &#039;Imi\\Kafka&#039;,\n    ],\n]连接池配置：（Swoole）[\n    &#039;pools&#039;    =&gt;    [\n        &#039;kafka&#039;    =&gt; [\n            &#039;pool&#039;    =&gt; [\n                &#039;class&#039;        =&gt; \\Imi\\Kafka\\Pool\\KafkaCoroutinePool::class,\n                &#039;config&#039;       =&gt; [\n                    &#039;maxResources&#039;    =&gt; 10,\n                    &#039;minResources&#039;    =&gt; 1,\n                ],\n            ],\n            &#039;resource&#039;    =&gt; [\n                &#039;bootstrapServers&#039; =&gt; KAFKA_BOOTSTRAP_SERVERS,\n                &#039;groupId&#039;          =&gt; &#039;test&#039;,\n                // 其它配置请参考：https://github.com/longyan/phpkafka/blob/master/doc/consumer.md#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0\n            ],\n        ],\n    ]\n]连接配置：（Workerman）&#039;kafka&#039; =&gt; [\n    &#039;connections&#039; =&gt; [\n        &#039;kafka&#039;    =&gt; [\n            &#039;bootstrapServers&#039; =&gt; KAFKA_BOOTSTRAP_SERVERS,\n            &#039;groupId&#039;          =&gt; &#039;test2&#039;,\n        ],\n    ],\n],默认连接池：[\n    &#039;beans&#039; =&gt;  [\n        &#039;Kafka&#039;  =&gt;  [\n            &#039;defaultPoolName&#039;   =&gt;  &#039;kafka&#039;,\n        ],\n    ],\n]生产者use Imi\\Kafka\\Pool\\KafkaPool;\nuse longlang\\phpkafka\\Producer\\ProduceMessage;\n\n// 获取生产者对象\n$producer = KafkaPool::getInstance();\n\n// 发送\n$producer-&gt;send(&#039;主题 Topic&#039;, &#039;消息内容&#039;);\n// send 方法定义\n// public function send(string $topic, ?string $value, ?string $key = null, array $headers = [], ?int $partitionIndex = null, ?int $brokerId = null): void\n\n// 批量发送\n$producer-&gt;sendBatch([\n    new ProduceMessage($topic, &#039;v1&#039;, &#039;k1&#039;),\n    new ProduceMessage($topic, &#039;v2&#039;, &#039;k2&#039;),\n]);\n// sendBatch 方法定义\n// public function sendBatch(ProduceMessage[] $messages, ?int $brokerId = null): void消费者消费者类：&lt;?php\n\nnamespace ImiApp\\Kafka\\Test;\n\nuse Imi\\Bean\\Annotation\\Bean;\nuse Imi\\Kafka\\Annotation\\Consumer;\nuse Imi\\Kafka\\Base\\BaseConsumer;\nuse Imi\\Redis\\Redis;\nuse longlang\\phpkafka\\Consumer\\ConsumeMessage;\n\n/**\n * @Bean(&quot;TestConsumer&quot;)\n * @Consumer(topic=&quot;queue-imi-1&quot;, groupId=&quot;test-consumer&quot;)\n */\nclass TestConsumer extends BaseConsumer\n{\n    /**\n     * 消费任务\n     */\n    protected function consume(ConsumeMessage $message): void\n    {\n        $messageValue = $message-&gt;getValue();\n    }\n}消费进程：&lt;?php\n\nnamespace ImiApp\\Process;\n\nuse Imi\\Aop\\Annotation\\Inject;\nuse Imi\\App;\nuse Imi\\Kafka\\Contract\\IConsumer;\nuse Imi\\Process\\Annotation\\Process;\nuse Imi\\Process\\BaseProcess;\n\n/**\n * @Process(name=&quot;TestProcess&quot;)\n */\nclass TestProcess extends BaseProcess\n{\n    /**\n     * @Inject(&quot;TestConsumer&quot;)\n     *\n     * @var \\ImiApp\\Kafka\\Test\\TestConsumer\n     */\n    protected $testConsumer;\n\n    public function run(\\Swoole\\Process $process): void\n    {\n        $this-&gt;runConsumer($this-&gt;testConsumer);\n        \\Swoole\\Coroutine::yield();\n    }\n\n    private function runConsumer(IConsumer $consumer): void\n    {\n        go(function () use ($consumer) {\n            try\n            {\n                $consumer-&gt;run();\n            }\n            catch (\\Throwable $th)\n            {\n                \\Imi\\Log\\Log::error($th);\n                sleep(3);\n                $this-&gt;runConsumer($consumer);\n            }\n        });\n    }\n}注解说明@Consumer消费者注解属性名称说明topic主题名称，支持字符串或字符串数组groupId分组IDpoolName连接池名称，不传则使用配置中默认的队列组件支持本组件额外实现了 imiphp/imi-queue 的接口，可以用 Queue 组件的 API 进行调用。只需要将队列驱动配置为：KafkaQueueDriver配置示例：[\n    &#039;components&#039;    =&gt;  [\n        &#039;Kafka&#039;  =&gt;  &#039;Imi\\Kafka&#039;,\n    ],\n    &#039;beans&#039; =&gt;  [\n        &#039;AutoRunProcessManager&#039; =&gt;  [\n            &#039;processes&#039; =&gt;  [\n                // 加入队列消费进程，非必须，你也可以自己写进程消费\n                &#039;QueueConsumer&#039;,\n            ],\n        ],\n        &#039;imiQueue&#039;  =&gt; [\n            // 默认队列\n            &#039;default&#039;   =&gt; &#039;QueueTest1&#039;,\n            // 队列列表\n            &#039;list&#039;  =&gt; [\n                // 队列名称\n                &#039;QueueTest1&#039; =&gt; [\n                    // 使用的队列驱动\n                    &#039;driver&#039;        =&gt; &#039;KafkaQueueDriver&#039;,\n                    // 消费协程数量\n                    &#039;co&#039;            =&gt; 1,\n                    // 消费进程数量；可能会受进程分组影响，以同一组中配置的最多进程数量为准\n                    &#039;process&#039;       =&gt; 1,\n                    // 消费循环尝试 pop 的时间间隔，单位：秒（仅使用消费者类时有效）\n                    &#039;timespan&#039;      =&gt; 0.1,\n                    // 进程分组名称\n                    &#039;processGroup&#039;  =&gt; &#039;a&#039;,\n                    // 自动消费\n                    &#039;autoConsumer&#039;  =&gt; true,\n                    // 消费者类\n                    &#039;consumer&#039;      =&gt; &#039;QueueTestConsumer&#039;,\n                    // 驱动类所需要的参数数组\n                    &#039;config&#039;        =&gt; [\n                        // Kafka 连接池名称\n                        &#039;poolName&#039; =&gt; &#039;kafka&#039;,\n                        // 分组ID，如果不传或为null则使用连接池中的配置\n                        &#039;groupId&#039;  =&gt; &#039;g1&#039;,\n                    ],\n                ],\n            ],\n        ],\n    ]\n]消费者类写法，与imi-queue组件用法一致。"},{"id":206,"title":"Redis 消息队列","pageTitle":"Redis 消息队列","url":"components/mq/redis.html","content":"Redis 消息队列目录介绍imi 框架的队列组件，使用 Redis 作为持久化支持的特性：消息持久化分布式延时消息ACK 机制消费超时机制失败/超时消息重新消费项目地址：https://github.com/imiphp/imi-queueComposer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-queue&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用说明阿里云集群用户，请把 script_check_enable 设置改为 0可以参考 example、tests 目录示例。项目配置文件：[\n    &#039;components&#039;    =&gt;  [\n        &#039;Queue&#039;  =&gt;  &#039;Imi\\Queue&#039;,\n    ],\n    &#039;beans&#039; =&gt;  [\n        &#039;AutoRunProcessManager&#039; =&gt;  [\n            &#039;processes&#039; =&gt;  [\n                // 加入队列消费进程，非必须，你也可以自己写进程消费\n                &#039;QueueConsumer&#039;,\n            ],\n        ],\n        &#039;imiQueue&#039;  =&gt;  [\n            // 默认队列\n            &#039;default&#039;   =&gt;  &#039;test1&#039;,\n            // 队列列表\n            &#039;list&#039;  =&gt;  [\n                // 队列名称\n                &#039;test1&#039; =&gt;  [\n                    // 使用的队列驱动\n                    &#039;driver&#039;        =&gt;  \\Imi\\Queue\\Driver\\RedisQueueDriver::class,\n                    // 消费协程数量\n                    &#039;co&#039;            =&gt;  1,\n                    // 消费进程数量；可能会受进程分组影响，以同一组中配置的最多进程数量为准\n                    &#039;process&#039;       =&gt;  1,\n                    // 消费循环尝试 pop 的时间间隔，单位：秒\n                    &#039;timespan&#039;      =&gt;  0.1,\n                    // 进程分组名称\n                    &#039;processGroup&#039;  =&gt;  &#039;a&#039;,\n                    // 自动消费\n                    &#039;autoConsumer&#039;  =&gt;  true,\n                    // 消费者类\n                    &#039;consumer&#039;      =&gt;  &#039;AConsumer&#039;,\n                    // 驱动类所需要的参数数组\n                    &#039;config&#039;        =&gt;  [\n                        &#039;poolName&#039;  =&gt;  &#039;redis&#039;,\n                        &#039;prefix&#039;    =&gt;  &#039;imi:queue:test:&#039;,\n                    ]\n                ],\n            ],\n        ],\n    ]\n]消费者类&lt;?php\nnamespace ImiApp\\Consumer;\n\nuse Imi\\Log\\Log;\nuse Imi\\Bean\\Annotation\\Bean;\nuse Imi\\Queue\\Contract\\IMessage;\nuse Imi\\Queue\\Driver\\IQueueDriver;\nuse Imi\\Queue\\Service\\BaseQueueConsumer;\n\n/**\n * @Bean(&quot;AConsumer&quot;)\n */\nclass AConsumer extends BaseQueueConsumer\n{\n    /**\n     * 处理消费\n     * \n     * @param \\Imi\\Queue\\Contract\\IMessage $message\n     * @param \\Imi\\Queue\\Driver\\IQueueDriver $queue\n     */\n    protected function consume(IMessage $message, IQueueDriver $queue): void\n    {\n        Log::info(sprintf(&#039;[%s]%s:%s&#039;, $queue-&gt;getName(), $message-&gt;getMessageId(), $message-&gt;getMessage()));\n        $queue-&gt;success($message);\n    }\n\n}获取队列对象use \\Imi\\Queue\\Facade\\Queue;\n$queue = Queue::getQueue(&#039;队列名称&#039;);推送消息到队列返回消息ID$message = new \\Imi\\Queue\\Model\\Message;\n$message-&gt;setMessage(&#039;字符串的消息内容&#039;);\n$message-&gt;setWorkingTimeout(0); // 设置工作超时时间，单位：秒，为0不限制\n$queue-&gt;push($message);\n// 延时消息，单位：秒\n$queue-&gt;push($message, 1.5);从队列弹出一个消息$message = $queue-&gt;pop();\nif(null !== $message)\n{\n    // 将消息标记为成功\n    $queue-&gt;success($message);\n\n    // 将消息标记为失败\n    $queue-&gt;fail($message);\n}删除消息$message = $queue-&gt;pop();\nif(null !== $message)\n{\n    $queue-&gt;delete($message);\n}清空队列use \\Imi\\Queue\\Enum\\QueueType;\n\n$queue-&gt;clear(); // 清空全部\n\n// 清空指定类型\n$queue-&gt;clear([\n    QueueType::READY,   // 准备就绪\n    QueueType::WORKING, // 工作中\n    QueueType::FAIL,    // 失败\n    QueueType::TIMEOUT, // 超时\n    QueueType::DELAY,   // 准备就绪延时\n]);获取队列状态// 返回 \\Imi\\Queue\\Model\\QueueStatus 类型\n$status = $queue-&gt;status();\n$status-&gt;getReady();    // 准备就绪数量\n$status-&gt;getWorking();  // 工作中数量\n$status-&gt;getFail();     // 失败数量\n$status-&gt;getTimeout();  // 超时数量\n$status-&gt;getDelay();    // 延时数量将失败消息恢复到队列让失败消息可以被重新消费$queue-&gt;restoreFailMessages();将超时消息恢复到队列让超时消息可以被重新消费$queue-&gt;restoreTimeoutMessages();命令行工具命令-获取队列状态命令：bin/imi-xxx queue/status 队列名称 (xxx 根据运行模式不同而不同)返回 JSON：{\n    &quot;ready&quot;: 0,\n    &quot;working&quot;: 0,\n    &quot;fail&quot;: 0,\n    &quot;timeout&quot;: 0,\n    &quot;delay&quot;: 0\n}命令-将失败消息恢复到队列命令：bin/imi-xxx queue/restoreFail 队列名称 (xxx 根据运行模式不同而不同)返回恢复的消息数量：0命令-将超时消息恢复到队列命令：bin/imi-xxx queue/restoreTimeout 队列名称 (xxx 根据运行模式不同而不同)返回恢复的消息数量：0"},{"id":207,"title":"Redis Stream 消息队列","pageTitle":"Redis Stream 消息队列","url":"components/mq/redisStream.html","content":"Redis Stream 消息队列目录介绍imi 框架的队列组件，使用 Redis 作为持久化支持的特性：消息持久化分布式ACK 机制消费超时机制失败/超时消息重新消费项目地址：https://github.com/imiphp/imi-queueComposer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-queue&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用说明阿里云集群用户，请把 script_check_enable 设置改为 0可以参考 example、tests 目录示例。项目配置文件：[\n    &#039;components&#039;    =&gt;  [\n        &#039;Queue&#039;  =&gt;  &#039;Imi\\Queue&#039;,\n    ],\n    &#039;beans&#039; =&gt;  [\n        &#039;AutoRunProcessManager&#039; =&gt;  [\n            &#039;processes&#039; =&gt;  [\n                // 加入队列消费进程，非必须，你也可以自己写进程消费\n                &#039;QueueConsumer&#039;,\n            ],\n        ],\n        &#039;imiQueue&#039;  =&gt;  [\n            // 默认队列\n            &#039;default&#039;   =&gt;  &#039;test1&#039;,\n            // 队列列表\n            &#039;list&#039;  =&gt;  [\n                // 队列名称\n                &#039;test1&#039; =&gt;  [\n                    // 使用的队列驱动\n                    &#039;driver&#039;        =&gt;  \\Imi\\Queue\\Driver\\RedisStreamQueueDriver::class,\n                    // 消费协程数量\n                    &#039;co&#039;            =&gt;  1,\n                    // 消费进程数量；可能会受进程分组影响，以同一组中配置的最多进程数量为准\n                    &#039;process&#039;       =&gt;  1,\n                    // 消费循环尝试 pop 的时间间隔，单位：秒\n                    &#039;timespan&#039;      =&gt;  0.1,\n                    // 进程分组名称\n                    &#039;processGroup&#039;  =&gt;  &#039;a&#039;,\n                    // 自动消费\n                    &#039;autoConsumer&#039;  =&gt;  true,\n                    // 消费者类\n                    &#039;consumer&#039;      =&gt;  &#039;AConsumer&#039;,\n                    // 驱动类所需要的参数数组\n                    &#039;config&#039;        =&gt;  [\n                        // &#039;poolName&#039;  =&gt;  null, // Redis 连接池名称\n                        // &#039;prefix&#039;    =&gt;  &#039;imi:&#039;, // 键前缀\n                        // &#039;maxLength&#039; =&gt; 0, // 队列最大长度，为0则不限制\n                        // &#039;approximate&#039; =&gt; false, // 队列最大长度近似模式\n                        // &#039;groupId&#039; =&gt; &#039;imiGroup&#039;, // 分组ID\n                        // &#039;queueConsumer&#039; =&gt; &#039;imiQueueConsumer&#039;, // 队列消费者\n                        // &#039;failConsumer&#039; =&gt; &#039;imiFailConsumer&#039;, // 消费失败后消息转移的目标消费者\n                        // &#039;workingTimeout&#039; =&gt; 60, // 工作超时时间\n                    ]\n                ],\n            ],\n        ],\n    ]\n]消费者类&lt;?php\nnamespace ImiApp\\Consumer;\n\nuse Imi\\Log\\Log;\nuse Imi\\Bean\\Annotation\\Bean;\nuse Imi\\Queue\\Contract\\IMessage;\nuse Imi\\Queue\\Driver\\IQueueDriver;\nuse Imi\\Queue\\Service\\BaseQueueConsumer;\n\n/**\n * @Bean(&quot;AConsumer&quot;)\n */\nclass AConsumer extends BaseQueueConsumer\n{\n    /**\n     * 处理消费\n     * \n     * @param \\Imi\\Queue\\Contract\\IMessage $message\n     * @param \\Imi\\Queue\\Driver\\IQueueDriver $queue\n     * @return void\n     */\n    protected function consume(IMessage $message, IQueueDriver $queue): void\n    {\n        Log::info(sprintf(&#039;[%s]%s:%s&#039;, $queue-&gt;getName(), $message-&gt;getMessageId(), $message-&gt;getMessage()));\n        $queue-&gt;success($message);\n    }\n\n}获取队列对象use \\Imi\\Queue\\Facade\\Queue;\n$queue = Queue::getQueue(&#039;队列名称&#039;);推送消息到队列返回消息ID$message = new \\Imi\\Queue\\Model\\Message;\n$message-&gt;setMessage(&#039;字符串的消息内容&#039;);\n$queue-&gt;push($message);从队列弹出一个消息$message = $queue-&gt;pop();\nif(null !== $message)\n{\n    // 将消息标记为成功\n    $queue-&gt;success($message);\n\n    // 将消息标记为失败\n    $queue-&gt;fail($message);\n}删除消息$message = $queue-&gt;pop();\nif(null !== $message)\n{\n    $queue-&gt;delete($message);\n}清空队列use \\Imi\\Queue\\Enum\\QueueType;\n\n$queue-&gt;clear(); // 清空全部\n\n// 清空指定类型\n$queue-&gt;clear([\n    QueueType::READY,   // 准备就绪\n    QueueType::WORKING, // 工作中\n    QueueType::FAIL,    // 失败\n    QueueType::TIMEOUT, // 超时\n    QueueType::DELAY,   // 准备就绪延时\n]);获取队列状态// 返回 \\Imi\\Queue\\Model\\QueueStatus 类型\n$status = $queue-&gt;status();\n$status-&gt;getReady();    // 准备就绪数量（无效）\n$status-&gt;getWorking();  // 工作中数量\n$status-&gt;getFail();     // 失败数量\n$status-&gt;getTimeout();  // 超时数量（无效）\n$status-&gt;getDelay();    // 延时数量（无效）将失败消息恢复到队列让失败消息可以被重新消费$queue-&gt;restoreFailMessages();将超时消息恢复到队列让超时消息可以被重新消费$queue-&gt;restoreTimeoutMessages();命令行工具命令-获取队列状态命令：bin/imi-cli queue/status 队列名称返回 JSON：{\n    &quot;ready&quot;: 0,\n    &quot;working&quot;: 0,\n    &quot;fail&quot;: 0,\n    &quot;timeout&quot;: 0,\n    &quot;delay&quot;: 0\n}命令-将失败消息恢复到队列命令：bin/imi-cli queue/restoreFail 队列名称返回恢复的消息数量：0命令-将超时消息恢复到队列命令：bin/imi-cli queue/restoreTimeout 队列名称返回恢复的消息数量：0"},{"id":116,"title":"MQTT 客户端","pageTitle":"MQTT 客户端","url":"components/mqtt/client.html","content":"MQTT 客户端目录仅支持 Swoole安装：composer require imiphp/imi-mqtt项目配置文件：[\n    &#039;components&#039;    =&gt;  [\n        &#039;MQTT&#039;  =&gt;  &#039;Imi\\MQTT&#039;,\n    ],\n]MQTT 功能要求 PHP &gt;= 7.4使用事件监听类：&lt;?php\nnamespace Imi\\MQTT\\Test;\n\nuse Imi\\MQTT\\Client\\Contract\\IMQTTClientListener;\n\nclass TestClientListener implements IMQTTClientListener\n{\n    /**\n     * 连接确认\n     *\n     * @param \\Imi\\MQTT\\Client\\MQTTClient $client\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\ConnectResponsePacket $packet\n     * @return void\n     */\n    public function connectACK(\\Imi\\MQTT\\Client\\MQTTClient $client, \\BinSoul\\Net\\Mqtt\\Packet\\ConnectResponsePacket $packet)\n    {\n    }\n\n    /**\n     * 发布\n     *\n     * @param \\Imi\\MQTT\\Client\\MQTTClient $client\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\PublishRequestPacket $packet\n     * @return void\n     */\n    public function publish(\\Imi\\MQTT\\Client\\MQTTClient $client, \\BinSoul\\Net\\Mqtt\\Packet\\PublishRequestPacket $packet)\n    {\n    }\n\n    /**\n     * 发布确认\n     *\n     * @param \\Imi\\MQTT\\Client\\MQTTClient $client\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\PublishAckPacket $packet\n     * @return void\n     */\n    public function publishAck(\\Imi\\MQTT\\Client\\MQTTClient $client, \\BinSoul\\Net\\Mqtt\\Packet\\PublishAckPacket $packet)\n    {\n    }\n\n    /**\n     * 发布已收到（保证交付部分1）\n     *\n     * @param \\Imi\\MQTT\\Client\\MQTTClient $client\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\PublishReceivedPacket $packet\n     * @return void\n     */\n    public function publishReceived(\\Imi\\MQTT\\Client\\MQTTClient $client, \\BinSoul\\Net\\Mqtt\\Packet\\PublishReceivedPacket $packet)\n    {\n    }\n\n    /**\n     * 发布释放（确保交付的第2部分）\n     *\n     * @param \\Imi\\MQTT\\Client\\MQTTClient $client\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\PublishReleasePacket $packet\n     * @return void\n     */\n    public function publishRelease(\\Imi\\MQTT\\Client\\MQTTClient $client, \\BinSoul\\Net\\Mqtt\\Packet\\PublishReleasePacket $packet)\n    {\n    }\n\n    /**\n     * 发布完成（保证交付的第3部分）\n     *\n     * @param \\Imi\\MQTT\\Client\\MQTTClient $client\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\PublishCompletePacket $packet\n     * @return void\n     */\n    public function publishComplete(\\Imi\\MQTT\\Client\\MQTTClient $client, \\BinSoul\\Net\\Mqtt\\Packet\\PublishCompletePacket $packet)\n    {\n    }\n\n    /**\n     * 订阅确认\n     *\n     * @param \\Imi\\MQTT\\Client\\MQTTClient $client\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\SubscribeResponsePacket $packet\n     * @return void\n     */\n    public function subscribeACK(\\Imi\\MQTT\\Client\\MQTTClient $client, \\BinSoul\\Net\\Mqtt\\Packet\\SubscribeResponsePacket $packet)\n    {\n    }\n\n    /**\n     * 取消订阅确认\n     *\n     * @param \\Imi\\MQTT\\Client\\MQTTClient $client\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\UnsubscribeResponsePacket $packet\n     * @return void\n     */\n    public function unsubscribeACK(\\Imi\\MQTT\\Client\\MQTTClient $client, \\BinSoul\\Net\\Mqtt\\Packet\\UnsubscribeResponsePacket $packet)\n    {\n    }\n\n    /**\n     * Ping 响应\n     *\n     * @param \\Imi\\MQTT\\Client\\MQTTClient $client\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\PingResponsePacket $packet\n     * @return void\n     */\n    public function ping(\\Imi\\MQTT\\Client\\MQTTClient $client, \\BinSoul\\Net\\Mqtt\\Packet\\PingResponsePacket $packet)\n    {\n    }\n}客户端调用：use Imi\\MQTT\\Client\\MQTTClient;\n$client = new MQTTClient([\n    &#039;host&#039;          =&gt;  &#039;127.0.0.1&#039;,\n    &#039;port&#039;          =&gt;  8081,\n], new TestClientListener);\n$client-&gt;wait(); // 开始循环接收，直到关闭连接客户端参数表：参数名说明host服务器主机名称port服务器端口号timeout网络通讯超时时间pingTimespan定时 ping 的时间间隔，单位秒。默认为 NULL 则不自动 pingprotocol协议级别，默认4。3-MQIsdp;4-MQTTusername用户名password密码clientId客户端IDkeepAlive保活时间clean清除会话will遗嘱消息，具体结构看下面的表格ssl使用 SSL 连接sslCertFile证书文件sslKeyFile证书密钥文件sslVerifyPeer验证服务器端证书sslAllowSelfSigned允许自签名证书sslHostName服务器主机名称sslCafileCA 证书sslCapath证书目录will 遗嘱消息参数表：参数名说明topic主题payload有效载荷qosLevel0-最多一次的传输；1-至少一次的传输；2-只有一次的传输retain保留duplicate重复"},{"id":189,"title":"MQTT 服务端","pageTitle":"MQTT 服务端","url":"components/mqtt/server.html","content":"MQTT 服务端目录MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。仅支持 Swoole安装：composer require imiphp/imi-mqtt示例项目：composer create-project imiphp/project-mqtt:~2.1.0配置首先，服务器配置的type设为MQTT，并且定义好控制器。控制器需要继承Imi\\Server\\MQTT\\BaseMQTTController类，并且实现方法。如果你是主服务器，配置如下：&#039;mainServer&#039;    =&gt;    [\n    &#039;namespace&#039;     =&gt;    &#039;ImiApp\\MQTTServer&#039;,\n    &#039;type&#039;          =&gt;    &#039;MQTTServer&#039;,\n    &#039;host&#039;          =&gt;    &#039;127.0.0.1&#039;,\n    &#039;port&#039;          =&gt;    8081,\n    &#039;controller&#039;    =&gt;  \\ImiApp\\MQTTServer\\Controller\\MQTTController::class,\n    // &#039;configs&#039;       =&gt;    [\n    //     // 启用 MQTTS 配置证书\n    //     &#039;ssl_cert_file&#039;     =&gt;  dirname(__DIR__) . &#039;/ssl/server.crt&#039;,\n    //     &#039;ssl_key_file&#039;      =&gt;  dirname(__DIR__) . &#039;/ssl/server.key&#039;,\n    // ],\n],如果你是子服务器，配置如下下：// 子服务器（端口监听）配置\n&#039;subServers&#039;        =&gt;    [\n    &#039;xxxServer&#039;    =&gt;    [\n        &#039;namespace&#039;     =&gt;    &#039;ImiApp\\MQTTServer&#039;,\n        &#039;type&#039;          =&gt;    &#039;MQTTServer&#039;,\n        &#039;host&#039;          =&gt;    &#039;127.0.0.1&#039;,\n        &#039;port&#039;          =&gt;    8081,\n        &#039;controller&#039;    =&gt;  \\ImiApp\\MQTTServer\\Controller\\MQTTController::class,\n        // &#039;configs&#039;       =&gt;    [\n        //     // 启用 MQTTS 配置证书\n        //     &#039;ssl_cert_file&#039;     =&gt;  dirname(__DIR__) . &#039;/ssl/server.crt&#039;,\n        //     &#039;ssl_key_file&#039;      =&gt;  dirname(__DIR__) . &#039;/ssl/server.key&#039;,\n        // ],\n    ],\n],通讯数据包类imi-mqtt 基于 binsoul/net-mqtt 开发，使用的都是这个包中的数据包结构类。类名一般是BinSoul\\Net\\Mqtt\\Packet\\XXX如：\\BinSoul\\Net\\Mqtt\\Packet\\SubscribeRequestPacket控制器&lt;?php\nnamespace ImiApp\\MQTTServer\\Controller;\n\nuse Imi\\Server\\MQTT\\BaseMQTTController;\nuse Imi\\Server\\MQTT\\Message\\ReceiveData;\nuse BinSoul\\Net\\Mqtt\\Packet\\PublishAckPacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\PingRequestPacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\PingResponsePacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\ConnectRequestPacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\PublishReleasePacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\PublishRequestPacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\ConnectResponsePacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\PublishCompletePacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\PublishReceivedPacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\SubscribeRequestPacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\DisconnectRequestPacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\SubscribeResponsePacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\UnsubscribeRequestPacket;\nuse BinSoul\\Net\\Mqtt\\Packet\\UnsubscribeResponsePacket;\nuse Imi\\Server\\Server;\n\n/**\n * 示例控制器，代码全为示例，请根据实际项目编写\n */\nclass MQTTController extends BaseMQTTController\n{\n    /**\n     * 连接\n     *\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\ConnectRequestPacket $request\n     * @param \\Imi\\Server\\MQTT\\Message\\ReceiveData $receiveData\n     * @return \\BinSoul\\Net\\Mqtt\\Packet\\ConnectResponsePacket|null\n     */\n    public function connect(ConnectRequestPacket $request, ReceiveData $receiveData): ?ConnectResponsePacket\n    {\n        $success = &#039;root&#039; === $request-&gt;getUsername() &amp;&amp; &#039;123456&#039; === $request-&gt;getPassword();\n        $response = new ConnectResponsePacket;\n        if($success)\n        {\n            $response-&gt;setReturnCode(0);\n        }\n        else\n        {\n            $response-&gt;setReturnCode(4);\n        }\n        return $response;\n    }\n\n    /**\n     * 断开连接\n     *\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\DisconnectRequestPacket $request\n     * @param \\Imi\\Server\\MQTT\\Message\\ReceiveData $receiveData\n     * @return void\n     */\n    public function disconnect(DisconnectRequestPacket $request, ReceiveData $receiveData): void\n    {\n        \n    }\n\n    /**\n     * Ping\n     *\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\PingRequestPacket $request\n     * @param \\Imi\\Server\\MQTT\\Message\\ReceiveData $receiveData\n     * @return \\BinSoul\\Net\\Mqtt\\Packet\\PingResponsePacket|null\n     */\n    public function ping(PingRequestPacket $request, ReceiveData $receiveData): ?PingResponsePacket\n    {\n        return new PingResponsePacket;\n    }\n\n    /**\n     * 发布\n     *\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\PublishRequestPacket $request\n     * @param \\Imi\\Server\\MQTT\\Message\\ReceiveData $receiveData\n     * @return \\BinSoul\\Net\\Mqtt\\Packet\\PublishAckPacket|\\BinSoul\\Net\\Mqtt\\Packet\\PublishReceivedPacket|\\BinSoul\\Net\\Mqtt\\Packet\\PublishReleasePacket|\\BinSoul\\Net\\Mqtt\\Packet\\PublishCompletePacket|null\n     */\n    public function publish(PublishRequestPacket $request, ReceiveData $receiveData)\n    {\n        switch($request-&gt;getTopic())\n        {\n            case &#039;a&#039;:\n                $response = new PublishAckPacket;\n                break;\n            case &#039;b&#039;:\n                $response = new PublishReceivedPacket;\n                break;\n            case &#039;c&#039;:\n                $response = new PublishReleasePacket;\n                break;\n            case &#039;d&#039;:\n                $response = new PublishCompletePacket;\n                break;\n            default:\n                throw new \\RuntimeException(&#039;Unknown topic &#039; . $request-&gt;getTopic());\n        }\n        $response-&gt;setIdentifier($request-&gt;getIdentifier());\n        // TODO: 请自行实现推送消息给订阅者\n        return $response;\n    }\n\n    /**\n     * 订阅\n     *\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\SubscribeRequestPacket $request\n     * @param \\Imi\\Server\\MQTT\\Message\\ReceiveData $receiveData\n     * @return \\BinSoul\\Net\\Mqtt\\Packet\\SubscribeResponsePacket|null\n     */\n    public function subscribe(SubscribeRequestPacket $request, ReceiveData $receiveData): ?SubscribeResponsePacket\n    {\n        $response = new SubscribeResponsePacket;\n        $response-&gt;setIdentifier($request-&gt;getIdentifier());\n        $response-&gt;setReturnCodes([0]);\n\n        $publishData = new PublishRequestPacket;\n        $publishData-&gt;setPayload(&#039;test&#039;);\n        $publishData-&gt;setTopic(&#039;a&#039;);\n        Server::send($publishData, $receiveData-&gt;getClientId());\n\n        // TODO: 请自行实现订阅消息\n        return $response;\n    }\n\n    /**\n     * 取消订阅\n     *\n     * @param \\BinSoul\\Net\\Mqtt\\Packet\\UnsubscribeRequestPacket $request\n     * @param \\Imi\\Server\\MQTT\\Message\\ReceiveData $receiveData\n     * @return \\BinSoul\\Net\\Mqtt\\Packet\\UnsubscribeResponsePacket|null\n     */\n    public function unsubscribe(UnsubscribeRequestPacket $request, ReceiveData $receiveData): ?UnsubscribeResponsePacket\n    {\n        $response = new UnsubscribeResponsePacket;\n        $response-&gt;setIdentifier($request-&gt;getIdentifier());\n        // TODO: 请自行实现取消订阅消息\n\n        return $response;\n    }\n\n}"},{"id":138,"title":"模型配置","pageTitle":"模型配置","url":"components/orm/config.html","content":"模型配置目录项目配置文件：[\n    &#039;models&#039; =&gt; [\n        // 模型类型，带命名空间，开头不要有斜杠\n        &#039;Imi\\Pgsql\\Test\\Model\\Article&#039; =&gt; [\n            &#039;name&#039; =&gt; &#039;tb_article&#039;, // 覆盖注解中定义的表名，还支持：数据库名.表名\n            &#039;dbPoolName&#039; =&gt; null, // 覆盖注解中定义的连接池名\n        ],\n    ],\n]覆盖表名、连接池名的特性，请更新到 imi v2.0.10 及更高版本，重新生成模型基类后有效"},{"id":136,"title":"ORM","pageTitle":"ORM","url":"components/orm/index.html","content":"ORM目录介绍imi 中目前支持两个模型：数据库模型、内存表模型数据库模型与传统 php-fpm 框架下使用并无多大差别，甚至更加好用。在 imi 框架中，提供了一个模型生成工具。使用该工具生成的模型，在使用时无需手动定义字段，支持 IDE 代码提示。模型生成命令使用说明：https://doc.imiphp.com/v2.1/dev/generate/model.html模型字段和序列化模型实例对象可以同时作为数组和对象使用。如数据库中字段为user_age，同时支持原字段名和驼峰命名，使用方法如下：// 下面三句是等同的\n$model[&#039;user_age&#039;] = 1;\n$model[&#039;userAge&#039;] = 1;\n$model-&gt;setUserAge(1);调用$model-&gt;toArray()可以转为数组。可以直接对模型进行json_encode()处理。模型序列化后的字段默认为驼峰格式，如：数据库字段为user_age，序列化后为userAge。可以使用注解，设置为使用原数据库字段名：@Entity(camel=false)"},{"id":159,"title":"内存表模型","pageTitle":"内存表模型","url":"components/orm/MemoryTableModel.html","content":"内存表模型目录介绍基于 Swoole Table 跨进程共享内存表的模型。通过注解定义，框架底层自动创建SwooleTable，直接使用模型操作，方便快捷！模型定义喜闻乐见的对命名空间、类名无要求，只要按照规定写注解即可！具体定义看下面代码：namespace Test;\n\nuse Imi\\Swoole\\Model\\MemoryTableModel;\nuse Imi\\Model\\Annotation\\Column;\nuse Imi\\Model\\Annotation\\MemoryTable;\n\n/**\n * @MemoryTable(name=&quot;test&quot;)\n */\nclass MTest extends MemoryTableModel\n{\n    /**\n     * @Column(name=&quot;str&quot;,type=&quot;string&quot;,length=128)\n     * @var string\n     */\n    protected $str;\n\n    /**\n     * @Column(name=&quot;int&quot;,type=&quot;int&quot;)\n     * @var int\n     */\n    protected $int;\n\n    /**\n     * @Column(name=&quot;float&quot;,type=&quot;float&quot;)\n     * @var float\n     */\n    protected $float;\n\n    /**\n     * Get the value of str\n     *\n     * @return  string\n     */\n    public function getStr()\n    {\n        return $this-&gt;str;\n    }\n\n    /**\n     * Set the value of str\n     *\n     * @param  string  $str\n     *\n     * @return  self\n     */\n    public function setStr(string $str)\n    {\n        $this-&gt;str = $str;\n\n        return $this;\n    }\n\n    /**\n     * Get the value of int\n     *\n     * @return  int\n     */\n    public function getInt()\n    {\n        return $this-&gt;int;\n    }\n\n    /**\n     * Set the value of int\n     *\n     * @param  int  $int\n     *\n     * @return  self\n     */\n    public function setInt(int $int)\n    {\n        $this-&gt;int = $int;\n\n        return $this;\n    }\n\n    /**\n     * Get the value of float\n     *\n     * @return  float\n     */\n    public function getFloat()\n    {\n        return $this-&gt;float;\n    }\n\n    /**\n     * Set the value of float\n     *\n     * @param  float  $float\n     *\n     * @return  self\n     */\n    public function setFloat(float $float)\n    {\n        $this-&gt;float = $float;\n\n        return $this;\n    }\n}需要使用注解将表、字段属性全部标注。并且写上get和set方法。@MemoryTable(name=&quot;test&quot;) 是指定SwooleTable的名称@Column(name=&quot;str&quot;,type=&quot;string&quot;,length=128)中的name代表字段名，type支持string/int/float，string类型必须设置length模型操作查找一条记录$key = &#039;abc&#039;;\n$model = MTest::find($key);查询多条记录$list = MTest::select();\n// $list 为 MTest[] 类型保存记录$model = MTest::newInstance();\n$model-&gt;__setKey(&#039;abc&#039;);\n$model-&gt;setStr(&#039;aaa&#039;);\n$model-&gt;setInt(123);\n$model-&gt;setFloat(4.56);\n$model-&gt;save();删除记录$model = MTest::find(&#039;abc&#039;);\n$model-&gt;delete();批量删除// 两种方式\nMTest::deleteBatch(&#039;k1&#039;, &#039;k2&#039;);\nMTest::deleteBatch([&#039;k1&#039;, &#039;k2&#039;]);统计数量MTest::count();获取键$model = MTest::find(&#039;abc&#039;);\n$model-&gt;getKey();设置键$model = MTest::find(&#039;abc&#039;);\n$model-&gt;__setKey(&#039;def&#039;);"},{"id":156,"title":"数据库迁移","pageTitle":"数据库迁移","url":"components/orm/migration.html","content":"数据库迁移长期以来，数据库迁移一直是个麻烦事。当我们部署代码到服务器上时，希望可以轻松简单地升级我们的表结构。可能会有人用 Navicat 的结构同步来升级，这个确实好用，但有商业风险。常见的建表方式有：使用图形化工具建表、使用 PHP 代码定义表结构、手写 SQL 建表等。imi 的数据库迁移依赖模型功能，支持：使用图形化工具、手写 SQL 建表，只要你最终生成了模型，就可以使用数据库迁移功能。当你使用 imi 模型生成工具生成模型时，会把创建表的 SQL 语句定义在 @DDL 注解中。使用数据库迁移工具，可以自动比较模型定义与数据库服务器上的表（视图）结构差异，并且生成升级语句，升级语句不会造成表数据的丢失。正在测试阶段，使用时请先确认 SQL 无误后再执行，本项目不对删库删数据负责。项目地址：https://github.com/imiphp/imi-migration版权信息imi-migration 依赖 phpmyadmin/sql-parser，所以开源协议受到污染，必须是 GPL-2.0，所有基于本项目的代码都要开源。建议仅将此组件作为独立工具安装使用，不要在项目中调用此项目中的任意代码，这样就不受开源协议污染了！常用的 Linux 和 MySQL 都是 GPL 开源协议，只要使用得当是不会有法律风险的。安装composer require imiphp/imi-migration:~2.1.0使用说明同步表结构将数据库中的数据表结构升级为模型中定义的结构。vendor/bin/imi-swoole migration/patch -f生成同步结构 SQL 语句输出到命令行：vendor/bin/imi-swoole migration/patch保存到文件：vendor/bin/imi-swoole migration/patch -f &quot;文件名&quot;通用参数指定连接池vendor/bin/imi-swoole migration/命令 --poolName &quot;连接池名&quot;不指定时使用默认连接池指定连接参数vendor/bin/imi-swoole migration/命令 --driver &quot;PdoMysqlDriver&quot; --options &quot;host=127.0.0.1&amp;port=3306&amp;username=root&amp;password=root&quot;"},{"id":139,"title":"数据库模型","pageTitle":"数据库模型","url":"components/orm/RDModel/definition.html","content":"数据库模型目录介绍传统关系型数据库（MySQL）的模型，日常增删改查完全够用，支持复合主键、联合主键。需要注意的是，imi 的模型与传统 TP 等框架中的模型概念有些差别。imi 的模型类里一般不写逻辑代码，模型类的一个对象就代表一条记录，并且所有字段都需要有值（除非你不定义指定的字段）。模型定义喜闻乐见的对命名空间、类名无要求，只要按照规定写注解即可！@Entity 注解为定义实体类@Table 注解为定义数据表@Column 注解为定义字段@DDL 定义表结构的 SQL 语句建议使用模型生成工具：https://doc.imiphp.com/v2.1/dev/generate/model.html具体定义看下面代码：namespace Test;\n\nuse Imi\\Model\\Model;\nuse Imi\\Model\\Annotation\\Table;\nuse Imi\\Model\\Annotation\\Column;\nuse Imi\\Model\\Annotation\\Entity;\n\n/**\n * 定义为实体\n * @Entity\n * 指定实体为test，复合主键id和a\n * @Table(name=&quot;test&quot;, id={&quot;id&quot;, &quot;a&quot;})\n */\nclass Test extends Model\n{\n    /**\n     * ID\n     * 字段id，类型int，长度10，是主键，第0个主键，是自增字段\n     * @Column(name=&quot;id&quot;, type=&quot;int&quot;, length=10, isPrimaryKey=true, primaryKeyIndex=0, isAutoIncrement=true)\n     * @var int\n     */\n    protected $id;\n\n    /**\n     * aaa\n     * @Column(name=&quot;a&quot;, type=&quot;string&quot;, length=255, isPrimaryKey=true, primaryKeyIndex=1)\n     * @var string\n     */\n    protected $a;\n\n    /**\n     * bbb\n     * @Column(name=&quot;b&quot;, type=&quot;string&quot;, length=255)\n     * @var string\n     */\n    protected $b;\n\n    /**\n     * ccc\n     * @Column(name=&quot;c&quot;, type=&quot;string&quot;, length=255)\n     * @var string\n     */\n    protected $c;\n\n    /**\n     * Get iD\n     *\n     * @return  int\n     */\n    public function getId()\n    {\n        return $this-&gt;id;\n    }\n\n    /**\n     * Set iD\n     *\n     * @param  int  $id  ID\n     *\n     * @return  self\n     */\n    public function setId(int $id)\n    {\n        $this-&gt;id = $id;\n\n        return $this;\n    }\n\n    /**\n     * Get aaa\n     *\n     * @return  string\n     */\n    public function getA()\n    {\n        return $this-&gt;a;\n    }\n\n    /**\n     * Set aaa\n     *\n     * @param  string  $a  aaa\n     *\n     * @return  self\n     */\n    public function setA(string $a)\n    {\n        $this-&gt;a = $a;\n\n        return $this;\n    }\n\n    /**\n     * Get bbb\n     *\n     * @return  string\n     */\n    public function getB()\n    {\n        return $this-&gt;b;\n    }\n\n    /**\n     * Set bbb\n     *\n     * @param  string  $b  bbb\n     *\n     * @return  self\n     */\n    public function setB(string $b)\n    {\n        $this-&gt;b = $b;\n\n        return $this;\n    }\n\n    /**\n     * Get ccc\n     *\n     * @return  string\n     */\n    public function getC()\n    {\n        return $this-&gt;c;\n    }\n\n    /**\n     * Set ccc\n     *\n     * @param  string  $c  ccc\n     *\n     * @return  self\n     */\n    public function setC(string $c)\n    {\n        $this-&gt;c = $c;\n\n        return $this;\n    }\n}需要使用注解将表、字段属性全部标注。并且写上get和set方法，可以使用模型生成工具生成。模型中可以加入虚拟字段，通过注解@Column(virtual=true)，虚拟字段不参与数据库操作。模型注解@Entity写在类上，定义类为实体模型类用法：@Entity序列化时不使用驼峰命名，使用原本的字段名：@Entity(false)将模型设为非 bean 类：@Entity(camel=true, bean=false)非 bean 类性能更好，但无法用 AOP 切入类，事件也不生效，一般模型建议使用非 bean 类模式。启用增量更新：（默认不启用）@Entity(incrUpdate=true)@Table写在类上，定义数据表用法：@Table(&#039;tb_user&#039;)指定数据库连接池：@Table(name=&#039;tb_user&#039;, dbPoolName=&#039;指定数据库连接池名&#039;)指定主键：@Table(name=&#039;tb_user&#039;, id=&#039;id&#039;)指定多个主键@Table(name=&#039;tb_user&#039;, id={&#039;id1&#039;, &#039;id2&#039;})@DDL写在类上，定义表结构用法：/**\n * ArticleBase\n * @Entity\n * @Table(name=&quot;tb_article&quot;, id={&quot;id&quot;})\n * @DDL(&quot;CREATE TABLE `tb_article` (\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `title` varchar(255) NOT NULL,\n  `content` mediumtext NOT NULL,\n  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT&quot;)\n * @property int $id\n * @property string $title\n * @property string $content\n * @property string $time\n */\nabstract class ArticleBase extends Model\n{\n}@JsonEncode设定 JSON 序列化时的配置写在类上可以让模型类中所有 Json 字段生效。写在属性上，可以覆盖写在类上的注解。不使用 Unicode 编码转换中文：@JsonEncode(JSON_UNESCAPED_UNICODE)完整参数：@JsonEncode(flags=4194624, depth=512)4194624 === \\JSON_THROW_ON_ERROR | \\JSON_UNESCAPED_SLASHES | \\JSON_UNESCAPED_UNICODE参数含义同 json_encode()@JsonDecode设定 JSON 反序列化时的配置写在类上可以让模型类中所有 Json 字段生效。写在属性上，可以覆盖写在类上的注解。完整参数：@JsonDecode(associative=true, depth=512, flags=0, wrap=\\Imi\\Util\\LazyArrayObject::class)除 $wrap 外其它参数含义同 json_decode()$wrap 参数说明：$wrap 反序列化数据的包装，如果是对象或者数组时有效。支持类名、函数名。设为空字符串时，反序列化为数组。类名：// 将此类的对象作为属性值\nclass WrapClass\n{\n    /**\n     * @param mixed $data json_decode() 结果\n     */\n    public function __construct($data)\n    {\n    }\n}函数名：/**\n * @param mixed $data json_decode() 结果\n * @return mixed\n */\nfunction demoWrap($data)\n{\n    return $data; // 返回值作为属性值\n}@Column写在属性上，定义字段列@Column(name=&quot;字段名&quot;, type=&quot;字段类型&quot;, length=&quot;长度&quot;, nullable=&quot;是否允许为空true/false&quot;, accuracy=&quot;精度，小数位后几位&quot;, default=&quot;默认值&quot;, isPrimaryKey=&quot;是否为主键true/false&quot;, primaryKeyIndex=&quot;联合主键中的第几个，从0开始&quot;, isAutoIncrement=&quot;是否为自增字段true/false&quot;, virtual=&quot;虚拟字段，不参与数据库操作true/false&quot;, updateTime=true, createTime=true, reference=&quot;引用字段名，作为引用字段的别名使用，拥有同等的读写能力，需要将virtual设为true&quot;, unsigned=false)当你指定type=json时，写入数据库时自动json_encode，从数据实例化到对象时自动json_decode当你指定type=list并且设置了listSeparator分割符时，写入数据库时自动implode，从数据实例化到对象时自动explodeupdateTime：save/update 模型时是否将当前时间写入该字段。支持 date/time/datetime/timestamp/year/int/bigint。设为true时，当字段为 int 类型，写入秒级时间戳。当字段为 bigint 类型，写入毫秒级时间戳。设为int值时，当字段为 bigint 类型，写入值=time() * updateTime。比如传1是存秒级时间戳，传1000是毫秒级时间戳，以此类推。createTime：save/insert 模型时是否将当前时间写入该字段，save时表有自增ID主键才支持；支持 date/time/datetime/timestamp/year/int/bigint；设为true时，当字段为 int 类型，写入秒级时间戳；当字段为 bigint 类型，写入毫秒级时间戳。设为int值时，当字段为 bigint 类型，写入值=time() * updateTime。比如传1是存秒级时间戳，传1000是毫秒级时间戳，以此类推。@Sql为虚拟字段定义 SQL 语句，模型查询时自动带上改字段。imi 的模型思想就是要为查询结果建模，而不是每次查询时候手动指定字段。@Sql(&quot;SQL 语句&quot;)如果 @Column 注解定义了 name 属性，则将 name 作为字段别名；如果未定义，则使用属性名称作为别名。示例：&lt;?php\n\nnamespace Imi\\Test\\Component\\Model;\n\nuse Imi\\Bean\\Annotation\\Inherit;\nuse Imi\\Model\\Annotation\\Column;\nuse Imi\\Model\\Annotation\\Serializables;\nuse Imi\\Model\\Annotation\\Sql;\nuse Imi\\Test\\Component\\Model\\Base\\MemberBase;\n\n/**\n * Member.\n *\n * @Inherit\n * @Serializables(mode=&quot;deny&quot;, fields={&quot;password&quot;})\n */\nclass MemberWithSqlField extends MemberBase\n{\n    /**\n     * @Column(name=&quot;a&quot;, virtual=true)\n     * @Sql(&quot;1+1&quot;)\n     *\n     * @var int\n     */\n    public $test1;\n\n    /**\n     * @Column(virtual=true)\n     * @Sql(&quot;2+2&quot;)\n     *\n     * @var int\n     */\n    public $test2;\n\n    /**\n     * Set the value of test1.\n     *\n     * @param int $test1\n     *\n     * @return self\n     */\n    public function setTest1(int $test1)\n    {\n        $this-&gt;test1 = $test1;\n\n        return $this;\n    }\n\n    /**\n     * Get the value of test1.\n     *\n     * @return int\n     */\n    public function getTest1()\n    {\n        return $this-&gt;test1;\n    }\n\n    /**\n     * Set the value of test2.\n     *\n     * @param int $test2\n     *\n     * @return self\n     */\n    public function setTest2(int $test2)\n    {\n        $this-&gt;test2 = $test2;\n\n        return $this;\n    }\n\n    /**\n     * Get the value of test2.\n     *\n     * @return int\n     */\n    public function getTest2()\n    {\n        return $this-&gt;test2;\n    }\n}查询时的 SQL 语句：select `tb_member`.*,(1+1) as `a`,(2+2) as `test2` from `tb_member` where `id`=:id limit 1@JsonNotNull写在属性上，无参数。当字段值不为 null 时才序列化到 json@Serializable写在属性上，序列化注解用法：禁止参与序列化（toArray()或json_encode()不包含该字段）：@Serializable(false)@Serializables写在类上，批量设置序列化注解，优先级低于针对属性单独设置的@Serializable注解用法：白名单（序列化后只显示id、name字段）：@Serializables(mode=&quot;allow&quot;, fields={&quot;id&quot;, &quot;name&quot;})黑名单（序列化后，排除id、name字段）@Serializables(mode=&quot;deny&quot;, fields={&quot;id&quot;, &quot;name&quot;})@ExtractProperty写在属性上，提取字段中的属性到当前模型用法：提取该属性中的userId值到当前模型中的userId：@ExtractProperty(&quot;userId&quot;)提取该属性中的userId值到当前模型中的userId2：@ExtractProperty(fieldName=&quot;userId&quot;, alias=&quot;userId2&quot;)支持多级提取到当前模型中的userId2：/**\n * @ExtractProperty(fieldName=&quot;ex.userId&quot;, alias=&quot;userId2&quot;)\n */\nprotected $xxx = [\n    &#039;ex&#039;    =&gt;    [\n        &#039;userId&#039;    =&gt;    123,\n    ],\n];@Id写在属性上，声明主键，并且支持 ID 生成器（发号器）功能。用法：声明主键：@Id声明主键，指定顺序：@Id(0)@Id(index=0)ID 生成器：@Id(generator=生成器类::class)ID 生成器指定参数：@Id(generator=生成器类::class, generatorOptions={&quot;key&quot;=&quot;value&quot;})非主键字段使用 ID 生成器：@Id(index=false, generator=生成器类::class)UUID 发号器使用前请先安装 uuid 扩展：http://pecl.php.net/package/uuid或安装这个包：composer require symfony/polyfill-uuid时间算法：@Id(generator=\\Imi\\Model\\IdGenerator\\UUIDGenerator::class)@Id(generator=\\Imi\\Model\\IdGenerator\\UUIDGenerator::class, generatorOptions={&quot;type&quot;=\\Imi\\Model\\IdGenerator\\UUIDGeneratorType::TIME})随机算法：@Id(generator=\\Imi\\Model\\IdGenerator\\UUIDGenerator::class, generatorOptions={&quot;type&quot;=\\Imi\\Model\\IdGenerator\\UUIDGeneratorType::RANDOM})MD5、Sha1：使用方法基本一样，差别就是 generatorOptions.type 值不同。@Id(index=false, generator=\\Imi\\Model\\IdGenerator\\UUIDGenerator::class, generatorOptions={&quot;type&quot;=\\Imi\\Model\\IdGenerator\\UUIDGeneratorType::MD5, &quot;ns&quot;=&quot;99e4edaf-8363-466e-bddf-7254db57675c&quot;, &quot;nameField&quot;=&quot;名称字段名，该字段值必须唯一，否则会重复&quot;})ns 必须是一个合法的 UUID@Id(index=false, generator=\\Imi\\Model\\IdGenerator\\UUIDGenerator::class, generatorOptions={&quot;type&quot;=\\Imi\\Model\\IdGenerator\\UUIDGeneratorType::SHA1, &quot;nsField&quot;=&quot;命名空间字段名&quot;, &quot;name&quot;=&quot;直接指定名称&quot;})注意：ns、name 的值如果一样，生成的 UUID 也会一样！！！雪花算法发号器使用前请先安装 imi-snowflake：composer require imiphp/imi-snowflake@Id(index=false, generator=\\Imi\\Snowflake\\Model\\SnowflakeGenerator::class, generatorOptions={&quot;name&quot;=&quot;雪花算法配置名称&quot;})雪花算法配置请参考：https://doc.imiphp.com/v2.1/components/snowflake.html#%E9%85%8D%E7%BD%AE自定义发号器&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace app\\Model;\n\nuse Imi\\Model\\BaseModel;\nuse Imi\\Model\\IdGenerator\\Contract\\IIdGenerator;\n\nclass MyGenerator implements IIdGenerator\n{\n    /**\n     * @return mixed\n     */\n    public function generate(?BaseModel $model, array $options = [])\n    {\n        // $options是 @Id() 注解中 generatorOptions 参数传入的数组\n\n        // $model 是模型对象，也可能为 null，做好容错，或者直接抛异常也可\n\n        // 返回值可以是任何类型\n        return 0;\n    }\n}"},{"id":143,"title":"模型事件","pageTitle":"模型事件","url":"components/orm/RDModel/event.html","content":"模型事件目录事件监听分两种，一种是仅限于对象的事件，另一种是静态方法触发的事件。监听方式分两种：1、在类里写监听代码；2、定义监听类批量操作的事件监听，一般建议用监听类方式。对象的事件监听根据习惯选择即可。事件列表模型对象事件事件名常量描述BeforeInsertModelEvents::BEFORE_INSERT插入前，insert()/save()触发AfterInsertModelEvents::AFTER_INSERT插入后，insert()/save()触发BeforeUpdateModelEvents::BEFORE_UPDATE更新前，update()/save()触发AfterUpdateModelEvents::AFTER_UPDATE更新后，update()/save()触发BeforeDeleteModelEvents::BEFORE_DELETE删除前，delete()触发AfterDeleteModelEvents::AFTER_DELETE删除后，delete()触发BeforeSaveModelEvents::BEFORE_SAVE保存前，先于插入前和更新前触发AfterSaveModelEvents::AFTER_SAVE保存后，后于插入后和更新后触发AfterQueryModelEvents::AFTER_QUERY只要最终查询出该模型就会触发事件传递过来的参数类型为Imi\\Model\\Event\\Param\\事件名EventParam对象事件监听方法1-监听代码/**\n * Test\n * @Entity\n * @Table(name=&quot;tb_test&quot;, id={&quot;id&quot;, &quot;a&quot;})\n */\nclass Test extends Model\n{\n    public function __init($data = [])\n    {\n        $this-&gt;on(ModelEvents::AFTER_INIT, [$this, &#039;onAfterInit&#039;]);\n        parent::__init($data);\n    }\n\n    public function onAfterInit(\\Imi\\Model\\Event\\Param\\InitEventParam $data)\n    {\n        var_dump($data-&gt;data);\n    }\n}对象事件监听方法2-定义监听类&lt;?php\nnamespace XXX\\ModelEvent\\Logs;\n\nuse Imi\\Bean\\Annotation\\ClassEventListener;\nuse Imi\\Model\\Event\\Param\\BeforeInsertEventParam;\nuse Imi\\Model\\Event\\Listener\\IBeforeInsertEventListener;\n\n/**\n * 插入前处理\n * @ClassEventListener(className=&quot;\\XXX\\Model\\Test&quot;,eventName=\\Imi\\Model\\Event\\ModelEvents::BEFORE_INSERT)\n */\nclass BeforeInsert implements IBeforeInsertEventListener\n{\n    /**\n     * 事件处理方法\n     * @param BeforeInsertEventParam $e\n     * @return void\n     */\n    public function handle(BeforeInsertEventParam $e): void\n    {\n        $e-&gt;data-&gt;data = json_encode($e-&gt;data-&gt;data);\n        $e-&gt;data-&gt;ip = inet_pton($e-&gt;data-&gt;ip);\n    }\n}模型类静态事件事件名常量描述BeforeFindModelEvents::BEFORE_FIND查找前，Model::find()触发AfterFindModelEvents::AFTER_FIND查找后，Model::find()触发BeforeSelectModelEvents::BEFORE_SELECT查询前，Model::select()触发AfterSelectModelEvents::AFTER_SELECT查询后，Model::select()触发BeforeInitModelEvents::BEFORE_INIT初始化值前，newInstance()触发AfterInitModelEvents::AFTER_INIT初始化值后，newInstance()触发BeforeBatchUpdateModelEvents::BEFORE_BATCH_UPDATE批量更新前AfterBatchUpdateModelEvents::AFTER_BATCH_UPDATE批量更新后BeforeBatchDeleteModelEvents::BEFORE_BATCH_DELETE批量删除前AfterBatchDeleteModelEvents::AFTER_BATCH_DELETE批量删除后BeforeParseDataModelEvents::BEFORE_PARSE_DATA处理 save、insert、update 数据前AfterParseDataModelEvents::AFTER_PARSE_DATA处理 save、insert、update 数据后事件传递过来的参数类型为Imi\\Model\\Event\\Param\\事件名EventParamBeforeInit和AfterInit是例外，共用Imi\\Model\\Event\\Param\\InitEventParam类模型类静态事件监听事件名称为模型类名:事件名，如：XXX\\Model\\Test+:+BeforeBatchUpdate=XXX\\Model\\Test:BeforeBatchUpdate&lt;?php\nnamespace XXX\\Listener;\n\nuse Imi\\Model\\Event\\Param\\BeforeBatchUpdateEventParam;\nuse Imi\\Model\\Event\\Listener\\IBeforeBatchUpdateEventListener;\n\n/**\n * @Listener(&quot;XXX\\Model\\Test:BeforeBatchUpdate&quot;)\n */\nclass BeforeBatchUpdate implements IBeforeBatchUpdateEventListener\n{\n    /**\n     * 事件处理方法\n     * @param BeforeBatchUpdateEventParam $e\n     * @return void\n     */\n    public function handle(BeforeBatchUpdateEventParam $e): void\n    {\n        // $e-&gt;data-&gt;name = &#039;123&#039;; // 在更新前可以对数据赋值\n    }\n}\n"},{"id":141,"title":"模型用法","pageTitle":"模型用法","url":"components/orm/RDModel.html","content":"模型用法目录模型常量TestModel::PRIMARY_KEY 第一个主键名称，字符串TestModel::PRIMARY_KEYS 主键名称数组模型操作初始化模型$testModel = TestModel::newInstance([\n    &#039;a&#039;    =&gt;    &#039;abc&#039;,\n    &#039;b&#039;    =&gt;    &#039;def&#039;,\n]);第二种方法：$testModel = TestModel::newInstance();\n$testModel-&gt;set([\n    &#039;a&#039;    =&gt;    &#039;abc&#039;,\n    &#039;b&#039;    =&gt;    &#039;def&#039;,\n]);插入$testModel = TestModel::newInstance();\n$testModel-&gt;setA(&#039;1&#039;);\n$testModel-&gt;setB(&#039;1&#039;);\n$testModel-&gt;setC(&#039;1&#039;);\n$testModel-&gt;__setRaw(&#039;value&#039;, &#039;value+1&#039;); // set value=value+1，第一个参数是字段名，第二个参数是sql\n$result = $testModel-&gt;insert();\n// $result 用法同数据库中的 insert() 返回值用法\necho &#039;插入的自增ID：&#039;, $testModel-&gt;getId();未设置值的字段（以注解定义为准），默认以 null 值插入，如有需要建议给字段设置默认值更新$testModel = TestModel::find(1, &#039;abc&#039;);\n$result = $testModel-&gt;update();\n// $result 用法同数据库中的 update() 返回值用法保存// 自动判断是插入还是更新\n$testModel-&gt;save();删除$testModel = TestModel::find(1, &#039;abc&#039;);\n$result = $testModel-&gt;delete();\n// $result 用法同数据库中的 delete() 返回值用法查询构建器imi 中数据库查询连贯操作都来自于查询器，查询器的创建方式：查询结果返回模型对象：$query = TestModel::query();query() 方法返回的类是 Imi\\Model\\Contract\\IModelQuery，它继承了 Imi\\Db\\Query\\Interfaces\\IQuery，并且有扩展特性参数说明默认值poolName连接池名，如果为null则取配置@app.db.defaultPoolnullqueryType查询类型，影响读写分离逻辑。可选：QueryType::READ/QueryType::WRITE，默认为QueryType::WRITEnullqueryClass查询器类，默认通过Model::DEFAULT_QUERY_CLASS指定nullalias表别名null查询结果返回数组：$query = TestModel::dbQuery();dbQuery() 方法返回的类是 Imi\\Db\\Query\\Interfaces\\IQuery，与 Imi\\Db\\Db::query() 返回完全一致参数说明默认值poolName连接池名，如果为null则取配置@app.db.defaultPoolnullqueryType查询类型，影响读写分离逻辑。可选：QueryType::READ/QueryType::WRITE，默认为QueryType::WRITEnullalias表别名nullIModelQuery 扩展特性：关联模型预加载$list = TestModel::query()\n                -&gt;with(&#039;关联字段名&#039;) // 单个\n                -&gt;with([&#039;字段名1&#039;, &#039;字段名2&#039;]) // 多个\n                -&gt;with([\n                    // 回调第一个参数是：模型查询构建器\n                    // 第二个参数是当前关联查询对应的注解对象，如果不确定什么类型可以写 RelationBase，如果确定类型也可以写具体类型，比如：\\Imi\\Model\\Annotation\\Relation\\OneToOne\n                    &#039;字段名1&#039; =&gt; function(\\Imi\\Model\\Contract\\IModelQuery $query, \\Imi\\Model\\Annotation\\Relation\\RelationBase $annotation) {\n                        $query-&gt;withField(&#039;a&#039;, &#039;b&#039;); // 限定查询结果模型的可序列化字段\n                    },\n                ]) // 回调\n                -&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;select()-&gt;getArray();使用预加载后，模型关联的前后置事件都不会触发和 withField() 一起用时，with() 中查询的关联字段可以手动获取。但如果要在 JSON 序列化时返回，需要在 withField() 中指定该关联字段$list = TestModel::query()-&gt;with([&#039;a&#039;])-&gt;withField(&#039;b&#039;)-&gt;select()-&gt;getArray(); // JSON 序列化时，只返回字段 b，而没有 a\n$list = TestModel::query()-&gt;with([&#039;a&#039;])-&gt;withField(&#039;a&#039;, &#039;b&#039;)-&gt;select()-&gt;getArray(); // JSON 序列化时，返回字段中有a、b指定查询出的模型可序列化的字段按照 imi 模型思想，默认会查出模型定义的所有字段。如果你想要指定某些字段在序列化时不输出，可以使用以下方式：$list1 = TestModel::query()-&gt;withField(&#039;id&#039;, &#039;name&#039;)-&gt;select()-&gt;getArray();\n\n// 上面的代码同下面的效果\n$list2 = TestModel::query()-&gt;select()-&gt;getArray();\nforeach ($list2 as $row)\n{\n    $list2-&gt;__setSerializedFields([&#039;id&#039;, &#039;name&#039;]);\n}字段名必须使用驼峰命名查询时指定字段请使用 @Sql 注解建模，参考文档：https://doc.imiphp.com/v2.1/components/orm/RDModel/definition.html#@Sql不推荐的写法：TestModel::query()-&gt;field(&#039;*&#039;)-&gt;fieldRaw(&#039;123 as value&#039;)-&gt;select()-&gt;getArray();上述写法会导致默认的 @Serializable 和 @Serializables 注解的序列化配置失效，慎用！判断记录是否存在// where id = 1\n$exists = TestModel::exists(1);\n// 复合主键 where a = 1 and b = &#039;abc&#039;\n$exists = TestModel::exists(1, &#039;abc&#039;);\n// 指定多个字段条件 where a = 1 and b = &#039;abc&#039;\n$exists = TestModel::exists([\n    &#039;a&#039; =&gt; 1,\n    &#039;b&#039; =&gt; &#039;abc&#039;,\n]);查询记录查询记录并返回一个模型实例。// where id = 1\n$testModel = TestModel::find(1);\n// 复合主键 where a = 1 and b = &#039;abc&#039;\n$testModel = TestModel::find(1, &#039;abc&#039;);\necho $testModel-&gt;getId();\n// 指定多个字段条件 where a = 1 and b = &#039;abc&#039;\n$testModel = TestModel::find([\n    &#039;a&#039; =&gt; 1,\n    &#039;b&#039; =&gt; &#039;abc&#039;,\n]);\n// 通过构建器查询\n$testModel = TestModel::query()-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;find();查询单个值TestModel::query()-&gt;value(&#039;username&#039;);\nTestModel::query()-&gt;value(&#039;username&#039;, -1); // 当数据查询不到时返回的默认值 -1查询指定列// 查询 username 列并作为数组返回\nTestModel::query()-&gt;column(&#039;username&#039;);\n// 结果值如下：\n[\n    &#039;username1&#039;,\n    &#039;username2&#039;,\n    &#039;username4&#039;,\n]\n// 查询 username 列并返回 id 做下标，username 作为值的数组\nTestModel::query()-&gt;column(&#039;username&#039;, &#039;id&#039;);\n// 结果值如下：\n[\n    1 =&gt; &#039;username1&#039;,\n    2 =&gt; &#039;username2&#039;,\n    3 =&gt; &#039;username4&#039;,\n]\n\n// 查询 username、password 列并返回 id 做下标的数组\nTestModel::query()-&gt;column([&#039;username&#039;, &#039;password&#039;], &#039;id&#039;);\n// 结果值如下：\n[\n    1 =&gt; [&#039;username&#039; =&gt; &#039;username1&#039;, &#039;password&#039; =&gt; &#039;123&#039;],\n    2 =&gt; [&#039;username&#039; =&gt; &#039;username2&#039;, &#039;password&#039; =&gt; &#039;456&#039;],\n    3 =&gt; [&#039;username&#039; =&gt; &#039;username3&#039;, &#039;password&#039; =&gt; &#039;789&#039;],\n]批量查询记录// 查询所有记录\n$list = TestModel::select();\n\n// 带 where 条件的查询，id = 1\n$list = TestModel::select([\n    &#039;id&#039;    =&gt;    1\n]);\n\n// where 回调条件\n$list = TestModel::select(function(IQuery $query){\n    $query-&gt;where(&#039;id&#039;, &#039;=&#039;, 1);\n});\n\n// 查询器查询\n$list = TestModel::query()-&gt;where(&#039;id&#039;, &#039;=&#039;, 1)-&gt;select()-&gt;getArray();\n\n// 以上所有 $list 都是 TestModel[] 类型分页查询带扩展字段查询总记录数、总页数：$page = 1;\n$count = 10;\n$data = TestModel::query()-&gt;paginate($page, $count);\n// 指定转数组后的字段名\n$data = TestModel::query()-&gt;paginate($page, $count, [\n    &#039;field_list&#039; =&gt; &#039;list&#039;,\n    &#039;field_limit&#039; =&gt; &#039;limit&#039;,\n    &#039;field_total&#039; =&gt; &#039;total&#039;,\n    &#039;field_page_count&#039; =&gt; &#039;page_count&#039;,\n]);\n\n$data-&gt;getList(); // 列表数据\n$data-&gt;getTotal(); // 总记录数\n$data-&gt;getLimit(); // $count === 10\n$data-&gt;getPageCount(); // 总页数\n\nvar_dump($data-&gt;toArray()); // 转数组\nvar_dump(json_encode($data)); // 支持序列化\n// 数据格式如下：\n[\n    &#039;list&#039;          =&gt; [],\n    &#039;total&#039;         =&gt; 100,\n    &#039;limit&#039;         =&gt; 10,\n    &#039;page_count&#039;    =&gt; 10,\n]不查询总记录数、总页数：$page = 1;\n$count = 10;\n$data = TestModel::query()-&gt;paginate($page, $count, [\n    &#039;total&#039; =&gt;  false,\n]);\nvar_dump($data-&gt;toArray()); // 转数组\nvar_dump(json_encode($data)); // 支持序列化\n// 数据格式如下：\n[\n    &#039;list&#039;          =&gt; [],\n    &#039;limit&#039;         =&gt; 10,\n]全局设置转数组后的字段名：配置@app.db.paginate.fields:[\n    &#039;list&#039; =&gt; &#039;list&#039;,\n    &#039;limit&#039; =&gt; &#039;limit&#039;,\n    &#039;total&#039; =&gt; &#039;total&#039;,\n    &#039;pageCount&#039; =&gt; &#039;page_count&#039;,\n]分块查询chunkById利用有序字段进行分段读取，返回符合条件的数据，对于大型数据集结果，可以有效缓解数据库压力，降低应用内存消耗，提升稳定性。参数类型说明limitint每次查询的块大小columnstring用于分块的有序字段，建议是有序且存在索引的数值字段，一般情况下可以利用主键aliasstring用于分块的有序字段的别名，一般情况下跟column是一致的，无须设置，如果定义字段查询结果的别名时可设置该参数orderBystring用于分块的有序字段排序方式指定，支持asc、desc，默认为asc用于查询的字段的值必须是唯一且递增的。该查询方法是不支持用户设置排序的，任何类型的排序都将被重置，仅能通过column指定一个字段的排序方式。由于不是一次性载入全部数据，预加载功能对于每个块都是重复加载的，建议根据实际情况决定是否实现一个缓存查询来替代预加载。// 按 10 条每块遍历全部符合条件的行。\n\nforeach (TestModel::query()-&gt;chunkById(10, &#039;id&#039;) as $result)\n{\n    $list = $result-&gt;getArray(); // select 结果集\n    // 遍历结果集\n    foreach ($list as $row)\n    {\n        var_dump($row);\n    }\n}\n\n// 还有一个更简单的用法\n\nforeach (TestModel::query()-&gt;chunkById(10, &#039;id&#039;)-&gt;each() as $row)\n{\n    var_dump($row);\n}chunkByOffset利用limit进行查询驱动分块，效率与一般分页查询没区别，相对chunkById兼容更多的场景，如果追求性能还是推荐chunkById。参数类型说明limitint每次查询的块大小对于ORM下使用，由于不是一次性载入全部数据，预加载功能对于每个块都是重复加载的，建议根据实际情况决定是否实现一个缓存查询来替代预加载。// 按 10 条每块遍历全部符合条件的行。\n\nforeach (TestModel::query()-&gt;chunkByOffset(10) as $result)\n{\n    $list = $result-&gt;getArray(); // select 结果集\n    // 遍历结果集\n    foreach ($list as $row)\n    {\n        var_dump($row);\n    }\n}\n\n// 还有一个更简单的用法\n\nforeach (TestModel::query()-&gt;chunkByOffset(10)-&gt;each() as $row)\n{\n    var_dump($row);\n}chunkEach该方法已弃用并计划3.0移除，请使用chunkById()-&gt;each()orchunkByOffset()-&gt;each()替代。游标查询游标查询能对于查询大结果集时能有效节约应用内存消耗，对于数据库的消耗与select无差别。。由于不是一次性载入全部数据，与预加载功能不兼容，不推荐对于游标查询进行任何的模型关联操作。foreach (TestModel::query()-&gt;cursor() as $data)\n{\n    var_dump($data); // 输出单个模型\n}聚合函数TestModel::count();\nTestModel::sum(&#039;id&#039;);批量更新// update tb_test set a = &#039;abc&#039; where id &gt; 5\nTestModel::updateBatch([\n        &#039;a&#039;    =&gt; &#039;abc&#039;,\n    ], [\n        &#039;id&#039; =&gt; [&#039;&gt;&#039;, 5]\n    ]);批量删除// delete tb_test where a = &#039;abc&#039; and id &gt; 5\nTestModel::deleteBatch([\n    &#039;a&#039; =&gt; [&#039;=&#039;, &#039;abc&#039;],\n    &#039;id&#039; =&gt; [&#039;&gt;&#039;, 5]\n]);查询器$testModel = TestModel::query()-&gt;where()-&gt;join()-&gt;select()-&gt;get();\n// $testModel 依然是 TestModel 类型对象转数组将当前对象作为数组返回：属性的值，如果是对象，那依然会保持原样。只保证第一层是数组。$testModel = TestModel::find(1, &#039;abc&#039;);\n$array = $testModel-&gt;toArray();将当前模型转为数组：包括属性的值也会被转为数组$testModel = TestModel::find(1, &#039;abc&#039;);\n$array = $testModel-&gt;convertToArray(); // 过滤注解定义的隐藏属性\n$array = $testModel-&gt;convertToArray(false); // 不过滤转换模型数组为模型$list = TestModel::select();\n$arrayList = TestModel::convertListToArray($list); // 过滤注解定义的隐藏属性\n$arrayList = TestModel::convertListToArray($list, false); // 不过滤手动获取/设置模型序列化字段默认情况下，根据 @Column 注解定义字段，@Serializable、@Serializables 干预序列化（toArray、json_encode）后的字段。现在你也可以手动干预了，示例如下：$member-&gt;__getSerializedFields(); // 获取，默认为 null 则使用默认规则\n\n$member-&gt;__setSerializedFields([&#039;username&#039;, &#039;password&#039;]); // 手动干预，序列化后只有username、password字段\n$member-&gt;__setSerializedFields(null); // 设为默认Fork 模型Fork 模型特性，支持在运行阶段创建一个新的模型类，这个类从原模型继承。并且支持指定新模型类使用的：数据库名、数据表名、连接池名。方法定义：/**\n * Fork 模型.\n *\n * @return class-string&lt;static&gt;\n */\npublic static function fork(?string $tableName = null, ?string $poolName = null)例子：$newClassName = TestModel::fork(); // 不修改任何参数，返回新的类名（这个用法没有实际意义）\n\n$newClassName = TestModel::fork(&#039;tb_test2&#039;); // 指定表名\n$newClassName = TestModel::fork(&#039;db2.tb_test2&#039;); // 指定数据库名和表名\n\n$newClassName = TestModel::fork(null, &#039;pool2&#039;); // 指定连接池名\n\n$newClassName = TestModel::fork(&#039;tb_test2&#039;, &#039;pool2&#039;); // 同时指定"},{"id":158,"title":"Redis 模型","pageTitle":"Redis 模型","url":"components/orm/RedisModel.html","content":"Redis 模型目录介绍Redis 模型适合固定结构的数据结构，可以跟关系型数据库的模型一样，无需关心直接的操作，增删改查一把梭。模型定义喜闻乐见的对命名空间、类名无要求，只要按照规定写注解即可！具体定义看下面代码：&lt;?php\nnamespace ImiDemo\\HttpDemo\\MainServer\\Model;\n\nuse Imi\\Model\\RedisModel;\nuse Imi\\Model\\Annotation\\Table;\nuse Imi\\Model\\Annotation\\Column;\nuse Imi\\Model\\Annotation\\Entity;\nuse Imi\\Model\\Annotation\\RedisEntity;\n\n/**\n * Test\n * @Entity\n * @RedisEntity(poolName=&quot;redis&quot;, key=&quot;{id}-{name}&quot;)\n */\nclass TestRedisModel extends RedisModel\n{\n    /**\n     * id\n     * @Column(name=&quot;id&quot;)\n     * @var int\n     */\n    protected $id;\n\n    /**\n     * 获取 id\n     *\n     * @return int\n     */\n    public function getId()\n    {\n        return $this-&gt;id;\n    }\n\n    /**\n     * 赋值 id\n     * @param int $id id\n     * @return static\n     */\n    public function setId($id)\n    {\n        $this-&gt;id = $id;\n        return $this;\n    }\n\n    /**\n     * name\n     * @Column(name=&quot;name&quot;)\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * 获取 name\n     *\n     * @return string\n     */\n    public function getName()\n    {\n        return $this-&gt;name;\n    }\n\n    /**\n     * 赋值 name\n     * @param string $name name\n     * @return static\n     */\n    public function setName($name)\n    {\n        $this-&gt;name = $name;\n        return $this;\n    }\n\n    /**\n     * age\n     * @Column(name=&quot;age&quot;)\n     * @var string\n     */\n    protected $age;\n\n    /**\n     * 获取 age\n     *\n     * @return string\n     */\n    public function getAge()\n    {\n        return $this-&gt;age;\n    }\n\n    /**\n     * 赋值 age\n     * @param string $age age\n     * @return static\n     */\n    public function setAge($age)\n    {\n        $this-&gt;age = $age;\n        return $this;\n    }\n}需要使用注解将表、字段属性全部标注。并且写上get和set方法。@RedisEntity指定当前类为Redis实体类可选属性：poolNameredis连接池名称db第几个库，不传为null时使用连接池默认配置key键，支持定义多个参数，默认为{key}，在RedisModel中已经预先定义了setKey()和getKey()方法member，规则同key，仅在storage为hash时有效ttl数据默认的过期时间，null为永不过期，hash 存储模式不支持过期storageRedis 实体类存储模式，支持：string、hash、hash_objectformatter 格式；可选：Imi\\Util\\Format\\Json、Imi\\Util\\Format\\PhpSerialize，或者可以自行实现Imi\\Util\\Format\\IFormat接口storage 属性说明：string字符串模式，使用 set/get 存序列化后的对象hashhash 模式，使用 hset/hget 存序列化后的对象hash_objecthash 对象模式，使用 hset/hget，将对象存到一个 key 中，member 为字段名@ColumnRedis模型中只有name生效模型操作所有操作都是依据上面定义的TestRedisModel查找一条记录// 读取-直接传key\n$model2 = TestRedisModel::find(&#039;123-imi&#039;);\n\n// 读取-传参数组成\n$model3 = TestRedisModel::find([\n    &#039;id&#039;    =&gt;    &#039;123&#039;,\n    &#039;name&#039;    =&gt;    &#039;imi&#039;\n]);查询多条记录$list = TestRedisModel::select(&#039;kkk&#039;, &#039;123-imi&#039;, [\n    &#039;id&#039;    =&gt;    &#039;123&#039;,\n    &#039;name&#039;    =&gt;    &#039;imi&#039;\n]);\nforeach($list as $item)\n{\n    var_dump($item-&gt;toArray());\n}保存记录$model = TestRedisModel::newInstance();\n$model-&gt;setId(123);\n$model-&gt;setName(&#039;imi&#039;);\n$model-&gt;setAge(100);\n$model-&gt;save();\n删除记录$model2 = TestRedisModel::find(&#039;123-imi&#039;);\n$model2-&gt;delete();批量删除// 删除键为key和123-imi的数据\n// 123-imi是以RedisEntity中定义为准\nTestRedisModel::deleteBatch(&#039;kkk&#039;, [\n    &#039;id&#039;    =&gt;    &#039;123&#039;,\n    &#039;name&#039;    =&gt;    &#039;imi&#039;\n]);"},{"id":155,"title":"前置和后置事件","pageTitle":"前置和后置事件","url":"components/orm/relation/events.html","content":"前置和后置事件目录在 imi 中，使用模型关联时，提供了监听前置和后置事件的方法，让开发者可以更加灵活地做一些自定义处理。事件插入事件前置事件名： IMI.MODEL.RELATION.INSERT.模型类名.模型属性名.BEFORE后置事件名： IMI.MODEL.RELATION.INSERT.模型类名.模型属性名.AFTER事件参数：参数名类型描述modelstring模型类名propertyNamestring模型属性名annotationOneToOne OneToMany ManyToMany PolymorphicOneToOne PolymorphicOneToMany PolymorphicManyToMany PolymorphicToOne PolymorphicToMany注解，命名空间前缀\\Imi\\Model\\Annotation\\Relation\\structOneToOne OneToMany ManyToMany PolymorphicOneToOne PolymorphicOneToMany PolymorphicManyToMany用于获取一些信息的结构，命名空间前缀\\Imi\\Model\\Relation\\Struct\\更新事件前置事件名： IMI.MODEL.RELATION.UPDATE.模型类名.模型属性名.BEFORE后置事件名： IMI.MODEL.RELATION.UPDATE.模型类名.模型属性名.AFTER事件参数：同插入事件参数删除事件前置事件名： IMI.MODEL.RELATION.DELETE.模型类名.模型属性名.BEFORE后置事件名： IMI.MODEL.RELATION.DELETE.模型类名.模型属性名.AFTER事件参数：同插入事件参数查询事件前置事件名： IMI.MODEL.RELATION.QUERY.模型类名.模型属性名.BEFORE后置事件名： IMI.MODEL.RELATION.QUERY.模型类名.模型属性名.AFTER事件参数：参数名类型描述modelstring模型类名propertyNamestring模型属性名annotationOneToOne OneToMany ManyToMany PolymorphicOneToOne PolymorphicOneToMany PolymorphicManyToMany PolymorphicToOne PolymorphicToMany注解，命名空间前缀\\Imi\\Model\\Annotation\\Relation\\structOneToOne OneToMany ManyToMany PolymorphicOneToOne PolymorphicOneToMany PolymorphicManyToMany用于获取一些信息的结构，命名空间前缀\\Imi\\Model\\Relation\\Struct\\。annotation为PolymorphicToOne时不会有该参数。query\\Imi\\Db\\Query\\Interfaces\\IQuery查询构建器对象，为前置事件时必传"},{"id":147,"title":"介绍","pageTitle":"介绍","url":"components/orm/relation/index.html","content":"介绍目录通过预先确定好模型之间的关系，在业务开发中，使用非常简便的写法，就可以实现复杂的涉及多表数据增删改查。这一切都是模型底层实现帮你在处理，在 imi 中，模型的关联关系都使用注解来定义。注解这里列出定义模型关联关系所需的注解，所有关联模型的注解，命名空间为Imi\\Model\\Annotation\\Relation@OneToOne一对一关系声明用法：@OneToOne(&quot;模型类名&quot;)@OneToOne(model=&quot;模型类名&quot;)查询时指定字段：@OneToOne(model=&quot;模型类名&quot;, fields={&quot;指定查询时字段&quot;})预加载，减少查询次数：@OneToOne(model=&quot;模型类名&quot;, fields={&quot;指定查询时字段&quot;}, with=true, withFields={&quot;指定序列化字段&quot;})查询结果包含被软删除的数据：@OneToOne(model=&quot;模型类名&quot;, withSoftDelete=true)仅查询有效，非软删除模型请勿设置为 true@OneToMany一对多关系声明用法：@OneToMany(&quot;模型类名&quot;)@OneToMany(model=&quot;模型类名&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, limit=null)查询时指定字段：@OneToMany(model=&quot;模型类名&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;})预加载，减少查询次数：@OneToMany(model=&quot;模型类名&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;}, with=true, withFields={&quot;指定序列化字段&quot;})查询结果包含被软删除的数据：@OneToMany(model=&quot;模型类名&quot;, withSoftDelete=true)仅查询有效，非软删除模型请勿设置为 true@ManyToMany多对多关系声明用法：@ManyToMany(model=&quot;关联模型&quot;, middle=&quot;中间模型类名&quot;, rightMany=&quot;属性名，赋值为关联的模型对象列表&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, limit=null)查询时指定字段：@ManyToMany(model=&quot;关联模型&quot;, middle=&quot;中间模型类名&quot;, rightMany=&quot;属性名，赋值为关联的模型对象列表&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;})预加载，减少查询次数：@ManyToMany(model=&quot;关联模型&quot;, middle=&quot;中间模型类名&quot;, rightMany=&quot;属性名，赋值为关联的模型对象列表&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;}, with=true, withFields={&quot;指定序列化字段&quot;})查询结果包含被软删除的数据：@ManyToMany(model=&quot;关联模型&quot;, middle=&quot;中间模型类名&quot;, rightMany=&quot;属性名，赋值为关联的模型对象列表&quot;, withSoftDelete=true)仅查询有效，非软删除模型请勿设置为 true@PolymorphicOneToOne多态一对一关系声明用法：@PolymorphicOneToOne(model=&quot;关联模型&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;)查询时指定字段：@PolymorphicOneToOne(model=&quot;关联模型&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, fields={&quot;指定查询时字段&quot;})预加载，减少查询次数：@PolymorphicOneToOne(model=&quot;关联模型&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, fields={&quot;指定查询时字段&quot;}, with=true, withFields={&quot;指定序列化字段&quot;})查询结果包含被软删除的数据：@PolymorphicOneToOne(model=&quot;关联模型&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, withSoftDelete=true)仅查询有效，非软删除模型请勿设置为 true@PolymorphicOneToMany多态一对多关系声明用法：@PolymorphicOneToMany(model=&quot;关联模型&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, limit=null)查询时指定字段：@PolymorphicOneToMany(model=&quot;关联模型&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;})预加载，减少查询次数：@PolymorphicOneToMany(model=&quot;关联模型&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;}, with=true, withFields={&quot;指定序列化字段&quot;})查询结果包含被软删除的数据：@PolymorphicOneToMany(model=&quot;关联模型&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, withSoftDelete=true)仅查询有效，非软删除模型请勿设置为 true@PolymorphicManyToMany多态多对多关系声明用法：@PolymorphicManyToMany(model=&quot;关联模型&quot;, middle=&quot;中间模型类名&quot;, rightMany=&quot;属性名，赋值为关联的模型对象列表&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, limit=null)查询时指定字段：@PolymorphicManyToMany(model=&quot;关联模型&quot;, middle=&quot;中间模型类名&quot;, rightMany=&quot;属性名，赋值为关联的模型对象列表&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;})预加载，减少查询次数：@PolymorphicManyToMany(model=&quot;关联模型&quot;, middle=&quot;中间模型类名&quot;, rightMany=&quot;属性名，赋值为关联的模型对象列表&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;}, with=true, withFields={&quot;指定序列化字段&quot;})查询结果包含被软删除的数据：@PolymorphicManyToMany(model=&quot;关联模型&quot;, middle=&quot;中间模型类名&quot;, rightMany=&quot;属性名，赋值为关联的模型对象列表&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, withSoftDelete=true)仅查询有效，非软删除模型请勿设置为 true@PolymorphicToOne用于多态一对一、一对多关联被关联的模型中使用，查询对应的左侧模型允许出现多个，会根据type和typeValue判断，选择合适的注解配置查询模型。用法：@PolymorphicToOne(model=&quot;关联模型&quot;, modelField=&quot;关联的模型用于关联的字段&quot;, field=&quot;当前模型用于关联的字段&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;)查询时指定字段：@PolymorphicToOne(model=&quot;关联模型&quot;, modelField=&quot;关联的模型用于关联的字段&quot;, field=&quot;当前模型用于关联的字段&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, fields={&quot;指定查询时字段&quot;})预加载，减少查询次数：@PolymorphicToOne(model=&quot;关联模型&quot;, modelField=&quot;关联的模型用于关联的字段&quot;, field=&quot;当前模型用于关联的字段&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, fields={&quot;指定查询时字段&quot;}, with=true, withFields={&quot;指定序列化字段&quot;})查询结果包含被软删除的数据：@PolymorphicToOne(model=&quot;关联模型&quot;, modelField=&quot;关联的模型用于关联的字段&quot;, field=&quot;当前模型用于关联的字段&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, withSoftDelete=true)仅查询有效，非软删除模型请勿设置为 true@PolymorphicToMany用于多态多对多关联被关联的模型中使用，查询对应的左侧模型列表允许出现多个，会根据type和typeValue判断，选择合适的注解配置查询模型。用法：@PolymorphicToMany(model=&quot;关联模型&quot;, modelField=&quot;关联的模型用于关联的字段&quot;, field=&quot;当前模型用于关联的字段&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, limit=null, middleLeftField=&quot;中间表与模型类的关联字段&quot;, middleRightField=&quot;中间表与当前类的关联字段&quot;)查询时指定字段：@PolymorphicToMany(model=&quot;关联模型&quot;, modelField=&quot;关联的模型用于关联的字段&quot;, field=&quot;当前模型用于关联的字段&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;}, middleLeftField=&quot;中间表与模型类的关联字段&quot;, middleRightField=&quot;中间表与当前类的关联字段&quot;)预加载，减少查询次数：@PolymorphicToMany(model=&quot;关联模型&quot;, modelField=&quot;关联的模型用于关联的字段&quot;, field=&quot;当前模型用于关联的字段&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, order=&quot;排序规则字符串，例：age desc, id desc&quot;, fields={&quot;指定查询时字段&quot;}, middleLeftField=&quot;中间表与模型类的关联字段&quot;, middleRightField=&quot;中间表与当前类的关联字段&quot;, with=true, withFields={&quot;指定序列化字段&quot;})查询结果包含被软删除的数据：@PolymorphicToMany(model=&quot;关联模型&quot;, modelField=&quot;关联的模型用于关联的字段&quot;, field=&quot;当前模型用于关联的字段&quot;, type=&quot;多态类型字段名&quot;, typeValue=&quot;多态类型值&quot;, withSoftDelete=true)仅查询有效，非软删除模型请勿设置为 trueRelation自定义关联注解@JoinFrom一对一、一对多声明中，指定左表与右表关联用的字段名用法：@JoinFrom(&quot;字段名&quot;)@JoinFrom(field=&quot;字段名&quot;)@JoinTo一对一、一对多声明中，指定右表与左表关联用的字段名用法：@JoinTo(&quot;字段名&quot;)@JoinTo(field=&quot;字段名&quot;)@JoinToMiddle多对多声明中，指定左侧模型关联到中间表模型用法：@JoinToMiddle(field=&quot;左侧关联字段&quot;, middleField=&quot;中间表关联字段&quot;)@JoinFromMiddle多对多声明中，指定中间表模型关联到右侧模型用法：@JoinFromMiddle(field=&quot;右侧关联字段&quot;, middleField=&quot;中间表关联字段&quot;)@AutoSelect指定模型查询（find、select）时，该关联属性是否自动查询出关联数据。不写该注解，或不指定值默认为true用法：@AutoSelect@AutoSelect(true)是否总是显示该属性，如果为false，在为null时序列化为数组或json不显示该属性。默认为true@AutoSelect(alwaysShow=false)@AutoInsert指定模型插入（insert、save）时，该关联属性是否自动插入关联数据。不指定值默认为true用法：@AutoInsert@AutoInsert(true)@AutoInsert(false)@AutoUpdate指定模型更新（update、save）时，该关联属性是否自动更新关联数据。不指定值默认为true当orphanRemoval为true时，会把不包含在模型里的关联数据删除后再更新、插入关联数据。用法：@AutoUpdate@AutoUpdate(true)@AutoUpdate(false)@AutoUpdate(orphanRemoval=true)@AutoSave指定模型保存（save）时，该关联属性是否自动保存关联数据。不指定值默认为true当orphanRemoval为true时，会把不包含在模型里的关联数据删除后再更新、插入关联数据。用法：@AutoSave@AutoSave(true)@AutoSave(false)@AutoSave(orphanRemoval=true)@AutoDelete指定模型删除（delete）时，该关联属性是否自动删除关联数据。不指定值默认为true用法：@AutoDelete@AutoDelete(true)@AutoDelete(false)方法查询指定关联使用关联模型时，你可以设置注解@AutoSelect(false)，让它不自动查询。在之后想要用到的时候，再手动查询。$model-&gt;queryRelations(&#039;属性名&#039;);\n\n// 也可以支持多个\n$model-&gt;queryRelations(&#039;属性名1&#039;, &#039;属性名2&#039;);\n\n// 查询后可以这么获取结果\n$data = $model-&gt;属性名;为一个列表查询指定关联\\Imi\\Model\\Model::queryRelationsList($modelList);"},{"id":150,"title":"多对多关联","pageTitle":"多对多关联","url":"components/orm/relation/manyToMany.html","content":"多对多关联目录比如我们要关联用户和角色之间的关系，就要用到多对多。多对多需要一张中间表来做关联。定义多对多关联会用到的注解：@ManyToMany、@JoinFromMiddle、@JoinToMiddle、@AutoSelect、@AutoInsert、@AutoUpdate、@AutoSave、@AutoDelete如 imi-demo 中代码所示，类定义了一个$userRole属性和$role属性。$userRole属性定义的是中间模型，指定中间模型为UserRole，右侧表模型Role，右侧表模型数据到时会赋值到$role属性中。User模型使用id与中间模型的user_id关联，中间模型使用role_id与右侧模型id关联。允许自动查询、插入、更新、保存、删除时，自动处理关联模型数据。/**\n * User\n * @Entity\n * @Table(name=&quot;tb_user&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property string $username\n * @property \\ImiDemo\\HttpDemo\\MainServer\\Model\\UserEx $ex\n * @property \\Imi\\Util\\ArrayList $userRole\n * @property \\Imi\\Util\\ArrayList $role\n */\nclass User extends Model\n{\n    /**\n     * @ManyToMany(model=&quot;Role&quot;, middle=&quot;UserRole&quot;, rightMany=&quot;role&quot;)\n     * @JoinToMiddle(field=&quot;id&quot;, middleField=&quot;user_id&quot;)\n     * @JoinFromMiddle(middleField=&quot;role_id&quot;, field=&quot;id&quot;)\n     * \n     * @AutoInsert\n     * @AutoUpdate\n     * @AutoSave\n     * @AutoDelete\n     *\n     * @var \\Imi\\Util\\ArrayList\n     */\n    protected $userRole;\n    \n    /**\n     * Get the value of userRole\n     *\n     * @return  \\Imi\\Util\\ArrayList\n     */ \n    public function getUserRole()\n    {\n        return $this-&gt;userRole;\n    }\n\n    /**\n     * Set the value of userRole\n     *\n     * @param  \\Imi\\Util\\ArrayList  $userRole\n     *\n     * @return  self\n     */ \n    public function setUserRole($userRole)\n    {\n        $this-&gt;userRole = $userRole;\n\n        return $this;\n    }\n\n    /**\n     * \n     *\n     * @var \\Imi\\Util\\ArrayList\n     */\n    protected $role;\n\n    /**\n     * Get the value of role\n     *\n     * @return  \\ImiDemo\\HttpDemo\\MainServer\\Model\\ArrayList[]\n     */ \n    public function getRole()\n    {\n        return $this-&gt;role;\n    }\n\n    /**\n     * Set the value of role\n     *\n     * @param  \\ImiDemo\\HttpDemo\\MainServer\\Model\\ArrayList[]  $role\n     *\n     * @return  self\n     */ \n    public function setRole($role)\n    {\n        $this-&gt;role = $role;\n\n        return $this;\n    }\n\n    // 其它这边省略……\n}查询find$model = UserWithFriend::find(1);\n// 可以取到关联关系及右侧模型数据\nvar_dump($model-&gt;userRole);\nvar_dump($model-&gt;role);select$list = UserWithFriend::select();\nforeach($list as $item)\n{\n    // 可以取到关联关系及右侧模型数据\n    var_dump($item-&gt;userRole);\n    var_dump($item-&gt;role);\n}插入$user = UserWithFriend::newInstance();\n$user-&gt;username = Random::letterAndNumber(6, 16);\n$user-&gt;ex-&gt;intro = &#039;这个人很懒，什么也没留下&#039;;\n// 插入关联关系\n$user-&gt;userRole-&gt;append(\n    UserRole::newInstance([&#039;role_id&#039;=&gt;1]), \n    UserRole::newInstance([&#039;role_id&#039;=&gt;2])\n);\n$result = $user-&gt;insert();更新$user = UserWithFriend::find(1);\n$user-&gt;ex-&gt;intro = &#039;这个人很懒，什么也没留下-&#039; . date(&#039;Y-m-d H:i:s&#039;);\n$user-&gt;userRole-&gt;clear();\n// 更新关联关系\n$user-&gt;userRole-&gt;append(\n    UserRole::newInstance([&#039;role_id&#039;=&gt;998])\n);\n$result = $user-&gt;update();保存和insert、update同理，就不作演示了。删除$user = UserWithFriend::find(1);\n// 删除数据和关联关系\n$result = $user-&gt;delete();\nif($result-&gt;isSuccess())\n{\n    echo &#039;success&#039;;\n}"},{"id":149,"title":"一对多关联","pageTitle":"一对多关联","url":"components/orm/relation/oneToMany.html","content":"一对多关联目录比如我们有一个用户表，每个用户都可以发布文章，用户和文章就是一对多的关系。当然imi-demo里一对多的例子选的不好，不过不重要，理解意思就行。定义一对多关联会用到的注解：@OneToMany、@JoinFrom、@JoinTo、@AutoSelect、@AutoInsert、@AutoUpdate、@AutoSave、@AutoDelete如 imi-demo 中代码所示，UserWithFriend继承User。类定义了一个$friends属性，这个属性关联UserFriend模型。User中id与UserFriend中user_id关联，你可能会发现没有@JoinFrom注解，没有的话默认取左侧模型的主键。允许自动查询、插入、更新、删除时，自动处理UserFriend模型数据，当更新时，会删除不存在的数据。/**\n * User\n * @Entity\n * @Table(name=&quot;tb_user&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property string $username\n * @property \\ImiDemo\\HttpDemo\\MainServer\\Model\\UserEx $ex\n * @property \\Imi\\Util\\ArrayList $friends\n */\nclass UserWithFriend extends User\n{\n    /**\n     * @OneToMany(&quot;UserFriend&quot;)\n     * @JoinTo(&quot;user_id&quot;)\n     * @AutoInsert(true)\n     * @AutoUpdate(orphanRemoval=true)\n     * @AutoDelete(true)\n     *\n     * @var \\Imi\\Util\\ArrayList\n     */\n    protected $friends;\n\n    /**\n     * Get the value of friends\n     *\n     * @return  \\ImiDemo\\HttpDemo\\MainServer\\Model\\UserFriend[]\n     */ \n    public function getFriends()\n    {\n        return $this-&gt;friends;\n    }\n\n    /**\n     * Set the value of friends\n     *\n     * @param  \\ImiDemo\\HttpDemo\\MainServer\\Model\\UserFriend[]  $friends\n     *\n     * @return  self\n     */ \n    public function setFriends($friends)\n    {\n        $this-&gt;friends = $friends;\n\n        return $this;\n    }\n\n}查询find$model = UserWithFriend::find(1);\nvar_dump($model-&gt;friends); // friends数据可以直接取到，是UserFriend实例select$list = UserWithFriend::select();\nforeach($list as $item)\n{\n    var_dump($item-&gt;friends); // friends数据可以直接取到，是UserFriend实例\n}插入$user = UserWithFriend::newInstance();\n$user-&gt;username = &#039;Yurun&#039;;\n// 由于继承了User类，所以一对一关系还是存在，依旧可以使用\n$user-&gt;ex-&gt;intro = &#039;这个人很懒，什么也没留下&#039;;\n// 在朋友关系列表中增加2项\n$user-&gt;friends-&gt;append(\n    UserFriend::newInstance([&#039;friend_user_id&#039;=&gt;1]), \n    UserFriend::newInstance([&#039;friend_user_id&#039;=&gt;2])\n);\n$result = $user-&gt;insert();更新$user = UserWithFriend::find(1);\n$user-&gt;ex-&gt;intro = &#039;这个人很懒，什么也没留下-&#039; . date(&#039;Y-m-d H:i:s&#039;);\n\n// 下面注释的代码，是把多余的记录删除，只保留id为4这个\n// $friendIds = [4];\n// $user-&gt;friends-&gt;clear();\n// $updateItems = UserFriend::query()-&gt;where(&#039;user_id&#039;, &#039;=&#039;, $user-&gt;id)-&gt;whereIn(&#039;friend_user_id&#039;, $friendIds)-&gt;select()-&gt;getArray();\n// $user-&gt;friends-&gt;append(...$updateItems);\n// $ids = ObjectArrayHelper::column($updateItems, &#039;friend_user_id&#039;);\n// foreach(array_diff($friendIds, $ids) as $id)\n// {\n//     $user-&gt;friends-&gt;append(UserFriend::newInstance([\n//         &#039;friend_user_id&#039;    =&gt;    $id,\n//     ]));\n// }\n\n// 下面的是简单的增加两项关联\n$user-&gt;friends-&gt;append(\n    UserFriend::newInstance([&#039;friend_user_id&#039;=&gt;1]), \n    UserFriend::newInstance([&#039;friend_user_id&#039;=&gt;2])\n);\n\n$result = $user-&gt;update();保存和insert、update同理，就不作演示了。删除$user = UserWithFriend::find(1);\n// 删除ID为1的记录，UserEx对应表也会删除这条关联记录\n$result = $user-&gt;delete();\nif($result-&gt;isSuccess())\n{\n    echo &#039;success&#039;;\n}"},{"id":148,"title":"一对一关联","pageTitle":"一对一关联","url":"components/orm/relation/oneToOne.html","content":"一对一关联目录比如我们有一个用户表，另外有一个个人资料表，他们之间的关联就是一对一的关系。定义一对一关联会用到的注解：@OneToOne、@JoinFrom、@JoinTo、@AutoSelect、@AutoInsert、@AutoUpdate、@AutoSave、@AutoDelete如 imi-demo 中代码所示，定义了一个$ex属性，这个属性关联UserEx模型。User中id与UserEx中user_id关联。允许自动查询、保存、删除时，自动处理UserEx模型数据。/**\n * User\n * @Entity\n * @Table(name=&quot;tb_user&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property string $username\n * @property \\ImiDemo\\HttpDemo\\MainServer\\Model\\UserEx $ex\n * @property \\Imi\\Util\\ArrayList $userRole\n * @property \\Imi\\Util\\ArrayList $role\n */\nclass User extends Model\n{\n    /**\n     * @OneToOne(&quot;UserEx&quot;)\n     * @JoinFrom(&quot;id&quot;)\n     * @JoinTo(&quot;user_id&quot;)\n     * @AutoSave(true)\n     * @AutoDelete\n     */\n    protected ?\\ImiDemo\\HttpDemo\\MainServer\\Model\\UserEx $ex = null;\n\n    /**\n     * Get the value of ex\n     */ \n    public function getEx(): ?\\ImiDemo\\HttpDemo\\MainServer\\Model\\UserEx\n    {\n        return $this-&gt;ex;\n    }\n\n    /**\n     * Set the value of ex\n     *\n     * @return  self\n     */ \n    public function setEx(?\\ImiDemo\\HttpDemo\\MainServer\\Model\\UserEx $ex)\n    {\n        $this-&gt;ex = $ex;\n\n        return $this;\n    }\n\n    // 其它这边省略……查询find$model = User::find(1);\nvar_dump($model-&gt;ex); // ex数据可以直接取到，是UserEx实例select$list = User::select();\nforeach($list as $item)\n{\n    var_dump($item-&gt;ex); // ex数据可以直接取到，是UserEx实例\n}插入$user = User::newInstance();\n$user-&gt;username = &#039;User123&#039;;\n\n// 对UserEx实例赋值\n$user-&gt;ex-&gt;intro = &#039;这个人很懒，什么也没留下&#039;;\n\n// 一句话，数据插入两张表\n$result = $user-&gt;insert();\n\nvar_dump($result-&gt;getLastInsertId());更新$user = User::find(1);\n$user-&gt;ex-&gt;intro = &#039;这个人很懒，什么也没留下-&#039; . date(&#039;Y-m-d H:i:s&#039;);\n\n// 更新ID为1的记录\n// 对User对象执行update，同时也会让UserEx做update\n$result = $user-&gt;update();保存和insert、update同理，就不作演示了。删除$user = User::find(1);\n// 删除ID为1的记录，UserEx对应表也会删除这条关联记录\n$result = $user-&gt;delete();\nif($result-&gt;isSuccess())\n{\n    echo &#039;success&#039;;\n}"},{"id":153,"title":"多态多对多关联","pageTitle":"多态多对多关联","url":"components/orm/relation/polymorphicManyToMany.html","content":"多态多对多关联目录比如我们有一张文章表，一张书籍表，一张标签表，一张标签关联表。文章和书籍共用标签库。mysql&gt; desc tb_article;\n+---------+------------------+------+-----+---------+----------------+\n| Field   | Type             | Null | Key | Default | Extra          |\n+---------+------------------+------+-----+---------+----------------+\n| id      | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| title   | varchar(32)      | NO   |     | NULL    |                |\n| content | text             | NO   |     | NULL    |                |\n+---------+------------------+------+-----+---------+----------------+\n\nmysql&gt; desc tb_book;\n+-------+------------------+------+-----+---------+----------------+\n| Field | Type             | Null | Key | Default | Extra          |\n+-------+------------------+------+-----+---------+----------------+\n| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| title | varchar(32)      | NO   |     | NULL    |                |\n+-------+------------------+------+-----+---------+----------------+\n\nmysql&gt; desc tb_tags;\n+-------+------------------+------+-----+---------+----------------+\n| Field | Type             | Null | Key | Default | Extra          |\n+-------+------------------+------+-----+---------+----------------+\n| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| name  | varchar(32)      | NO   |     | NULL    |                |\n+-------+------------------+------+-----+---------+----------------+\n\nmysql&gt; desc tb_taggables;\n+---------------+------------------+------+-----+---------+-------+\n| Field         | Type             | Null | Key | Default | Extra |\n+---------------+------------------+------+-----+---------+-------+\n| tag_id        | int(10) unsigned | NO   | PRI | NULL    |       |\n| taggable_id   | int(10) unsigned | NO   | PRI | NULL    |       |\n| taggable_type | tinyint(4)       | NO   | PRI | NULL    |       |\n+---------------+------------------+------+-----+---------+-------+定义多对多关联会用到的注解：@PolymorphicManyToMany、@PolymorphicToMany、@JoinFromMiddle、@JoinToMiddle、@AutoSelect、@AutoInsert、@AutoUpdate、@AutoSave、@AutoDeleteArticle 模型/**\n * Article\n * @Entity\n * @Table(name=&quot;tb_article&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property string $title\n * @property string $content\n * @property \\Imi\\Util\\ArrayList $comments\n * @property \\Imi\\Util\\ArrayList $taggables\n * @property \\Imi\\Util\\ArrayList $tags\n */\nclass Article extends Model\n{\n    // 省略其它……\n\n    /**\n     * 标签关联\n     *\n     * @PolymorphicManyToMany(model=&quot;Tags&quot;, middle=&quot;Taggables&quot;, rightMany=&quot;tags&quot;, type=&quot;taggable_type&quot;, typeValue=1)\n     * @JoinToMiddle(field=&quot;id&quot;, middleField=&quot;taggable_id&quot;)\n     * @JoinFromMiddle(middleField=&quot;tag_id&quot;, field=&quot;id&quot;)\n     *\n     * @AutoInsert\n     * @AutoUpdate(orphanRemoval=true)\n     * @AutoSave\n     * @AutoDelete\n     *\n     * @var \\Imi\\Util\\ArrayList\n     */\n    protected $taggables;\n\n    /**\n     * Get 标签关联\n     *\n     * @return  \\Imi\\Util\\ArrayList\n     */\n    public function getTaggables()\n    {\n        return $this-&gt;taggables;\n    }\n\n    /**\n     * Set 标签关联\n     *\n     * @param  \\Imi\\Util\\ArrayList  $taggables  标签关联\n     *\n     * @return  self\n     */\n    public function setTaggables(\\Imi\\Util\\ArrayList $taggables)\n    {\n        $this-&gt;taggables = $taggables;\n\n        return $this;\n    }\n\n    /**\n     * 关联标签\n     *\n     * @var \\Imi\\Util\\ArrayList\n     */\n    protected $tags;\n\n    /**\n     * Get 关联标签\n     *\n     * @return  \\Imi\\Util\\ArrayList\n     */\n    public function getTags()\n    {\n        return $this-&gt;tags;\n    }\n\n    /**\n     * Set 关联标签\n     *\n     * @param  \\Imi\\Util\\ArrayList  $tags  关联标签\n     *\n     * @return  self\n     */\n    public function setTags($tags)\n    {\n        $this-&gt;tags = $tags;\n\n        return $this;\n    }\n}Tags 模型/**\n * Tags\n * @Entity\n * @Table(name=&quot;tb_tags&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property string $name\n */\nclass Tags extends Model\n{\n    // 省略其它……\n\n    /**\n     * 拥有本标签的文章列表\n     *\n     * @PolymorphicToMany(model=ImiDemo\\HttpDemo\\MainServer\\Model\\Article::class, modelField=&quot;id&quot;, type=&quot;taggable_type&quot;, typeValue=1, field=&quot;taggable_id&quot;, middle=&quot;Taggables&quot;)\n     * @JoinToMiddle(field=&quot;id&quot;, middleField=&quot;taggable_id&quot;)\n     * @JoinFromMiddle(middleField=&quot;tag_id&quot;, field=&quot;id&quot;)\n     *\n     * @AutoSelect(false)\n     *\n     * @var \\Imi\\Util\\ArrayList\n     */\n    protected $articles;\n\n    /**\n     * Get 拥有本标签的模型列表\n     *\n     * @return  \\Imi\\Util\\ArrayList\n     */\n    public function getArticles()\n    {\n        return $this-&gt;articles;\n    }\n\n    /**\n     * Set 拥有本标签的模型列表\n     *\n     * @param  \\Imi\\Util\\ArrayList  $articles  拥有本标签的模型列表\n     *\n     * @return  self\n     */\n    public function setArticles(\\Imi\\Util\\ArrayList $articles)\n    {\n        $this-&gt;articles = $articles;\n\n        return $this;\n    }\n\n    /**\n     * 拥有本标签的书籍列表\n     *\n     * @PolymorphicToMany(model=ImiDemo\\HttpDemo\\MainServer\\Model\\Book::class, modelField=&quot;id&quot;, type=&quot;taggable_type&quot;, typeValue=2, field=&quot;taggable_id&quot;, middle=&quot;Taggables&quot;)\n     * @JoinToMiddle(field=&quot;id&quot;, middleField=&quot;taggable_id&quot;)\n     * @JoinFromMiddle(middleField=&quot;tag_id&quot;, field=&quot;id&quot;)\n     *\n     * @AutoSelect(false)\n     *\n     * @var \\Imi\\Util\\ArrayList\n     */\n    protected $books;\n\n    /**\n     * Get 拥有本标签的书籍列表\n     *\n     * @return  \\Imi\\Util\\ArrayList\n     */\n    public function getBooks()\n    {\n        return $this-&gt;books;\n    }\n\n    /**\n     * Set 拥有本标签的书籍列表\n     *\n     * @param  \\Imi\\Util\\ArrayList  $books  拥有本标签的书籍列表\n     *\n     * @return  self\n     */\n    public function setBooks(\\Imi\\Util\\ArrayList $books)\n    {\n        $this-&gt;books = $books;\n\n        return $this;\n    }\n\n}Taggables 模型没有要设置的注解，不展示了查询常见的增删改查就不写了，和一对多关联一样用法标签反查文章和书籍$tag = Tags::find(1);\n$tag-&gt;queryRelations(&#039;articles&#039;, &#039;books&#039;);\n$articles = $tag-&gt;articles;\n$books = $tag-&gt;books;"},{"id":152,"title":"多态一对多关联","pageTitle":"多态一对多关联","url":"components/orm/relation/polymorphicOneToMany.html","content":"多态一对多关联目录比如我们有一张文章表，一张书籍表，一张评论表。文章和书籍的评论记录都在同一张评论表中。mysql&gt; desc tb_article;\n+---------+------------------+------+-----+---------+----------------+\n| Field   | Type             | Null | Key | Default | Extra          |\n+---------+------------------+------+-----+---------+----------------+\n| id      | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| title   | varchar(32)      | NO   |     | NULL    |                |\n| content | text             | NO   |     | NULL    |                |\n+---------+------------------+------+-----+---------+----------------+\n\nmysql&gt; desc tb_book;\n+-------+------------------+------+-----+---------+----------------+\n| Field | Type             | Null | Key | Default | Extra          |\n+-------+------------------+------+-----+---------+----------------+\n| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| title | varchar(32)      | NO   |     | NULL    |                |\n+-------+------------------+------+-----+---------+----------------+\n\nmysql&gt; desc tb_comment;\n+-------------+------------------+------+-----+---------+----------------+\n| Field       | Type             | Null | Key | Default | Extra          |\n+-------------+------------------+------+-----+---------+----------------+\n| id          | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| content     | text             | NO   |     | NULL    |                |\n| type        | tinyint(4)       | NO   |     | NULL    |                |\n| relation_id | int(10) unsigned | NO   |     | NULL    |                |\n+-------------+------------------+------+-----+---------+----------------+定义一对多关联会用到的注解：@PolymorphicOneToMany、@PolymorphicToOne、@JoinFrom、@JoinTo、@AutoSelect、@AutoInsert、@AutoUpdate、@AutoSave、@AutoDelete如 imi-demo 中代码所示，Article定义了一个$comments属性，这个属性关联Comment模型。Article中id与Comment中relation_id关联，并且type为1的才关联。Article 模型/**\n * Article\n * @Entity\n * @Table(name=&quot;tb_article&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property string $title\n * @property string $content\n * @property \\Imi\\Util\\ArrayList $comments\n * @property \\Imi\\Util\\ArrayList $taggables\n * @property \\Imi\\Util\\ArrayList $tags\n */\nclass Article extends Model\n{\n    /**\n     * id\n     * @Column(name=&quot;id&quot;, type=&quot;int&quot;, length=10, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=true, primaryKeyIndex=0, isAutoIncrement=true)\n     * @var int\n     */\n    protected $id;\n\n    /**\n     * 获取 id\n     *\n     * @return int\n     */ \n    public function getId()\n    {\n        return $this-&gt;id;\n    }\n\n    /**\n     * 赋值 id\n     * @param int $id id\n     * @return static\n     */ \n    public function setId($id)\n    {\n        $this-&gt;id = $id;\n        return $this;\n    }\n\n    /**\n     * title\n     * @Column(name=&quot;title&quot;, type=&quot;varchar&quot;, length=32, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var string\n     */\n    protected $title;\n\n    /**\n     * 获取 title\n     *\n     * @return string\n     */ \n    public function getTitle()\n    {\n        return $this-&gt;title;\n    }\n\n    /**\n     * 赋值 title\n     * @param string $title title\n     * @return static\n     */ \n    public function setTitle($title)\n    {\n        $this-&gt;title = $title;\n        return $this;\n    }\n\n    /**\n     * content\n     * @Column(name=&quot;content&quot;, type=&quot;text&quot;, length=0, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var string\n     */\n    protected $content;\n\n    /**\n     * 获取 content\n     *\n     * @return string\n     */ \n    public function getContent()\n    {\n        return $this-&gt;content;\n    }\n\n    /**\n     * 赋值 content\n     * @param string $content content\n     * @return static\n     */ \n    public function setContent($content)\n    {\n        $this-&gt;content = $content;\n        return $this;\n    }\n\n    /**\n     * 评论\n     * \n     * @PolymorphicOneToMany(model=ImiDemo\\HttpDemo\\MainServer\\Model\\Comment::class, type=&quot;type&quot;, typeValue=1)\n     * @JoinTo(&quot;relation_id&quot;)\n     * @AutoSave(orphanRemoval=true)\n     * @AutoDelete\n     *\n     * @var \\Imi\\Util\\ArrayList\n     */\n    protected $comments;\n\n    /**\n     * Get 评论\n     *\n     * @return  \\ImiDemo\\HttpDemo\\MainServer\\Model\\Comment[]\n     */ \n    public function getComments()\n    {\n        return $this-&gt;comments;\n    }\n\n    /**\n     * Set 评论\n     *\n     * @param  \\ImiDemo\\HttpDemo\\MainServer\\Model\\Comment[]  $comments  评论\n     *\n     * @return  self\n     */ \n    public function setComments($comments)\n    {\n        $this-&gt;comments = $comments;\n\n        return $this;\n    }\n    \n}主要参考$comments上的注解，与多态一对多一样。Comment 模型/**\n * Comment\n * @Entity\n * @Table(name=&quot;tb_comment&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property string $content\n * @property int $type\n * @property int $relationId\n */\nclass Comment extends Model\n{\n    /**\n     * id\n     * @Column(name=&quot;id&quot;, type=&quot;int&quot;, length=10, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=true, primaryKeyIndex=0, isAutoIncrement=true)\n     * @var int\n     */\n    protected $id;\n\n    /**\n     * 获取 id\n     *\n     * @return int\n     */ \n    public function getId()\n    {\n        return $this-&gt;id;\n    }\n\n    /**\n     * 赋值 id\n     * @param int $id id\n     * @return static\n     */ \n    public function setId($id)\n    {\n        $this-&gt;id = $id;\n        return $this;\n    }\n\n    /**\n     * content\n     * @Column(name=&quot;content&quot;, type=&quot;text&quot;, length=0, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var string\n     */\n    protected $content;\n\n    /**\n     * 获取 content\n     *\n     * @return string\n     */ \n    public function getContent()\n    {\n        return $this-&gt;content;\n    }\n\n    /**\n     * 赋值 content\n     * @param string $content content\n     * @return static\n     */ \n    public function setContent($content)\n    {\n        $this-&gt;content = $content;\n        return $this;\n    }\n\n    /**\n     * type\n     * @Column(name=&quot;type&quot;, type=&quot;tinyint&quot;, length=4, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var int\n     */\n    protected $type;\n\n    /**\n     * 获取 type\n     *\n     * @return int\n     */ \n    public function getType()\n    {\n        return $this-&gt;type;\n    }\n\n    /**\n     * 赋值 type\n     * @param int $type type\n     * @return static\n     */ \n    public function setType($type)\n    {\n        $this-&gt;type = $type;\n        return $this;\n    }\n\n    /**\n     * relation_id\n     * @Column(name=&quot;relation_id&quot;, type=&quot;int&quot;, length=10, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var int\n     */\n    protected $relationId;\n\n    /**\n     * 获取 relationId\n     *\n     * @return int\n     */ \n    public function getRelationId()\n    {\n        return $this-&gt;relationId;\n    }\n\n    /**\n     * 赋值 relationId\n     * @param int $relationId relation_id\n     * @return static\n     */ \n    public function setRelationId($relationId)\n    {\n        $this-&gt;relationId = $relationId;\n        return $this;\n    }\n\n}查询常见的增删改查就不写了，和一对多关联一样用法评论模型反查文章模型注解及用法与一对一相同"},{"id":151,"title":"多态一对一关联","pageTitle":"多态一对一关联","url":"components/orm/relation/polymorphicOneToOne.html","content":"多态一对一关联目录比如我们有一个用户表，一个团队表，他们和头像表相关联。mysql&gt; desc tb_user;\n+----------+------------------+------+-----+---------+----------------+\n| Field    | Type             | Null | Key | Default | Extra          |\n+----------+------------------+------+-----+---------+----------------+\n| id       | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| username | varchar(32)      | NO   |     | NULL    |                |\n| age      | tinyint(3)       | NO   |     | NULL    |                |\n+----------+------------------+------+-----+---------+----------------+\n\nmysql&gt; desc tb_team;\n+-------+------------------+------+-----+---------+----------------+\n| Field | Type             | Null | Key | Default | Extra          |\n+-------+------------------+------+-----+---------+----------------+\n| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| name  | varchar(32)      | NO   |     | NULL    |                |\n+-------+------------------+------+-----+---------+----------------+\n\nmysql&gt; desc tb_avatar;\n+-------------+------------------+------+-----+---------+----------------+\n| Field       | Type             | Null | Key | Default | Extra          |\n+-------------+------------------+------+-----+---------+----------------+\n| id          | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| type        | tinyint(4)       | NO   | MUL | NULL    |                |\n| relation_id | int(10) unsigned | NO   |     | NULL    |                |\n| url         | varchar(255)     | NO   |     | NULL    |                |\n+-------------+------------------+------+-----+---------+----------------+定义多态一对一关联会用到的注解：@PolymorphicOneToOne、@PolymorphicToOne、@JoinFrom、@JoinTo、@AutoSelect、@AutoInsert、@AutoUpdate、@AutoSave、@AutoDelete如 imi-demo 中代码所示，定义了一个$avatar属性，这个属性关联Avatar模型。User中id与Avatar中relation_id关联，并且type为1的才关联。User 模型/**\n * User\n * @Entity\n * @Table(name=&quot;tb_user&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property string $username\n * @property \\ImiDemo\\HttpDemo\\MainServer\\Model\\UserEx $ex\n * @property \\Imi\\Util\\ArrayList $userRole\n * @property \\Imi\\Util\\ArrayList $role\n * @property \\ImiDemo\\HttpDemo\\MainServer\\Model\\Avatar $avatar\n */\nclass User extends Model\n{\n    /**\n     * 头像\n     * \n     * @PolymorphicOneToOne(model=ImiDemo\\HttpDemo\\MainServer\\Model\\Avatar::class, type=&quot;type&quot;, typeValue=1)\n     * @JoinTo(&quot;relation_id&quot;)\n     * @AutoSave\n     * @AutoDelete\n     *\n     * @var \\ImiDemo\\HttpDemo\\MainServer\\Model\\Avatar\n     */\n    protected $avatar;\n\n    /**\n     * Get 头像\n     *\n     * @return  \\ImiDemo\\HttpDemo\\MainServer\\Model\\Avatar\n     */ \n    public function getAvatar()\n    {\n        return $this-&gt;avatar;\n    }\n\n    /**\n     * Set 头像\n     *\n     * @param  \\ImiDemo\\HttpDemo\\MainServer\\Model\\Avatar  $avatar  头像\n     *\n     * @return  self\n     */ \n    public function setAvatar(\\ImiDemo\\HttpDemo\\MainServer\\Model\\Avatar $avatar)\n    {\n        $this-&gt;avatar = $avatar;\n\n        return $this;\n    }\n\n}@PolymorphicOneToOne注解中，type代表在Avatar模型中的字段名，typeValue代表匹配的值。Avatar 模型/**\n * Avatar\n * @Entity\n * @Table(name=&quot;tb_avatar&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property int $type\n * @property int $relationId\n * @property string $url\n */\nclass Avatar extends Model\n{\n    /**\n     * id\n     * @Column(name=&quot;id&quot;, type=&quot;int&quot;, length=10, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=true, primaryKeyIndex=0, isAutoIncrement=true)\n     * @var int\n     */\n    protected $id;\n\n    /**\n     * 获取 id\n     *\n     * @return int\n     */ \n    public function getId()\n    {\n        return $this-&gt;id;\n    }\n\n    /**\n     * 赋值 id\n     * @param int $id id\n     * @return static\n     */ \n    public function setId($id)\n    {\n        $this-&gt;id = $id;\n        return $this;\n    }\n\n    /**\n     * type\n     * @Column(name=&quot;type&quot;, type=&quot;tinyint&quot;, length=4, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var int\n     */\n    protected $type;\n\n    /**\n     * 获取 type\n     *\n     * @return int\n     */ \n    public function getType()\n    {\n        return $this-&gt;type;\n    }\n\n    /**\n     * 赋值 type\n     * @param int $type type\n     * @return static\n     */ \n    public function setType($type)\n    {\n        $this-&gt;type = $type;\n        return $this;\n    }\n\n    /**\n     * relation_id\n     * @Column(name=&quot;relation_id&quot;, type=&quot;int&quot;, length=10, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var int\n     */\n    protected $relationId;\n\n    /**\n     * 获取 relationId\n     *\n     * @return int\n     */ \n    public function getRelationId()\n    {\n        return $this-&gt;relationId;\n    }\n\n    /**\n     * 赋值 relationId\n     * @param int $relationId relation_id\n     * @return static\n     */ \n    public function setRelationId($relationId)\n    {\n        $this-&gt;relationId = $relationId;\n        return $this;\n    }\n\n    /**\n     * url\n     * @Column(name=&quot;url&quot;, type=&quot;varchar&quot;, length=255, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var string\n     */\n    protected $url;\n\n    /**\n     * 获取 url\n     *\n     * @return string\n     */ \n    public function getUrl()\n    {\n        return $this-&gt;url;\n    }\n\n    /**\n     * 赋值 url\n     * @param string $url url\n     * @return static\n     */ \n    public function setUrl($url)\n    {\n        $this-&gt;url = $url;\n        return $this;\n    }\n\n    /**\n     * 对应用户\n     * \n     * @PolymorphicToOne(model=ImiDemo\\HttpDemo\\MainServer\\Model\\User::class, modelField=&quot;id&quot;, type=&quot;type&quot;, typeValue=1, field=&quot;relation_id&quot;)\n     * @AutoSelect(false)\n     *\n     * @var \\ImiDemo\\HttpDemo\\MainServer\\Model\\User\n     */\n    protected $user;\n\n    /**\n     * Get 对应用户\n     *\n     * @return  \\ImiDemo\\HttpDemo\\MainServer\\Model\\User\n     */ \n    public function getUser()\n    {\n        return $this-&gt;user;\n    }\n\n    /**\n     * Set 对应用户\n     *\n     * @param  \\ImiDemo\\HttpDemo\\MainServer\\Model\\User  $user  对应用户\n     *\n     * @return  self\n     */ \n    public function setUser(\\ImiDemo\\HttpDemo\\MainServer\\Model\\User $user)\n    {\n        $this-&gt;user = $user;\n\n        return $this;\n    }\n\n    /**\n     * 对应用户\n     * \n     * @PolymorphicToOne(model=ImiDemo\\HttpDemo\\MainServer\\Model\\Team::class, modelField=&quot;id&quot;, type=&quot;type&quot;, typeValue=2, field=&quot;relation_id&quot;)\n     * @AutoSelect(false)\n     *\n     * @var \\ImiDemo\\HttpDemo\\MainServer\\Model\\Team\n     */\n    protected $team;\n\n    /**\n     * Get 对应用户\n     *\n     * @return  \\ImiDemo\\HttpDemo\\MainServer\\Model\\Team\n     */ \n    public function getTeam()\n    {\n        return $this-&gt;team;\n    }\n\n    /**\n     * Set 对应用户\n     *\n     * @param  \\ImiDemo\\HttpDemo\\MainServer\\Model\\Team  $team  对应用户\n     *\n     * @return  self\n     */ \n    public function setTeam(\\ImiDemo\\HttpDemo\\MainServer\\Model\\Team $team)\n    {\n        $this-&gt;team = $team;\n\n        return $this;\n    }\n\n    /**\n     * 对应用户\n     * \n     * @PolymorphicToOne(model=ImiDemo\\HttpDemo\\MainServer\\Model\\User::class, modelField=&quot;id&quot;, type=&quot;type&quot;, typeValue=1, field=&quot;relation_id&quot;)\n     * @PolymorphicToOne(model=ImiDemo\\HttpDemo\\MainServer\\Model\\Team::class, modelField=&quot;id&quot;, type=&quot;type&quot;, typeValue=2, field=&quot;relation_id&quot;)\n     * @AutoSelect(false)\n     *\n     * @var \\ImiDemo\\HttpDemo\\MainServer\\Model\\User|\\ImiDemo\\HttpDemo\\MainServer\\Model\\Team\n     */\n    protected $relationModel;\n\n    /**\n     * Get 对应用户\n     *\n     * @return  \\ImiDemo\\HttpDemo\\MainServer\\Model\\User|\\ImiDemo\\HttpDemo\\MainServer\\Model\\Team\n     */ \n    public function getRelationModel()\n    {\n        return $this-&gt;relationModel;\n    }\n\n    /**\n     * Set 对应用户\n     *\n     * @param  \\ImiDemo\\HttpDemo\\MainServer\\Model\\User|\\ImiDemo\\HttpDemo\\MainServer\\Model\\Team  $relationModel  对应用户\n     *\n     * @return  self\n     */ \n    public function setRelationModel($relationModel)\n    {\n        $this-&gt;relationModel = $relationModel;\n\n        return $this;\n    }\n}Avatar 模型中，$user和$team是指定类型的关联，只能取到对应模型的数据。$relationModel会根据当前模型的type值，查询出对应模型的数据，类型不固定。查询常见的增删改查就不写了，和一对一关联一样用法头像模型反查用户模型智能类型查询$avatar = Avatar::find(1);\n$avatar-&gt;queryRelations(&#039;relationModel&#039;);\n$user = $avatar-&gt;relationModel;指定类型查询$avatar = Avatar::find(1);\n$avatar-&gt;queryRelations(&#039;user&#039;);\n$user = $avatar-&gt;user;同时查询多个$avatar = Avatar::find(1);\n$avatar-&gt;queryRelations(&#039;user&#039;, &#039;relationModel&#039;);\n$user1 = $avatar-&gt;user;\n$user2 = $avatar-&gt;relationModel;"},{"id":154,"title":"自定义关联","pageTitle":"自定义关联","url":"components/orm/relation/relation.html","content":"自定义关联在 imi 中除了一对一等传统关联以外，你还可以自定义关联处理。使用注解在属性上声明注解 @Relation (Imi\\Model\\Annotation\\Relation\\Relation) 使用自定义关联。声明关联的属性/**\n * @Relation\n *\n * @AutoSave\n *\n * @AutoDelete\n */\npublic ?array $relation = null;\n\npublic function getRelation(): ?array\n{\n    return $this-&gt;relation;\n}\n\npublic function setRelation(?array $relation): self\n{\n    $this-&gt;relation = $relation;\n\n    return $this;\n}@Relation 是必选项@AutoSave 可启用 insert 和 update 处理@AutoInsert 可单独启用 insert 处理@AutoUpdate 可单独启用 update 处理@AutoDelete 可启用 delete 处理@AutoSelect 可启用 query 处理，默认开启无需设置实现自定义关联插入在类中定义方法：// 一定要声明为 public static\n// 方法名规则：__insert + 首字母大写的属性名\npublic static function __insertRelation(self $model, \\Imi\\Model\\Annotation\\Relation\\Relation $annotation): void\n{\n    // 你可以直接操作 $model 对象，跟操作 $this 一样\n    $model-&gt;xxx = 123;\n}更新在类中定义方法：// 一定要声明为 public static\n// 方法名规则：__update + 首字母大写的属性名\npublic static function __updateRelation(self $model, \\Imi\\Model\\Annotation\\Relation\\Relation $annotation): void\n{\n    // 你可以直接操作 $model 对象，跟操作 $this 一样\n    $model-&gt;xxx = 123;\n}删除在类中定义方法：// 一定要声明为 public static\n// 方法名规则：__delete + 首字母大写的属性名\npublic static function __deleteRelation(self $model, \\Imi\\Model\\Annotation\\Relation\\Relation $annotation): void\n{\n    // 你可以直接操作 $model 对象，跟操作 $this 一样\n    $model-&gt;xxx = 123;\n}查询在类中定义方法：// 一定要声明为 public static\n// 方法名规则：__query + 首字母大写的属性名\n// 需要注意：第一个参数是模型对象属性，与上面其它操作不同\n/**\n * @param self[] $models\n */\npublic static function __queryRelation(array $models, \\Imi\\Model\\Annotation\\Relation\\Relation $annotation): void\n{\n    foreach ($models as $model)\n    {\n        // 你可以直接操作 $model 对象，跟操作 $this 一样\n        $model-&gt;xxx = 123;\n    }\n}"},{"id":145,"title":"模型软删除","pageTitle":"模型软删除","url":"components/orm/softDelete.html","content":"模型软删除目录因为种种原因，现在大部分场景下，我们开发删除功能时，都不会将记录物理删除。使用模型软删除功能非常简单，只需要在模型类中引入 trait Imi\\Model\\SoftDelete\\Traits\\TSoftDelete，并且在类上加上注解 @SoftDelete示例&lt;?php\n\nnamespace Imi\\Test\\Component\\Model;\n\nuse Imi\\Bean\\Annotation\\Inherit;\nuse Imi\\Model\\SoftDelete\\Annotation\\SoftDelete;\nuse Imi\\Model\\SoftDelete\\Traits\\TSoftDelete;\nuse Imi\\Test\\Component\\Model\\Base\\TestSoftDeleteBase;\n\n/**\n * tb_test_soft_delete.\n *\n * @Inherit\n * @SoftDelete\n */\nclass TestSoftDelete extends TestSoftDeleteBase\n{\n    use TSoftDelete;\n}注解@SoftDelete软删除类名：Imi\\Model\\SoftDelete\\Annotation\\SoftDelete属性名称说明field软删除字段名，默认值见下方说明default软删除字段的默认值，代表非删除状态，默认为0field 不设置时，默认从配置 @app.model.softDelete.fields.deleteTime 读取，如果没有配置，默认是：delete_time(imi &gt;= v2.0.16)使用imi 模型软删除，默认逻辑是非删除状态字段值为 0，删除后值为当前时间戳。你也可以自行定义字段名、默认值、删除后的值。字段名、默认值可以通过 @SoftDelete 进行设置。删除后的值可以通过覆盖模型类中的 __generateSoftDeleteValue() 方法实现：/**\n * 生成软删除字段的值\n *\n * @return mixed\n */\npublic function __generateSoftDeleteValue()\n{\n    return time();\n}查询如果模型引入了软删除机制，使用 XXXModel::find()、XXXModel::query() 等方式查询时，自动过滤被软删除的数据。如果需要查询到被软删除的数据，请使用 XXXModel::findDeleted()。如果想要查到所有数据（包括删除和未删除），可以使用 XXXModel::originQuery() 获取查询构建器。删除软删除：XXXModel::find(1)-&gt;delete();物理删除：XXXModel::find(1)-&gt;hardDelete();恢复记录恢复被软删除的记录：XXXModel::findDeleted(1)-restore();"},{"id":144,"title":"TreeModel","pageTitle":"TreeModel","url":"components/orm/TreeModel.html","content":"TreeModel目录介绍我们开发中有一些表是树形结构的，比如地区、分销关系等。imi 特地为此做了增强支持，可以非常方便地操作树形结构的数据表。定义模型引入 trait：Imi\\Model\\Tree\\TTreeModel类上加上 @TreeModel 注解，类：Imi\\Model\\Tree\\Annotation\\TreeModel属性名称说明idField主键字段名，默认为null，则自动获取parentField父级ID字段名childrenField子集字段名&lt;?php\nnamespace Imi\\Test\\Component\\Model;\n\nuse Imi\\Model\\Model;\nuse Imi\\Model\\Tree\\TTreeModel;\nuse Imi\\Model\\Annotation\\Table;\nuse Imi\\Model\\Annotation\\Column;\nuse Imi\\Model\\Annotation\\Entity;\nuse Imi\\Model\\Tree\\Annotation\\TreeModel;\nuse Imi\\Test\\Component\\Model\\Base\\TreeBase;\n\n/**\n * Tree\n * @Entity\n * @TreeModel(parentField=&quot;parent_id&quot;, childrenField=&quot;children&quot;)\n * @Table(name=&quot;tb_tree&quot;, id={&quot;id&quot;})\n */\nclass Tree extends TreeBase // TreeBase 为通过 generate/model 工具生成出来的基类\n{\n    use TTreeModel;\n\n    /**\n     * 子节点集合\n     * \n     * @Column(virtual=true)\n     *\n     * @var static[]\n     */\n    protected $children = [];\n\n    /**\n     * Get 子节点集合\n     *\n     * @return static[]\n     */ \n    public function &amp;getChildren()\n    {\n        return $this-&gt;children;\n    }\n\n    /**\n     * Set 子节点集合\n     *\n     * @param static[] $children\n     *\n     * @return self\n     */ \n    public function setChildren($children)\n    {\n        $this-&gt;children = $children;\n\n        return $this;\n    }\n\n}使用方法列表getChildIds获取一级子节点的ID们$item = Tree::find(1);\n$ids = $item-&gt;getChildIds(); // 当前对象子节点\n$ids = $item-&gt;getChildIds(123); // 指定 ID 子节点getChildrenIds获取下属 N 级子节点的ID非递归实现，相比递归实现性能更高，更省内存$item = Tree::find(1);\n$item-&gt;getChildrenIds(null, true); // 包含父级ID（1）\n$item-&gt;getChildrenIds(); // 不包含父级ID（1）\n$item-&gt;getChildrenIds(123, false, 1); // 不包含父级ID（123），限制获取子层级为1级getChildrenList获取子成员对象列表，可以指定层级，默认无限级$item = Tree::find(1);\n$tree = $item-&gt;getChildrenList(); // 获取父级ID（1）下所有记录\n$tree = $item-&gt;getChildrenList(null, 1); // 获取父级ID（1）下所有记录，层级1级\n$tree = $item-&gt;getChildrenList(123, 1); // 获取父级ID（123）下所有记录，层级1级\ngetParent获取父级对象$item = Tree::find(1);\n$parentItem = $item-&gt;getParent();getParents获取所有父级对象列表$item = Tree::find(1);\n$parentItemList = $item-&gt;getParents();getAssocList获取关联列表，@TreeModel注解中配置的childrenField属性生效，放入配置的属性中$list = Tree::getAssocList(); // 所有数据\n\n// 指定只显示 ID 为 1、2、3 的数据，他们之间如果有上下级关系，会在 children 属性中体现\n$query = Tree::query()-&gt;whereIn(&#039;id&#039;, [1, 2, 3]);\n$list = Tree::getAssocList($query);\n$children = $list[0]-&gt;children; // $children 与 $list 结构相同"},{"id":186,"title":"Phar 支持","pageTitle":"Phar 支持","url":"components/phar/index.html","content":"Phar 支持目录imi v2.1.4 已经实验性支持了 Phar 模式运行。打包为 Phar 文件后，可以单文件部署非常方便，再配合 swoole-cli 可谓是如虎添翼。安装composer require --dev imiphp/imi-phar快速开始\n# 切换到需要打包的项目目录\ncd ~/my-xxx-project\n\n# 首次运行需初始化打包配置，将在项目目录下创建默认的`imi-phar-cfg.php`配置，建议把文件添加到代码仓库\nvendor/bin/imi-phar build --init\n\n# 执行打包命令，`xxx`为要打包容器，内置`swoole、workerman、roadrunner`容器支持，更多细节查看配置说明\nvendor/bin/imi-phar build xxx\n\n# 查看目录下的`build`目录获得打包的可执行`phar`文件\n./build/imi.phar\n更多命令行细节执行vendor/bin/imi-phar -h参考。打包特性打包后将初始化一些工作常量，详情查看 内置常量列表配置说明该配置文件中所声明的目录或文件，无特殊说明均是基于该配置所在工作目录中的相对路径，请勿填写绝对路径。如果文档中的配置与vendor/bin/imi-phar --init生成的配置文件不一致，建议以生成的配置为准。配置文件中用到的文件过滤器使用规则均由symfony/finder提供，更多细节可看 finder doc。[\n    // 构建产物\n    &#039;output&#039;       =&gt; &#039;build/imi.phar&#039;,\n\n    // 参与打包的文件\n    // 可选值：\n    //   - &#039;*&#039;自动包含根目录下的 *.php、*.macro 文件。（默认）\n    //   - 空数组不包含任何文件。\n    //   - 定义数组并填入文件名（仅限于当前目录下的文件）。\n    &#039;files&#039;        =&gt; &#039;*&#039;,\n\n    // 参与打包的目录\n    &#039;dirs&#039;         =&gt; [\n        // 参与打包的目录\n        // 可选值：\n        //   - &#039;*&#039;自动包含根目录除`vendor`以外的目录。（默认）\n        //   - 空数组不包含任何目录。\n        //   - 定义数组并填入目录名名（仅限于当前目录下的目录名）。\n        &#039;in&#039; =&gt; &#039;*&#039;,\n        // 要排除的目录，仅对 dirs 扫描到的内容有作用。（使用参考 symfony/finder-&gt;exclude）\n        &#039;excludeDirs&#039;  =&gt; [],\n        // 要排除的文件，仅对 dirs 扫描到的内容有作用。（使用参考 symfony/finder-&gt;notName）\n        &#039;excludeFiles&#039; =&gt; [],\n    ],\n\n    // 包含 vendor 目录\n    // 可选值：\n    //   - true  : 打包 vendor 中的文件（默认）\n    //   - false : 不打包 vendor 中的文件\n    //   - symfony/finder 实例 : 完全自定义如何获得文件\n    // 无特殊情况勿动\n    &#039;vendorScan&#039;   =&gt; true,\n\n    // 传入 symfony/finder 实例，支持多个，完全自定义扫描的内容。\n    &#039;finder&#039; =&gt; [],\n\n    // 是否转存构建时的 git 信息\n    &#039;dumpGitInfo&#039; =&gt; true,\n\n    // 自定义启动入口\n    // 如果该处提供入口参数，命令行打包时可不传入\n    // 如果命令行输入参数`container`，则覆盖该选项值\n    // 如果指定一个有效的 php 文件文件则可以完全控制入口\n    // 可选值：\n    //   - swoole\n    //   - workerman\n    //   - roadrunner\n    //   - 当前目录下的一个有效 php 文件\n    &#039;bootstrap&#039; =&gt; null,\n\n    // 压缩算法，一旦启用压缩，则执行环境也必须加载对应的依赖库\n    // 由于 PHP 内核 BUG，该选项暂时屏蔽\n    // 可选值：\n    //   - \\Phar::NONE : 不压缩\n    //   - \\Phar::GZ   : 必须启用扩展 zlib\n    //   - \\Phar::BZ2  : 必须启用扩展 bzip2\n    &#039;compression&#039; =&gt; \\Phar::NONE,\n\n    // 构建配置\n    &#039;build&#039;             =&gt; [\n        &#039;before&#039; =&gt; static function () {\n            // 构建前执行的代码\n        },\n        &#039;after&#039;  =&gt; static function () {\n            // 构建后执行的代码\n        },\n    ],\n\n    // 资源文件配置\n    &#039;resources&#039;         =&gt; [\n        &#039;files&#039;             =&gt; [\n            &#039;a.txt&#039;, // 将 a.txt 输出到 build/a.txt\n            &#039;a.txt&#039; =&gt; &#039;b.txt&#039;, // 将 a.txt 输出到 build/b.txt\n        ],\n        // 可选值：\n        //   - 空数组不包含任何目录。\n        //   - 定义数组并填入目录名（仅限于当前目录下的目录名）。\n        &#039;in&#039;                =&gt; [],\n        // 要排除的目录，仅对 dirs 扫描到的内容有作用。\n        &#039;excludeDirs&#039;       =&gt; [],\n        // 要排除的文件，仅对 dirs 扫描到的内容有作用。\n        &#039;excludeFiles&#039;      =&gt; [],\n    ],\n]finder 的使用支持在配置文件中支持声明finder实例数组。例子，禁用内置文件扫描器，提供一个忽略png与pdf的文件扫描器：return [\n[\n    &#039;output&#039;       =&gt; &#039;build/imi.phar&#039;,\n    &#039;files&#039;        =&gt; [],\n    &#039;dirs&#039;         =&gt; [\n        &#039;in&#039; =&gt; [],\n        &#039;excludeDirs&#039;  =&gt; [],\n        &#039;excludeFiles&#039; =&gt; [],\n    ],\n    &#039;vendorScan&#039;   =&gt; false,\n    &#039;finder&#039; =&gt; [\n        (new Symfony\\Component\\Finder\\Finder())\n            -&gt;in(__DIR__)\n            -&gt;notName([&#039;*.png&#039;, &#039;*.pdf&#039;])\n            -&gt;files()\n    ],\n]默认过滤器过滤规则任何以点开头的文件都会被忽略，如果想这类型的文件，请使用files选项指定或自行提供finder实例。vsc目录都将被忽略[&#039;.svn&#039;, &#039;_svn&#039;, &#039;CVS&#039;, &#039;_darcs&#039;, &#039;.arch-params&#039;, &#039;.monotone&#039;, &#039;.bzr&#039;, &#039;.git&#039;, &#039;.hg&#039;]。内置过滤器(项目)// https://github.com/box-project/box/blob/e2cbc2424c0c4b97b626653c7f8ff8029282b9aa/src/Configuration/Configuration.php#L1478\n// Remove build files\n-&gt;notName(&#039;composer.json&#039;)\n-&gt;notName(&#039;composer.lock&#039;)\n-&gt;notName(&#039;Makefile&#039;)\n-&gt;notName(&#039;Vagrantfile&#039;)\n-&gt;notName(&#039;phpstan*.neon*&#039;)\n-&gt;notName(&#039;infection*.json*&#039;)\n-&gt;notName(&#039;humbug*.json*&#039;)\n-&gt;notName(&#039;easy-coding-standard.neon*&#039;)\n-&gt;notName(&#039;phpbench.json*&#039;)\n-&gt;notName(&#039;phpcs.xml*&#039;)\n-&gt;notName(&#039;psalm.xml*&#039;)\n-&gt;notName(&#039;scoper.inc*&#039;)\n-&gt;notName(&#039;box*.json*&#039;)\n-&gt;notName(&#039;phpdoc*.xml*&#039;)\n-&gt;notName(&#039;codecov.yml*&#039;)\n-&gt;notName(&#039;Dockerfile&#039;)\n-&gt;exclude(&#039;build&#039;)\n-&gt;exclude(&#039;dist&#039;)\n-&gt;exclude(&#039;example&#039;)\n-&gt;exclude(&#039;examples&#039;)\n// Remove documentation\n-&gt;notName(&#039;*.md&#039;)\n-&gt;notName(&#039;*.rst&#039;)\n-&gt;notName(&#039;/^readme((?!\\.php)(\\..*+))?$/i&#039;)\n-&gt;notName(&#039;/^upgrade((?!\\.php)(\\..*+))?$/i&#039;)\n-&gt;notName(&#039;/^contributing((?!\\.php)(\\..*+))?$/i&#039;)\n-&gt;notName(&#039;/^changelog((?!\\.php)(\\..*+))?$/i&#039;)\n-&gt;notName(&#039;/^authors?((?!\\.php)(\\..*+))?$/i&#039;)\n-&gt;notName(&#039;/^conduct((?!\\.php)(\\..*+))?$/i&#039;)\n-&gt;notName(&#039;/^todo((?!\\.php)(\\..*+))?$/i&#039;)\n-&gt;exclude(&#039;doc&#039;)\n-&gt;exclude(&#039;docs&#039;)\n-&gt;exclude(&#039;documentation&#039;)\n// Remove backup files\n-&gt;notName(&#039;*~&#039;)\n-&gt;notName(&#039;*.back&#039;)\n-&gt;notName(&#039;*.swp&#039;)\n// Remove tests\n-&gt;notName(&#039;*Test.php&#039;)\n-&gt;exclude(&#039;test&#039;)\n-&gt;exclude(&#039;Test&#039;)\n-&gt;exclude(&#039;tests&#039;)\n-&gt;exclude(&#039;Tests&#039;)\n-&gt;notName(&#039;/phpunit.*\\.xml(.dist)?/&#039;)\n-&gt;notName(&#039;/behat.*\\.yml(.dist)?/&#039;)\n-&gt;exclude(&#039;spec&#039;)\n-&gt;exclude(&#039;specs&#039;)\n-&gt;exclude(&#039;features&#039;)\n// Remove CI config\n-&gt;exclude(&#039;travis&#039;)\n-&gt;notName(&#039;travis.yml&#039;)\n-&gt;notName(&#039;appveyor.yml&#039;)\n-&gt;notName(&#039;build.xml*&#039;)内置过滤器(vendor)-&gt;notName([&#039;/LICENSE|.*\\\\.md|.*\\\\.dist|Makefile/&#039;, &#039;*.macro.php&#039;])\n-&gt;exclude([\n    &#039;doc&#039;,\n    &#039;test&#039;,\n    &#039;test_old&#039;,\n    &#039;tests&#039;,\n    &#039;Tests&#039;,\n    &#039;vendor-bin&#039;,\n    &#039;vendor/bin&#039;,\n]);注意事项不要在配置文件中，使用 __DIR__、__FILE__ 等方式，指定物理路径，比如日志保存目录，而应该使用 \\Imi\\App::get(\\Imi\\AppContexts::APP_PATH_PHYSICS)默认打包文件路径是 build/imi.phar，如果运行不要忘记把 .env 文件（如果有）复制进去"},{"id":127,"title":"连接池","pageTitle":"连接池","url":"components/pool/index.html","content":"连接池目录由于 Swoole 的常驻内存特性，所以 imi 中实现了连接池。所有的数据库、Redis连接，都通过连接池去获取。定义连接池连接池的配置，可以写在项目配置文件中，也可以写在服务器配置文件中。在配置文件中有一个pools节点，里面配置的是连接池。同步池子仅在task进程使用，异步池子在worker进程使用。一般使用时无需自行判断在哪个进程，框架会自动帮你获取对应的连接。连接池配置选项说明类型默认值maxResources池子中最多资源数int10minResources池子中最少资源数int1gcInterval资源回收时间间隔，单位：秒，null则不限制?int60maxActiveTime获取资源最大存活时间，单位：秒，null则不限制?intnullwaitTimeout等待资源最大超时时间，单位：毫秒int3000heartbeatInterval心跳时间间隔，单位：秒，null则不启用?floatnullcheckStateWhenGetResource当获取资源时是否检查状态，单位：秒，null则不限制booltruemaxUsedTime每次获取资源最长使用时间，单位：秒，null则不限制?floatnullmaxIdleTime资源创建后最大空闲回收时间，单位：秒，null则不限制?floatnullrequestResourceCheckInterval当前请求上下文资源检查状态间隔float30resourceConfigMode负载均衡模式，ROUND_ROBIN：轮询、RANDOM：随机intImi\\Pool\\ResourceConfigMode::ROUND_ROBIN获取连接获取池子中的资源\\Imi\\Pool\\PoolManager::getResource(string $name): IPoolResource$name 为池子名称获取请求上下文资源一个请求上下文通过此方法，只能获取同一个资源\\Imi\\Pool\\PoolManager::getRequestContextResource(string $name): IPoolResource尝试获取资源\\Imi\\Pool\\PoolManager::tryGetResource(string $name): IPoolResource|boolean回调方式使用资源使用回调来使用池子中的资源，无需手动释放$result = \\Imi\\Pool\\PoolManager::use($poolName, function($resource, \\Swoole\\Coroutine\\Redis $redis) use($key){\n    return $redis-&gt;get($key);\n});$poolName-池子名称第二个参数为回调，接收两个参数，第一个资源本身，第二个为资源里面的实例。比如上面的是Redis回调的返回值也会成为use方法的返回值手动释放连接\\Imi\\Pool\\PoolManager::releaseResource(IPoolResource $resource)自动释放连接调用\\Imi\\Pool\\PoolManager::getRequestContextResource()方法获取，当上下文被销毁时，会自动释放资源。"},{"id":179,"title":"进程","pageTitle":"进程","url":"components/process/index.html","content":"进程目录imi 中对进程的创建和运行做了简单封装。定义进程&lt;?php\nnamespace ImiDemo\\HttpDemo\\MainServer\\Process;\n\nuse Imi\\Swoole\\Process\\BaseProcess;\nuse Imi\\Swoole\\Process\\Annotation\\Process;\n\n/**\n * 定义进程tp1\n * @Process(&quot;tp1&quot;)\n */\nclass TestProcess extends BaseProcess\n{\n    public function run(\\Swoole\\Process $process): void\n    {\n        var_dump($this-&gt;data);\n        sleep(3);\n        var_dump(&#039;testProcess&#039;);\n    }\n}释放连接池因为我们有些进程是用不到，或者不需要所有进程池的。进程池资源连着也是浪费，所以提供一个注解，用以释放。在 run() 方法上使用 @PoolClean 注解即可，类：Imi\\Pool\\Annotation\\PoolClean@PoolClean 参数：mode 模式，allow-白名单，deny-黑名单list=[] 连接池名称列表。mode=allow则为保留的连接池，mode=deny则为关闭的连接池注解@Process/**\n * 进程名称\n * @var string\n */\npublic $name;\n\n/**\n * 重定向子进程的标准输入和输出。启用此选项后，在子进程内输出内容将不是打印屏幕，而是写入到主进程管道。读取键盘输入将变为从管道中读取数据。默认为阻塞读取。\n * @var boolean\n */\npublic $redirectStdinStdout = false;\n\n/**\n * 管道类型，启用$redirectStdinStdout后，此选项将忽略用户参数，强制为1。如果子进程内没有进程间通信，可以设置为 0\n * @var int\n */\npublic $pipeType = 2;\n\n/**\n * 自动开启协程\n * @var bool\n */\npublic $co = true;创建进程通过注解中的进程名称创建进程，返回\\Swoole\\Process类型的对象，需要手动调用start()方法来运行进程。/**\n * 创建进程\n * 本方法无法在控制器中使用\n * 返回\\Swoole\\Process对象实例\n * \n * @param string $name\n * @param array $args\n * @param boolean $redirectStdinStdout\n * @param int $pipeType\n * @return \\Swoole\\Process\n */\nProcessManager::create($name, $args = [], $redirectStdinStdout = null, $pipeType = null): \\Swoole\\Process运行进程，同步阻塞等待进程执行返回/**\n * 运行进程，同步阻塞等待进程执行返回\n * 不返回\\Swoole\\Process对象实例\n * 执行失败返回false，执行成功返回数组，包含了进程退出的状态码、信号、输出内容。\n * array(\n *     &#039;code&#039; =&gt; 0,\n *     &#039;signal&#039; =&gt; 0,\n *     &#039;output&#039; =&gt; &#039;&#039;,\n * );\n *\n * @param string $name\n * @param array $args\n * @param boolean $redirectStdinStdout\n * @param int $pipeType\n * @return array\n */\nProcessManager::run($name, $args = [], $redirectStdinStdout = null, $pipeType = null)运行进程，创建一个协程执行进程，无法获取进程执行结果/**\n * 运行进程，创建一个协程执行进程，无法获取进程执行结果\n * 执行失败返回false，执行成功返回数组，包含了进程退出的状态码、信号、输出内容。\n * array(\n *     &#039;code&#039; =&gt; 0,\n *     &#039;signal&#039; =&gt; 0,\n *     &#039;output&#039; =&gt; &#039;&#039;,\n * );\n *\n * @param string $name\n * @param array $args\n * @param boolean $redirectStdinStdout\n * @param int $pipeType\n * @return void\n */\nProcessManager::coRun($name, $args = [], $redirectStdinStdout = null, $pipeType = null)运行进程，托管到 Manager 进程这个用法只能在IMI.SERVERS.CREATE.AFTER事件中使用！/**\n * 挂靠Manager进程运行进程\n *\n * @param string $name\n * @param array $args\n * @param boolean $redirectStdinStdout\n * @param int $pipeType\n * @return void\n */\npublic static function runWithManager($name, $args = [], $redirectStdinStdout = null, $pipeType = null)进程随服务启动在项目配置文件中配置beans节：[\n    &#039;AutoRunProcessManager&#039; =&gt;  [\n        &#039;processes&#039; =&gt;  [\n            // 方式一：最简单用法，@Process 注解定义的进程名称\n            &#039;XXXProcess&#039;,\n            // 方式二：支持指定参数\n            &#039;A&#039; =&gt;  [\n                &#039;process&#039;   =&gt;  &#039;XXXProcess&#039;, // @Process 注解定义的进程名称\n                &#039;args&#039;      =&gt;  [&#039;id&#039; =&gt; 123],\n            ],\n        ],\n    ],\n]获取随服务启动的进程对象use \\Imi\\Swoole\\Process\\ProcessManager;\n/** @var \\Swoole\\Process $process */\n$process = ProcessManager::getProcessWithManager(&#039;processName&#039;);设置异步信号监听\\Imi\\Swoole\\Process\\Process::signal(SIGTERM, function($signo) {\n     echo &quot;shutdown.&quot;;\n});"},{"id":181,"title":"进程池-imi","pageTitle":"进程池-imi","url":"components/process-pool/imi.html","content":"进程池-imi目录imi 实现了一个可以替代 Swoole 进程池的更强大的进程池。支持信号监听、重启进程（可指定）、Pool Master 与 Worker 消息通讯等。基于 Swoole\\Process 实现，内部已实现了信号监听。使用$workerNum = 4;\n$processPool = new \\Imi\\Swoole\\Process\\Pool($workerNum);\n// 初始化事件-可选\n$processPool-&gt;on(&#039;Init&#039;, function(\\Imi\\Swoole\\Process\\Pool\\InitEventParam $e){\n    var_dump(&#039;init&#039;);\n});\n// 工作进程开始事件-必选\n$processPool-&gt;on(&#039;WorkerStart&#039;, function(\\Imi\\Swoole\\Process\\Pool\\WorkerEventParam $e){\n    // 业务代码写这\n    while(true)\n    {\n        // 给 master 进程发消息\n        $e-&gt;getWorker()-&gt;sendMessage(&#039;test&#039;, [\n            &#039;time&#039;  =&gt;  time(),\n        ]);\n        sleep(3);\n    }\n});\n// 工作进程退出事件-可选\n$processPool-&gt;on(&#039;WorkerExit&#039;, function(\\Imi\\Swoole\\Process\\Pool\\WorkerEventParam $e){\n    // 做一些释放操作\n});\n// 工作进程停止事件-可选\n$processPool-&gt;on(&#039;WorkerStop&#039;, function(\\Imi\\Swoole\\Process\\Pool\\WorkerEventParam $e){\n\n});\n// 工作进程接收到消息事件-可选\n$processPool-&gt;on(&#039;Message&#039;, function(\\Imi\\Swoole\\Process\\Pool\\MessageEventParam $e){\n    $data = $e-&gt;getData();\n     // $data[&#039;a&#039;] 约定是操作名，其它成员为参数\n    switch($data[&#039;a&#039;])\n    {\n        case &#039;test&#039;:\n            // 做一些事\n            var_dump($e-&gt;getWorkerId() . &#039;:&#039; . $data[&#039;time&#039;]);\n            break;\n    }\n});\n$processPool-&gt;start(); // 启动\n// $processPool-&gt;shutdown(); // 停止\n$processPool-&gt;wait(); // 阻塞等待进程池结束，成功返回 true\n$processPool-&gt;wait(false); // 不阻塞等待，成功返回 true重启进程重启所有进程：$processPool-&gt;restartAllWorker();重启部分进程：// 重启 workerId 为 0、3 的进程\n$processPool-&gt;restartWorker(0, 3);"},{"id":180,"title":"进程池-Swoole","pageTitle":"进程池-Swoole","url":"components/process-pool/swoole.html","content":"进程池-Swoole目录imi 中对进程池的创建和运行做了简单封装，基于Swoole\\Process\\Pool实现。定义进程池&lt;?php\nnamespace XinchengApi\\api\\ProcessPool;\n\nuse Imi\\Swoole\\Process\\Annotation\\ProcessPool;\n\n/**\n * @ProcessPool(name=&quot;进程名称&quot;)\n */\nclass Sms extends \\Imi\\Swoole\\Process\\BasePoolProcess\n{\n    public function run(\\Swoole\\Process\\Pool $pool, int $workerId, $name, $workerNum, $args, $ipcType, $msgQueueKey)\n    {\n        // 做一些事情\n    }\n}释放连接池因为我们有些进程是用不到，或者不需要所有进程池的。进程池资源连着也是浪费，所有提供一个注解，用以释放。在 run() 方法上使用 @PoolClean 注解即可，类：Imi\\Pool\\Annotation\\PoolClean@PoolClean 参数：mode 模式，allow-白名单，deny-黑名单list=[] 连接池名称列表。mode=allow则为保留的连接池，mode=deny则为关闭的连接池注解@ProcessPool/**\n * 进程池名称\n * @var string\n */\npublic $name;\n\n/**\n * 进程数量\n *\n * @var int\n */\npublic $workerNum = 1;\n\n/**\n * 进程间通信的模式，默认为0表示不使用任何进程间通信特性\n *\n * @var integer\n */\npublic $ipcType = 0;\n\n/**\n * 消息队列key\n *\n * @var string\n */\npublic $msgQueueKey = null;创建进程池通过注解中的进程名称创建进程，返回\\Swoole\\Process类型的对象，需要手动调用start()方法来运行进程。/**\n * 创建进程池\n * 本方法无法在控制器中使用\n * 返回\\Swoole\\Process\\Pool对象实例\n * \n * @param string $name\n * @param int $workerNum 指定工作进程的数量\n * @param array $args\n * @param int $ipcType 进程间通信的模式，默认为0表示不使用任何进程间通信特性\n * @param string $msgQueueKey\n * @return \\Swoole\\Process\\Pool\n */\npublic static function create($name, $workerNum = null, $args = [], $ipcType = 0, $msgQueueKey = null): \\Swoole\\Process\\Pool启动连接池进程命令：bin/imi-swoole process/pool 进程名其它参数可加上-h参数查看"},{"id":223,"title":"限流","pageTitle":"限流","url":"components/rate-limit.html","content":"限流目录介绍imi-rate-limit 是 imi 框架的限流组件，基于 bandwidth-throttle/token-bucket 开发。本组件仅支持使用 Redis 作为中间件，可以针对方法、接口设置限流，通过设置总容量、单位时间内生成填充的数量、每次扣除数量实现限流。Composer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-rate-limit&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用阿里云集群用户，请把 script_check_enable 设置改为 0在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入本组件\n        &#039;RateLimit&#039;    =&gt;  &#039;Imi\\RateLimit&#039;,\n    ],\n    &#039;pools&#039;    =&gt;    [\n        // 一定得要配置 Redis 连接池才可以用\n    ],\n    &#039;redis&#039; =&gt;  [\n        &#039;defaultPool&#039;   =&gt;  &#039;redis连接池名称&#039;,\n    ],\n]使用：/**\n * 限制每秒同时访问 3 次\n * \n * @Action\n * \n * @RateLimit(name=&quot;test1&quot;, capacity=3)\n *\n * @return void\n */\npublic function test1()\n{\n    return [\n        &#039;data&#039;  =&gt;  &#039;test1&#039;,\n    ];\n}\n\n/**\n * 限制每秒同时访问 1 次，等待解除限制后继续执行，超时时间为 1 秒\n * \n * @Action\n * \n * @RateLimit(name=&quot;test2&quot;, capacity=1)\n * @BlockingConsumer(1)\n *\n * @return void\n */\npublic function test2()\n{\n    return [\n        &#039;data&#039;  =&gt;  &#039;test2&#039;,\n    ];\n}\n\n/**\n * 总容量为 1000，每毫秒填充 1，每次调用扣除 500\n * \n * 自定义处理限制\n * \n * @Action\n * \n * @RateLimit(name=&quot;test3&quot;, capacity=1000, fill=1, unit=&quot;millisecond&quot;, deduct=500, callback=&quot;\\ImiDemo\\HttpDemo\\Util\\RateLimitParser::parse&quot;)\n *\n * @return void\n */\npublic function test3()\n{\n    return [\n        &#039;data&#039;  =&gt;  &#039;test3&#039;,\n    ];\n}\n\n/**\n * 手动调用限流\n * \n * 总容量为 1000，每毫秒填充 1，每次调用扣除 500\n *\n * @Action\n * \n * @return void\n */\npublic function test4()\n{\n    if(true !== $result = RateLimiter::limit(&#039;test4&#039;, 1000, function(){\n        // 自定义回调中的返回值，会作为原方法的返回值被返回\n        return [\n            &#039;message&#039;   =&gt;  &#039;自定义触发限流返回内容&#039;,\n        ];\n    }, 1, &#039;millisecond&#039;, 500))\n    {\n        return $result;\n    }\n    return [\n        &#039;data&#039;  =&gt;  &#039;test4&#039;,\n    ];\n}\n\n/**\n * 手动调用限流\n * \n * 限制每秒同时访问 1 次，等待解除限制后继续执行，超时时间为 1 秒\n *\n * @Action\n * \n * @return void\n */\npublic function test5()\n{\n    if(true !== $result = RateLimiter::limitBlock(&#039;test5&#039;, 1, function(){\n        // 自定义回调中的返回值，会作为原方法的返回值被返回\n        return [\n            &#039;message&#039;   =&gt;  &#039;自定义触发限流返回内容&#039;,\n        ];\n    }, 1, 1, &#039;second&#039;, 1))\n    {\n        return $result;\n    }\n    return [\n        &#039;data&#039;  =&gt;  &#039;test5&#039;,\n    ];\n}"},{"id":157,"title":"Redis","pageTitle":"Redis","url":"components/redis/index.html","content":"Redis目录Redis 连接池配置方式已经在连接池里讲过，这里就不重复了，直接说使用方法。连接池配置连接池适用于 Swoole 环境标准写法：从 imi v1.2.1 版本开始支持\n&lt;?php\nreturn [\n    &#039;redis&#039;    =&gt; [\n        &#039;defaultPool&#039;             =&gt; &#039;alias1&#039;, // 默认连接池\n        &#039;quickFromRequestContext&#039; =&gt; true, // 从当前上下文中获取公用连接\n    ],\n    &#039;pools&#039; =&gt; [\n        // 连接池名称\n        &#039;alias1&#039; =&gt; [\n            &#039;pool&#039; =&gt; [\n                // 协程池类名\n                &#039;class&#039;    =&gt;    \\Imi\\Swoole\\Redis\\Pool\\CoroutineRedisPool::class,\n                // 同步池类名，一般用不着\n                // &#039;class&#039;     =&gt;    \\Imi\\Redis\\SyncRedisPool::class,\n                &#039;config&#039; =&gt; [\n                    // 池子中最多资源数\n                    // &#039;maxResources&#039; =&gt; 10,\n                    // 池子中最少资源数\n                    // &#039;minResources&#039; =&gt; 2,\n                    // 资源回收时间间隔，单位：秒\n                    // &#039;gcInterval&#039; =&gt; 60,\n                    // 获取资源最大存活时间，单位：秒\n                    // &#039;maxActiveTime&#039; =&gt; 3600,\n                    // 等待资源最大超时时间，单位：毫秒\n                    // &#039;waitTimeout&#039; =&gt; 3000,\n                    // 心跳时间间隔，单位：秒\n                    // &#039;heartbeatInterval&#039; =&gt; null,\n                    // 当获取资源时，是否检查状态\n                    // &#039;checkStateWhenGetResource&#039; =&gt; true,\n                    // 每次获取资源最长使用时间，单位：秒；为 null 则不限制\n                    // &#039;maxUsedTime&#039; =&gt; null,\n                    // 资源创建后最大空闲回收时间，单位：秒；为 null 则不限制\n                    // &#039;maxIdleTime&#039; =&gt; null,\n                    // 当前请求上下文资源检查状态间隔，单位：支持小数的秒；为 null 则不限制\n                    // &#039;requestResourceCheckInterval&#039; =&gt; 30,\n                    // 负载均衡-轮询\n                    // &#039;resourceConfigMode&#039; =&gt; ResourceConfigMode::ROUND_ROBIN,\n                    // 负载均衡-随机\n                    // &#039;resourceConfigMode&#039; =&gt; ResourceConfigMode::RANDOM,\n                ],\n            ],\n            // 数组资源配置\n            &#039;resource&#039; =&gt; [\n                // --- 单机模式配置 ---\n                // &#039;mode&#039; =&gt; \\Imi\\Redis\\Enum\\RedisMode::STANDALONE,\n\n                // --- Tcp 连接参数示范 ---\n                // &#039;host&#039;    =&gt;    &#039;127.0.0.1&#039;,\n                // &#039;port&#039;    =&gt;    6379,\n                // --- Unix Socket 连接参数示范（仅支持单机模式） ---\n                // &#039;host&#039;    =&gt;    &#039;/var/run/redis/redis-server.sock&#039;,\n\n                // 是否自动序列化变量\n                // &#039;serialize&#039;    =&gt;    true,\n                // 密码\n                // &#039;password&#039;    =&gt;    null,\n                // 第几个库\n                // &#039;db&#039;    =&gt;    0,\n\n                // --- 哨兵模式配置 ---\n                &#039;mode&#039; =&gt; \\Imi\\Redis\\Enum\\RedisMode::SENTINEL,\n                &#039;master&#039; =&gt; &#039;master 名称&#039;,\n                &#039;nodes&#039; =&gt; [\n                    // 支持两种格式\n                    // 格式一\n                    &#039;127.0.0.1:6379&#039;,\n                    // 格式二\n                    [\n                        &#039;host&#039; =&gt; &#039;127.0.0.1&#039;\n                        &#039;port&#039; =&gt; 6379,\n                    ],\n                ],\n                &#039;timeout&#039; =&gt; null,\n                &#039;retryInterval&#039; =&gt; null,\n                &#039;readTimeout&#039; =&gt; null,\n\n                // --- 集群模式配置 ---\n                &#039;mode&#039; =&gt; \\Imi\\Redis\\Enum\\RedisMode::CLUSTER,\n                &#039;seeds&#039; =&gt; [\n                    &#039;127.0.0.1:6379&#039;,\n                    &#039;127.0.0.1:6380&#039;,\n                ],\n                &#039;name&#039; =&gt; null,\n                &#039;persistent&#039; =&gt; null,\n                &#039;timeout&#039; =&gt; null,\n                &#039;readTimeout&#039; =&gt; null,\n            ],\n            // uri资源配置，以分号;分隔多个，参数使用query参数格式，特殊字符需要转码\n            // &#039;resource&#039;  =&gt;  &#039;tcp://192.168.0.222?timeout=60&amp;db=1;tcp://192.168.0.222&#039;,\n            // uri资源配置，Unix Socket 连接参数示范（仅支持单机模式）\n            // &#039;resource&#039;  =&gt;  &#039;unix:///var/run/redis/redis-server.sock?db=1&#039;,\n        ],\n    ],\n];单例配置用于 php-fpm、Workerman 下&lt;?php\n\nreturn [\n    &#039;redis&#039;    =&gt;    [\n        &#039;defaultPool&#039;    =&gt;    &#039;alias1&#039;, // 默认连接名\n        &#039;quickFromRequestContext&#039;    =&gt;    true, // 从当前上下文中获取公用连接\n        &#039;connections&#039;   =&gt; [\n            &#039;alias1&#039; =&gt; [\n                // --- Tcp 连接参数示范 ---\n                // &#039;host&#039;    =&gt;    &#039;127.0.0.1&#039;,\n                // &#039;port&#039;    =&gt;    6379,\n                // --- Unix Socket 连接参数示范（仅支持单机模式） ---\n                // &#039;host&#039;    =&gt;    &#039;/var/run/redis/redis-server.sock&#039;,\n\n                // 是否自动序列化变量\n                // &#039;serialize&#039;    =&gt;    true,\n                // 密码\n                // &#039;password&#039;    =&gt;    null,\n                // 第几个库\n                // &#039;db&#039;    =&gt;    0,\n                // 当获取资源时，是否检查状态\n                // &#039;checkStateWhenGetResource&#039; =&gt; true,\n                // 心跳时间间隔，单位：秒\n                // &#039;heartbeatInterval&#039; =&gt; null,\n            ],\n        ],\n    ],\n];基本使用与原生 Redis 类操作方式基本一致，这里无需多说。获取对象use \\Imi\\Redis\\RedisManager;\n$redis = RedisManager::getInstance();\n$redis-&gt;set(&#039;imi:redis:test&#039;, date(&#039;Y-m-d H:i:s&#039;));\n$datetime = $redis-&gt;get(&#039;imi:redis:test&#039;);获取新对象每次调用都尝试从连接池中获取新的对象，要注意每次用完需要手动释放！use \\Imi\\Redis\\RedisManager;\n$redis = RedisManager::getNewInstance();\n// $redis = RedisManager::getNewInstance($poolName);\nRedisManager::release($redis);获取默认连接池名称use \\Imi\\Redis\\RedisManager;\necho RedisManager::getDefaultPoolName();便捷操作Redis::方法名()use \\Imi\\Redis\\Redis;\nRedis::set(&#039;imi:redis:test&#039;, date(&#039;Y-m-d H:i:s&#039;));\n$datetime = Redis::get(&#039;imi:redis:test&#039;);回调方式使用Redis$result = Redis::use(function(\\Imi\\Redis\\RedisHandler $redis){\n    $redis-&gt;set(&#039;a&#039;, 1);\n    return true;\n}); // true进阶使用$redis = RedisManager::getInstance();\n$redis-&gt;方法名();或\\Imi\\Redis\\Redis::方法名();evalEximi 封装了一个基于 evalSha 和 eval 的便捷方法，优先使用 evalSha 尝试，失败则使用 eval 方法。定义：public function evalEx($script, $args = null, $num_keys = null)return false !== $redis-&gt;evalEx(&lt;&lt;&lt;SCRIPT\nredis.call(&#039;set&#039;, &#039;a&#039;, &#039;123&#039;)\nreturn redis.call(&#039;get&#039;, &#039;a&#039;)\nSCRIPT\n    );scanEachscan 方法的扩展简易遍历方法参数与 scan 基本一致，无需传递 it 参数foreach(Redis::scanEach(&#039;imi:scanEach:*&#039;, 10) as $value)\n{\n    var_dump($value);\n}hscanEachhscan 方法的扩展简易遍历方法参数与 hscan 基本一致，无需传递 it 参数foreach(Redis::hscanEach($key, &#039;value:*&#039;, 10) as $k =&gt; $value)\n{\n    var_dump($k, $value);\n}sscanEachsscan 方法的扩展简易遍历方法参数与 sscan 基本一致，无需传递 it 参数foreach(Redis::sscanEach($key, &#039;*&#039;, 10) as $value)\n{\n    var_dump($value);\n}zscanEachzscan 方法的扩展简易遍历方法参数与 zscan 基本一致，无需传递 it 参数foreach(Redis::zscanEach($key, &#039;*&#039;, 10) as $score)\n{\n    var_dump($value);\n}"},{"id":171,"title":"请求上下文代理（RequestContextProxy）","pageTitle":"请求上下文代理（RequestContextProxy）","url":"components/requestContextProxy/index.html","content":"请求上下文代理（RequestContextProxy）目录可以代理请求上下文中的数据，支持静态方法调用和对象方法调用。示例假设有这么一个类：&lt;?php\n\nnamespace Imi\\Test\\Component\\RequestContextProxy;\n\nclass A\n{\n    public function add($a, $b)\n    {\n        return $a + $b;\n    }\n}\n定义代理类 RequestContextProxy：&lt;?php\nnamespace Imi\\Test\\Component\\RequestContextProxy;\n\nuse Imi\\RequestContextProxy\\BaseRequestContextProxy;\nuse Imi\\RequestContextProxy\\Annotation\\RequestContextProxy;\n\n/**\n * @RequestContextProxy(class=&quot;Imi\\Test\\Component\\RequestContextProxy\\A&quot;, name=&quot;testRequestContextProxyA&quot;)\n * @method mixed add($a, $b)\n * @method static mixed add($a, $b)\n */\nclass RequestContextProxyA extends BaseRequestContextProxy\n{\n\n}\n继承 Imi\\RequestContextProxy\\BaseRequestContextProxy 类，然后使用@RequestContextProxy注解类定义绑定到上下文的名称。使用方式：use Imi\\Test\\Component\\RequestContextProxy\\RequestContextProxyA;\nRequestContextProxyA::add(1, 2); // 3\n\n// 也可以实例化后使用\n$a = new RequestContextProxyA();\n$a-&gt;add(2, 3); // 5\n\n// 获取请求上下文中的实例\n$a = RequestContextProxyA::__getProxyInstance();\n$a-&gt;add(2, 3); // 5\n\n// 设置请求上下文中的实例\nRequestContextProxyA::__setProxyInstance($a);@RequestContextProxy 注解class RequestContextProxy extends Base\n{\n    /**\n     * 只传一个参数时的参数名.\n     *\n     * @var string\n     */\n    protected $defaultFieldName = &#039;name&#039;;\n\n    /**\n     * 代理类名.\n     *\n     * @var string\n     */\n    public $class;\n\n    /**\n     * 请求上下文中的名称.\n     *\n     * @var string\n     */\n    public $name;\n}RequestContextProxy 生成器查看帮助：imi-xxx generate/requestContextProxy -h"},{"id":121,"title":"Protobuf","pageTitle":"Protobuf","url":"components/rpc/grpc-protobuf.html","content":"Protobuf目录介绍Protobuf + HTTP2 = gRPCprotoc 下载和安装：https://github.com/protocolbuffers/protobuf/releases\\Imi\\Grpc\\Util\\ProtobufUtilDemo proto 文件定义syntax = &quot;proto3&quot;;\n\npackage grpc;\n\nimport &quot;google/protobuf/any.proto&quot;;\nimport &quot;google/protobuf/timestamp.proto&quot;;\nimport &quot;google/protobuf/duration.proto&quot;;\nimport &quot;google/protobuf/struct.proto&quot;;\nimport &quot;google/protobuf/field_mask.proto&quot;;\n\noption php_generic_services = true;\n\nenum Test {\n    A = 0;\n    B = 2;\n}\n\nmessage TestRequest {\n    int32 int = 1;\n    string string = 2;\n    LoginRequest message = 3;\n    repeated LoginRequest messages = 4;\n    google.protobuf.Any any = 5;\n    map&lt;int32, string&gt; map = 6;\n    map&lt;string, LoginRequest&gt; map2 = 7;\n    repeated google.protobuf.Any anys = 8;\n    Test enum = 9;\n    bool bool = 10;\n    google.protobuf.Timestamp timestamp = 11;\n    google.protobuf.Duration duration = 12;\n    google.protobuf.Struct struct = 13;\n    google.protobuf.FieldMask fieldMask = 14;\n    repeated string strings = 15;\n}newMessage实例化并初始化一个消息/** @var TestRequest $request */\n$request = ProtobufUtil::newMessage(TestRequest::class, [\n    &#039;int&#039;      =&gt; 1,\n]);newMessageArray实例化并初始化一个消息列表/** @var TestRequest[] $requests */\n$requests = ProtobufUtil::newMessage(TestRequest::class, [\n    [\n        &#039;int&#039;      =&gt; 1,\n    ],\n    [\n        &#039;int&#039;      =&gt; 2,\n    ],\n]);setMessageData向 Grpc Message 对象设置值，每次设置前会清空所有的值$request = new TestRequest();\n$ignoreUnknown = true; // 忽略未知字段\n// 下面示例的值代表了几乎所有常见的类型，可供参考\nProtobufUtil::setMessageData($request, [\n    &#039;int&#039;      =&gt; 1,\n    &#039;string&#039;   =&gt; &#039;abc&#039;,\n    &#039;strings&#039;  =&gt; [&#039;a&#039;, &#039;b&#039;],\n    &#039;message&#039;  =&gt; [&#039;phone&#039; =&gt; &#039;114514&#039;, &#039;password&#039; =&gt; &#039;123456&#039;],\n    &#039;messages&#039; =&gt; [\n        [&#039;phone&#039; =&gt; &#039;1&#039;, &#039;password&#039; =&gt; &#039;11&#039;],\n        [&#039;phone&#039; =&gt; &#039;2&#039;, &#039;password&#039; =&gt; &#039;22&#039;],\n    ],\n    &#039;any&#039;    =&gt; [\n        &#039;@type&#039;    =&gt; &#039;type.googleapis.com/grpc.LoginRequest&#039;,\n        &#039;phone&#039;    =&gt; &#039;114514&#039;,\n        &#039;password&#039; =&gt; &#039;123&#039;,\n    ],\n    &#039;map&#039; =&gt; [\n        11 =&gt; &#039;aa&#039;,\n        22 =&gt; &#039;bb&#039;,\n    ],\n    &#039;map2&#039; =&gt; [\n        &#039;a&#039; =&gt; [&#039;phone&#039; =&gt; &#039;1&#039;, &#039;password&#039; =&gt; &#039;11&#039;],\n        &#039;b&#039; =&gt; [&#039;phone&#039; =&gt; &#039;2&#039;, &#039;password&#039; =&gt; &#039;22&#039;],\n    ],\n    &#039;anys&#039;    =&gt; [\n        [\n            &#039;@type&#039;    =&gt; &#039;type.googleapis.com/grpc.LoginRequest&#039;,\n            &#039;phone&#039;    =&gt; &#039;114514&#039;,\n            &#039;password&#039; =&gt; &#039;123&#039;,\n        ],\n    ],\n    &#039;enum&#039;      =&gt; 2,\n    &#039;bool&#039;      =&gt; true,\n    &#039;timestamp&#039; =&gt; &#039;2018-06-21T04:00:00Z&#039;,\n    &#039;duration&#039;  =&gt; &#039;1s&#039;,\n    &#039;struct&#039;    =&gt; [\n        &#039;null&#039;   =&gt; null,\n        &#039;number&#039; =&gt; 3.14,\n        &#039;string&#039; =&gt; &#039;abc&#039;,\n        &#039;bool&#039;   =&gt; true,\n        &#039;struct&#039; =&gt; [\n            &#039;id&#039;   =&gt; 1,\n            &#039;name&#039; =&gt; &#039;imi&#039;,\n        ],\n        &#039;list1&#039; =&gt; [1, 2, 3],\n        &#039;list2&#039; =&gt; [\n            [\n                &#039;id&#039;   =&gt; 1,\n                &#039;name&#039; =&gt; &#039;imi&#039;,\n            ],\n        ],\n    ],\n    &#039;fieldMask&#039; =&gt; &#039;abc.def&#039;,\n]\n, $ignoreUnknown  // 忽略未知字段，默认可以忽略不传\n);getMessageValue获取 Grpc Message 对象本身代表的值$request = new TestRequest();\n// 这个 demo 是返回数组\nvar_dump(ProtobufUtil::getMessageValue($request));\n\n// 指定一些参数设置\nvar_dump(ProtobufUtil::getMessageValue($request, [\n    &#039;enumReturnType&#039; =&gt; &#039;value&#039;, // 枚举返回值是值，默认\n    &#039;enumReturnType&#039; =&gt; &#039;name&#039;, // 枚举返回值是枚举名称\n]));"},{"id":122,"title":"gRPC 的 HTTP 代理网关","pageTitle":"gRPC 的 HTTP 代理网关","url":"components/rpc/grpc-proxy.html","content":"gRPC 的 HTTP 代理网关目录介绍imi v2.1.22 新加入的 gRPC HTTP 代理网关，作用是可以用 HTTP + JSON 的方式请求接口，而不用 Protobuf + HTTP2 来直接调用 gRPC。其实这里可以画一个很厉害的架构图，但对使用没有什么帮助，就不放了。使用proto 文件生成 PHP 代码这一步和 gRPC 服务开发一样，就不再赘述。配置 gRPC 连接池因为我们服务端是代理网关，其实就是作为客户端去连服务端，所以要配置连接池。可参考 gRPC 服务开发。绑定 gRPC 接口（非必须）如果你的 gRPC 接口是跟代理同一个服务，那么 imi 会帮你做好绑定，不需要做这一步。如果你是代理外部服务的 gRPC 接口，此步骤是必须的。在 @app.beans 中配置：[\n    &#039;GrpcInterfaceManager&#039; =&gt; [\n        // 绑定的服务接口\n        &#039;binds&#039; =&gt; [\n            \\Grpc\\AuthServiceInterface::class, // 这里换成你自己的\n        ],\n    ],\n]编写代理接口就是写一个 HTTP 接口，没什么多说的，直接上代码：&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace GrpcApp\\GrpcServer\\Controller;\n\nuse Imi\\Aop\\Annotation\\Inject;\nuse Imi\\Controller\\HttpController;\nuse Imi\\Grpc\\Proxy\\Http\\GrpcHttpProxy;\nuse Imi\\Server\\Http\\Route\\Annotation\\Action;\nuse Imi\\Server\\Http\\Route\\Annotation\\Controller;\nuse Imi\\Server\\Http\\Route\\Annotation\\Route;\n\n/**\n * @Controller(&quot;/proxy/&quot;)\n */\nclass ProxyController extends HttpController\n{\n    /**\n     * @Inject(&quot;GrpcHttpProxy&quot;)\n     */\n    protected GrpcHttpProxy $grpcHttpProxy;\n\n    /**\n     * @Action\n     * @Route(&quot;grpc/{service}/{method}&quot;)\n     *\n     * @return mixed\n     */\n    public function proxy(string $service, string $method)\n    {\n        // 这里的 grpc 是连接池名称，换成你自己的\n        return $this-&gt;grpcHttpProxy-&gt;proxy(&#039;grpc&#039;, $this-&gt;request, $this-&gt;response, $service, $method);\n    }\n}@Controller(&quot;/proxy/&quot;) 和 @Route(&quot;grpc/{service}/{method}&quot;) 的路由都是可以自己定义的，这里仅仅作为演示用。测试这里拿 gRPC 服务开发中的示例来测试：curl --location --request POST -X POST &quot;http://127.0.0.1:8080/proxy/grpc/grpc.AuthService/login&quot; \\\n--header &#039;Content-Type: application/json&#039; \\\n--data &#039;{\n    &quot;phone&quot;: &quot;12345678901&quot;,\n    &quot;password&quot;: &quot;123456&quot;\n}&#039;返回：{\n    &quot;success&quot;: true,\n    &quot;error&quot;: &quot;&quot;\n}注意事项如何传请求参数请求参数可以是 GET、POST、JSON 数据，只要 imi 能正常接收就可以。推荐使用 JSON，可以支持复杂数据结构。请求参数格式下面给个示例，可以参考，几乎覆盖了绝大部分常见类型proto:syntax = &quot;proto3&quot;;\n\npackage grpc;\n\nimport &quot;google/protobuf/any.proto&quot;;\nimport &quot;google/protobuf/timestamp.proto&quot;;\nimport &quot;google/protobuf/duration.proto&quot;;\nimport &quot;google/protobuf/struct.proto&quot;;\nimport &quot;google/protobuf/field_mask.proto&quot;;\n\noption php_generic_services = true;\n\nservice AuthService {\n    rpc Login (LoginRequest) returns (LoginResponse);\n}\n\nmessage LoginRequest {\n    string phone = 1;       // 手机号\n    string password = 2;    // 密码\n}\n\nmessage LoginResponse {\n    bool success = 1;       // 是否成功\n    string error = 2;       // 错误信息\n}\n\nservice TestService {\n    rpc Test (TestRequest) returns (TestRequest);\n}\n\nenum Test {\n    A = 0;\n    B = 2;\n}\n\nmessage TestRequest {\n    int32 int = 1;\n    string string = 2;\n    LoginRequest message = 3;\n    repeated LoginRequest messages = 4;\n    google.protobuf.Any any = 5;\n    map&lt;int32, string&gt; map = 6;\n    map&lt;string, LoginRequest&gt; map2 = 7;\n    repeated google.protobuf.Any anys = 8;\n    Test enum = 9;\n    bool bool = 10;\n    google.protobuf.Timestamp timestamp = 11;\n    google.protobuf.Duration duration = 12;\n    google.protobuf.Struct struct = 13;\n    google.protobuf.FieldMask fieldMask = 14;\n    repeated string strings = 15;\n}JSON 请求参数：{\n    &quot;int&quot;: 1,\n    &quot;string&quot;: &quot;abc&quot;,\n    &quot;strings&quot;: [\n        &quot;a&quot;,\n        &quot;b&quot;\n    ],\n    &quot;message&quot;: {\n        &quot;phone&quot;: &quot;114514&quot;,\n        &quot;password&quot;: &quot;123456&quot;\n    },\n    &quot;messages&quot;: [\n        {\n            &quot;phone&quot;: &quot;1&quot;,\n            &quot;password&quot;: &quot;11&quot;\n        },\n        {\n            &quot;phone&quot;: &quot;2&quot;,\n            &quot;password&quot;: &quot;22&quot;\n        }\n    ],\n    &quot;any&quot;: {\n        &quot;@type&quot;: &quot;type.googleapis.com\\/grpc.LoginRequest&quot;,\n        &quot;phone&quot;: &quot;114514&quot;,\n        &quot;password&quot;: &quot;123&quot;\n    },\n    &quot;map&quot;: {\n        &quot;11&quot;: &quot;aa&quot;,\n        &quot;22&quot;: &quot;bb&quot;\n    },\n    &quot;map2&quot;: {\n        &quot;a&quot;: {\n            &quot;phone&quot;: &quot;1&quot;,\n            &quot;password&quot;: &quot;11&quot;\n        },\n        &quot;b&quot;: {\n            &quot;phone&quot;: &quot;2&quot;,\n            &quot;password&quot;: &quot;22&quot;\n        }\n    },\n    &quot;anys&quot;: [\n        {\n            &quot;@type&quot;: &quot;type.googleapis.com\\/grpc.LoginRequest&quot;,\n            &quot;phone&quot;: &quot;114514&quot;,\n            &quot;password&quot;: &quot;123&quot;\n        }\n    ],\n    &quot;enum&quot;: 2,\n    &quot;bool&quot;: true,\n    &quot;timestamp&quot;: &quot;2018-06-21T04:00:00Z&quot;,\n    &quot;duration&quot;: &quot;1s&quot;,\n    &quot;struct&quot;: {\n        &quot;null&quot;: null,\n        &quot;number&quot;: 3.14,\n        &quot;string&quot;: &quot;abc&quot;,\n        &quot;bool&quot;: true,\n        &quot;struct&quot;: {\n            &quot;id&quot;: 1,\n            &quot;name&quot;: &quot;imi&quot;\n        },\n        &quot;list1&quot;: [\n            1,\n            2,\n            3\n        ],\n        &quot;list2&quot;: [\n            {\n                &quot;id&quot;: 1,\n                &quot;name&quot;: &quot;imi&quot;\n            }\n        ]\n    },\n    &quot;fieldMask&quot;: &quot;abc.def&quot;\n}"},{"id":190,"title":"gRPC 服务开发","pageTitle":"gRPC 服务开发","url":"components/rpc/grpc.html","content":"gRPC 服务开发目录介绍在 imi 框架中集成 gRPC 服务开发、客户端调用及连接池。通讯协议为二进制的 Protobuf。Github: https://github.com/imiphp/imi-grpc仅支持 SwooleComposer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-grpc&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。你也可以直接创建 imi gRPC 骨架项目：composer create-project imiphp/project-grpc:~2.1.0使用说明可以参考 https://github.com/imiphp/imi-grpc/tree/master/example 目录示例，包括完整的服务端和客户端调用。服务和消息格式定义gRPC 和 Protobuf 是黄金搭档，Protobuf 是用来做通讯消息格式的序列化和反序列化的工作。gRPC 通讯有请求（Request）消息和响应（Response）消息，从请求消息中获取请求参数，通过响应消息返回给客户端。定义参考：example/grpc/grpc.protosyntax = &quot;proto3&quot;;\n\npackage grpc;\noption php_generic_services = true;\n\nservice AuthService {\n    rpc Login (LoginRequest) returns (LoginResponse);\n}\n\nmessage LoginRequest {\n    string phone = 1;       // 手机号\n    string password = 2;    // 密码\n}\n\nmessage LoginResponse {\n    bool success = 1;       // 是否成功\n    string error = 2;       // 错误信息\n}定义好后，通过命令生成 PHP 文件：protoc --php_out=./ grpc.protoprotoc 下载和安装：https://github.com/protocolbuffers/protobuf/releases生成好文件后，要把生成出来文件所在命名空间，配置到 composer.json，例：&quot;autoload&quot;: {\n    &quot;psr-4&quot;: {\n        &quot;Grpc\\\\&quot;: &quot;grpc/Grpc&quot;,\n        &quot;GPBMetadata\\\\&quot;: &quot;grpc/GPBMetadata&quot;,\n    }\n},服务端config.php 配置忽略目录&#039;ignorePaths&#039; =&gt; [\n    \\dirname(__DIR__) . \\DIRECTORY_SEPARATOR . &#039;grpc&#039;,\n],如果你用主服务器：[\n    // 主服务器配置\n    &#039;mainServer&#039;    =&gt;  [\n        &#039;namespace&#039; =&gt;    &#039;ImiApp\\GrpcServer&#039;,\n        &#039;type&#039;      =&gt;    &#039;GrpcServer&#039;,\n        &#039;host&#039;      =&gt;    &#039;127.0.0.1&#039;,\n        &#039;port&#039;      =&gt;    8080,\n    ],\n]如果你用子服务器：[\n    // 子服务器（端口监听）配置\n    &#039;subServers&#039;    =&gt;  [\n        // 子服务器名\n        &#039;XXX&#039;   =&gt;  [\n            &#039;namespace&#039; =&gt;    &#039;ImiApp\\GrpcServer&#039;,\n            &#039;type&#039;      =&gt;    &#039;GrpcServer&#039;,\n            &#039;host&#039;      =&gt;    &#039;127.0.0.1&#039;,\n            &#039;port&#039;      =&gt;    8080,\n        ]\n    ],\n]控制器写法与 Http Api 几乎一致。标准 gRPC Url 格式为：http://host:port/{package}.{service}/{method}/**\n * @Controller(&quot;/grpc.AuthService/&quot;)\n */\nclass AuthServiceController extends HttpController implements AuthServiceInterface\n{\n    /**\n     * Method &lt;code&gt;login&lt;/code&gt;\n     *\n     * @Action\n     * \n     * @param \\Grpc\\LoginRequest $request\n     * @return \\Grpc\\LoginResponse\n     */\n    public function login(\\Grpc\\LoginRequest $request)\n    {\n        $response = new LoginResponse;\n        $success = &#039;12345678901&#039; === $request-&gt;getPhone() &amp;&amp; &#039;123456&#039; === $request-&gt;getPassword();\n        $response-&gt;setSuccess($success);\n        $response-&gt;setError($success ? &#039;&#039; : &#039;登录失败&#039;);\n        return $response;\n    }\n\n}客户端连接池配置[\n    // 连接池配置\n    &#039;pools&#039;    =&gt;    [\n        &#039;grpc&#039;  =&gt;  [\n            &#039;pool&#039;    =&gt;    [\n                &#039;class&#039;        =&gt;    \\Imi\\Rpc\\Client\\Pool\\RpcClientCoroutinePool::class,\n                &#039;config&#039;    =&gt;    [\n                    // 根据实际情况设置\n                    &#039;maxResources&#039;  =&gt;    100,\n                    &#039;minResources&#039;  =&gt;    1,\n                ],\n            ],\n            &#039;resource&#039;    =&gt;    [\n                // 这里需要和你的服务端路由一致\n                &#039;url&#039;           =&gt;  &#039;http://127.0.0.1:8080/{package}.{service}/{name}&#039;,\n                // &#039;url&#039;           =&gt;  &#039;http://127.0.0.1:8080/{package}.{service}/{name|ucfirst}&#039;, // 参数支持设定函数处理，比如这个将方法名首字母大写，兼容其它部分语言\n                &#039;clientClass&#039;   =&gt;  \\Imi\\Grpc\\Client\\GrpcClient::class,\n                &#039;method&#039;        =&gt;  &#039;POST&#039;, // 指定请求方式，默认 GET\n            ],\n        ],\n    ],\n    &#039;rpc&#039;   =&gt;  [\n        &#039;defaultPool&#039;   =&gt;  &#039;grpc&#039;,\n    ],\n]客户端调用代码调用：// $service = \\Imi\\Rpc\\Client\\Pool\\RpcClientPool::getInstance(&#039;连接池名&#039;)-&gt;getService(&#039;服务名&#039;, &#039;生成出来的服务接口类名&#039;);\n$service = \\Imi\\Rpc\\Client\\Pool\\RpcClientPool::getInstance()-&gt;getService(&#039;AuthService&#039;, \\Grpc\\AuthServiceInterface::class);\n$request = new \\Grpc\\LoginRequest;\n$request-&gt;setPhone(&#039;&#039;);\n$service-&gt;login($request);注解调用：use Imi\\Rpc\\Annotation\\RpcClient;\nuse Imi\\Grpc\\Client\\Annotation\\GrpcService;\n\nclass Test\n{\n    /**\n     * @RpcClient()\n     *\n     * @var \\Imi\\Rpc\\Client\\IRpcClient\n     */\n    protected $rpcClient;\n\n    /**\n     * @GrpcService(serviceName=&quot;grpc.AuthService&quot;, interface=\\Grpc\\AuthServiceInterface::class)\n     *\n     * @var \\Grpc\\AuthServiceInterface\n     */\n    protected $authService;\n\n    public function aaa()\n    {\n        $request = new \\Grpc\\LoginRequest;\n        $request-&gt;setPhone(&#039;&#039;);\n\n        // 方法一\n        $this-&gt;rpcClient-&gt;getService(&#039;服务名&#039;, &#039;生成出来的服务接口类名&#039;)-&gt;方法名($request);\n\n        // 方法二\n        $this-&gt;xxxRpc-&gt;方法名($request);\n    }\n}@GrpcService 注解的 serviceName 属性格式为 {package}.{service}；interface 属性是生成出来的服务接口类名↓↓↓注意↓↓↓：使用 @GrpcService 注解注入时，如果调用的 grpc 接口方法名是：getName、send、recv、call、getClient，请使用 call 方法来调用，因为这和内置方法名相冲突了。"},{"id":191,"title":"Hprose","pageTitle":"Hprose","url":"components/rpc/hprose.html","content":"Hprose目录介绍在 imi 框架中集成 Hprose 服务开发，目前支持TCP、Unix Socket协议。Github: https://github.com/imiphp/imi-hprose仅支持 SwooleComposer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-hprose&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。服务端在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入RPC组件以及本组件\n        &#039;Rpc&#039;        =&gt;  &#039;Imi\\Rpc&#039;,\n        &#039;Hprose&#039;    =&gt;  &#039;Imi\\Hprose&#039;,\n    ],\n]如果你用主服务器：[\n    // 主服务器配置\n    &#039;mainServer&#039;    =&gt;    [\n        &#039;namespace&#039;    =&gt;    &#039;XXX\\MainServer&#039;, // 你的命名空间\n        &#039;type&#039;        =&gt;    &#039;Hprose&#039;, // 必须设为 Hprose\n        &#039;port&#039;        =&gt;    8080,\n    ],\n]如果你用子服务器：[\n    // 子服务器（端口监听）配置\n    &#039;subServers&#039;        =&gt;    [\n        // 子服务器名\n        &#039;XXX&#039;    =&gt;    [\n            &#039;namespace&#039;    =&gt;    &#039;XXX\\Hprose&#039;, // 你的命名空间\n            &#039;type&#039;        =&gt;    &#039;Hprose&#039;, // 必须设为 Hprose\n            &#039;port&#039;        =&gt;    50001,\n        ]\n    ],\n]控制器基类Imi\\Rpc\\Controller\\RpcController控制器注解\\Imi\\Rpc\\Route\\Annotation\\RpcController用法：@RpcController别名前缀：@RpcController(&quot;a_b_&quot;)指定服务器：@RpcController(prefix=&quot;a_b_&quot;, server=&quot;服务器名&quot;)动作注解\\Imi\\Rpc\\Route\\Annotation\\RpcAction无参路由注解\\Imi\\Hprose\\Route\\Annotation\\HproseRoute参数：name 路由名称规则。一般也是方法名，如果设置了别名，则最终为别名+方法名mode 该设置表示该服务函数返回的结果类型，具体值请参考 Hprose 文档simple 该设置表示本服务函数所返回的结果是否为简单数据。默认值为 false。oneway 该设置表示本服务函数是否不需要等待返回值。当该设置为 true 时，调用会异步开始，并且不等待结果，立即返回 null 给客户端。默认值为 false。async 该设置表示本服务函数是否为异步函数，异步函数的最后一个参数是一个回调函数，用户需要在异步函数中调用该回调方法来传回返回值passContext 该属性为 boolean 类型，默认值为 false。具体请参考 Hprose 文档Hprose 文档参考：https://github.com/hprose/hprose-php/wiki/06-Hprose-服务器#addfunction-%E6%96%B9%E6%B3%95客户端连接池配置[\n    &#039;pools&#039;    =&gt;    [\n        &#039;连接池名&#039;    =&gt;    [\n            &#039;pool&#039;    =&gt;    [\n                &#039;class&#039;        =&gt;    \\Imi\\Rpc\\Client\\Pool\\RpcClientCoroutinePool::class,\n                &#039;config&#039;    =&gt;    [\n                    // 连接池通用，查阅文档\n                ],\n            ],\n            &#039;resource&#039;    =&gt;    [\n                &#039;clientClass&#039;    =&gt;    \\Imi\\Hprose\\Client\\HproseSocketClient::class,\n                &#039;uris&#039;    =&gt;    &#039;tcp://127.0.0.1:50001&#039;, // 连接地址\n                // 其它配置\n            ]\n        ],\n    ],\n    &#039;rpc&#039;    =&gt;    [\n        &#039;defaultPool&#039;    =&gt;    &#039;连接池名&#039;, // 默认连接池名\n    ],\n]客户端调用代码调用：\\Imi\\Rpc\\Client\\Pool\\RpcClientPool::getService(&#039;服务名&#039;)-&gt;方法名(参数);注解调用：class Test\n{\n    /**\n     * @RpcClient()\n     *\n     * @var \\Imi\\Rpc\\Client\\IRpcClient\n     */\n    protected $rpcClient;\n\n    /**\n     * @RpcService(serviceName=&quot;服务名&quot;)\n     *\n     * @var \\Imi\\Rpc\\Client\\IService\n     */\n    protected $xxxRpc;\n\n    public function aaa()\n    {\n        // 方法一\n        $this-&gt;rpcClient-&gt;getService(&#039;服务名&#039;)-&gt;方法名(参数);\n\n        // 方法二\n        $this-&gt;xxxRpc-&gt;方法名(参数);\n    }\n}"},{"id":109,"title":"数据处理器","pageTitle":"数据处理器","url":"components/server/dataParser.html","content":"数据处理器目录数据处理器是用于长连接服务中的，它可以把从客户端接收来的数据，转成 PHP 数组或对象的类。同理，也可以从 PHP 数组或对象转换为数据。配置处理器Swoole:[\n    // 主服务器配置\n    &#039;mainServer&#039; =&gt; [\n        &#039;namespace&#039;    =&gt; &#039;Imi\\Swoole\\Test\\TCPServer\\MainServer&#039;,\n        &#039;type&#039;         =&gt; Imi\\Swoole\\Server\\Type::TCP_SERVER,\n        &#039;host&#039;         =&gt; \\Imi\\env(&#039;SERVER_HOST&#039;, &#039;127.0.0.1&#039;),\n        &#039;port&#039;         =&gt; 13003,\n        &#039;configs&#039;      =&gt; [\n            &#039;worker_num&#039;    =&gt; 1,\n            // EOF自动分包\n            &#039;open_eof_split&#039;     =&gt; true, //打开EOF_SPLIT检测\n            &#039;package_eof&#039;        =&gt; &quot;\\r\\n&quot;, //设置EOF\n        ],\n        // 这里配置数据处理器\n        &#039;dataParser&#039;    =&gt; \\Imi\\Server\\DataParser\\JsonArrayParser::class,\n    ],\n    // 子服务器（端口监听）配置\n    &#039;subServers&#039; =&gt; [\n        // 子服务器别名\n        &#039;alias1&#039;    =&gt;    [\n            // 指定服务器命名空间\n            &#039;namespace&#039;  =&gt; &#039;ImiDemo\\HttpDemo\\MainServer&#039;,\n            // 服务器类型(http/WebSocket/TcpServer/UdpServer)\n            &#039;type&#039;       =&gt; \\Imi\\Swoole\\Server\\Type::TCP_SERVER,\n            // 监听的IP地址，可选\n            &#039;host&#039;       =&gt; &#039;0.0.0.0&#039;,\n            // 监听的端口\n            &#039;port&#039;       =&gt; 8080,\n            // 参考 swoole sockType，可选\n            &#039;sockType&#039;   =&gt; SWOOLE_SOCK_TCP,\n            // 服务器配置，参数用法同\\Swoole\\Server-&gt;set($configs)\n            &#039;configs&#039;    =&gt; [\n            ],\n            // 这里配置数据处理器\n            &#039;dataParser&#039; =&gt; \\Imi\\Server\\DataParser\\JsonArrayParser::class,\n        ],\n    ],\n]Workerman:\nreturn [\n    // Workerman 服务器配置\n    &#039;workermanServer&#039; =&gt; [\n        // 服务器名\n        &#039;tcp&#039; =&gt; [\n            &#039;namespace&#039;   =&gt; &#039;Imi\\Workerman\\Test\\AppServer\\TcpServer&#039;,\n            &#039;type&#039;        =&gt; Imi\\Workerman\\Server\\Type::TCP,\n            &#039;host&#039;        =&gt; \\Imi\\env(&#039;SERVER_HOST&#039;, &#039;127.0.0.1&#039;),\n            &#039;port&#039;        =&gt; 13003,\n            &#039;shareWorker&#039; =&gt; &#039;http&#039;,\n            &#039;configs&#039;     =&gt; [\n                &#039;protocol&#039; =&gt; \\Workerman\\Protocols\\Text::class,\n            ],\n            // 这里配置数据处理器\n            &#039;dataParser&#039;    =&gt; \\Imi\\Server\\DataParser\\JsonArrayParser::class,\n        ],\n    ],\n];关于 Workerman 的 protocol 和 imi 中的 dataParser 差别。protocol 是 Workerman 中自定义通信协议的类；dataParser 是 imi 框架中对于通信协议编码解码的类；在 imi 中 protocol 只会用到里面的 decode() 方法在 imi 中 dataParser 的 encode()、decode() 方法都会被用到imi 内置的 Workerman Protocol 类：\\Imi\\Workerman\\Server\\Protocol\\FrameWithLength:基于 Workerman Frame 协议改造，返回内容：数据包长度+数据包\\Imi\\Workerman\\Server\\Protocol\\TextCRLF:基于 Workerman Text 协议改造，以 \\r\\n 分隔数据包内置处理器类JsonArrayParserJSON 数组类名：\\Imi\\Server\\DataParser\\JsonArrayParser::class支持注入的属性：名称描述默认值optionsJSON 序列化时的参数0 depth设置最大深度。 必须大于0。512 JsonObjectParserJSON 对象类名：\\Imi\\Server\\DataParser\\JsonObjectParser::class支持注入的属性：名称描述默认值optionsJSON 序列化时的参数0 depth设置最大深度。 必须大于0。512 自定义数据处理器实现接口：Imi\\Server\\DataParser\\IParser&lt;?php\n\nnamespace App\\DataParser;\n\nuse Imi\\Server\\DataParser\\IParser;\n\nclass XXXParser implements IParser\n{\n    /**\n     * 编码为存储格式.\n     *\n     * @param mixed $data\n     */\n    public function encode($data): string\n    {\n    }\n\n    /**\n     * 解码为php变量.\n     *\n     * @return mixed\n     */\n    public function decode(string $data)\n    {\n    }\n}"},{"id":93,"title":"SSL","pageTitle":"SSL","url":"components/server/ssl.html","content":"SSL目录本页介绍有关 HTTPS、WSS 的配置方法。有两个方式，第一种是直接在 imi 服务器配置中设置，第二种是在 Nginx 层配置。这边更加推荐在 Nginx 层设置通过 imi 配置Swoole项目 config.php：[\n    // 主服务器配置\n    &#039;mainServer&#039;    =&gt;    [\n        &#039;namespace&#039; =&gt;  &#039;ImiApp\\WebSocketServer&#039;,\n        &#039;type&#039;      =&gt;  Imi\\Swoole\\Server\\Type::WEBSOCKET,\n        &#039;host&#039;      =&gt;  &#039;127.0.0.1&#039;,\n        &#039;port&#039;      =&gt;  8082,\n        &#039;mode&#039;      =&gt;  SWOOLE_BASE,\n        &#039;sockType&#039;  =&gt;  SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL 需要设置一下 sockType\n        &#039;configs&#039;   =&gt;  [\n            &#039;worker_num&#039;            =&gt;  1,\n            &#039;task_worker_num&#039;       =&gt;  1,\n            &#039;task_enable_coroutine&#039; =&gt;  true,\n            // 配置证书\n            &#039;ssl_cert_file&#039;     =&gt;  &#039;/server.crt&#039;,\n            &#039;ssl_key_file&#039;      =&gt;  &#039;/server.key&#039;,\n        ],\n    ],\n\n    // 子服务器（端口监听）配置\n    &#039;subServers&#039;        =&gt;    [\n        &#039;ApiServer&#039;     =&gt;  [\n            &#039;namespace&#039; =&gt;  &#039;ImiApp\\ApiServer&#039;,\n            &#039;type&#039;      =&gt;  Imi\\Swoole\\Server\\Type::HTTP,\n            &#039;host&#039;      =&gt;  &#039;127.0.0.1&#039;,\n            &#039;port&#039;      =&gt;  8080,\n            &#039;sockType&#039;  =&gt;  SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL 需要设置一下 sockType\n            &#039;configs&#039;   =&gt;  [\n                // 配置证书\n                &#039;ssl_cert_file&#039;     =&gt;  &#039;/server.crt&#039;,\n                &#039;ssl_key_file&#039;      =&gt;  &#039;/server.key&#039;,\n            ]\n        ],\n    ],\n]Workerman// Workerman 服务器配置\n&#039;workermanServer&#039; =&gt; [\n    &#039;http&#039; =&gt; [\n        &#039;namespace&#039; =&gt; &#039;Imi\\Workerman\\Test\\AppServer\\ApiServer&#039;,\n        &#039;type&#039;      =&gt; Imi\\Workerman\\Server\\Type::HTTP,\n        &#039;host&#039;      =&gt; &#039;0.0.0.0&#039;,\n        &#039;port&#039;      =&gt; 13000,\n        &#039;context&#039;   =&gt; [\n            // 这个需要\n            &#039;ssl&#039; =&gt; [\n                &#039;local_cert&#039;  =&gt; &#039;/etc/nginx/conf.d/ssl/server.pem&#039;, // 也可以是crt文件\n                &#039;local_pk&#039;    =&gt; &#039;/etc/nginx/conf.d/ssl/server.key&#039;,\n                &#039;verify_peer&#039; =&gt; false,\n            ],\n        ]\n        &#039;configs&#039;   =&gt; [\n            &#039;transport&#039; =&gt; &#039;ssl&#039;, // 这个需要\n        ],\n    ],\n]通过 Nginx 配置HTTPS推荐配置如下server {\n    listen       80;\n    server_name  {域名};\n    return 301 https://$server_name$request_uri;\n}\n\n# 在下面配置 imi 服务 HTTP 地址\nupstream  imiserver { \n    server  127.0.0.1:8080 weight=1 fail_timeout=60s;\n}\n\nserver {\n    listen 443 ssl;\n    server_name {域名};\n    root {静态资源目录路径};\n    \n    access_log  /var/log/nginx/{域名}.access.log  main;\n    error_log  /var/log/nginx/{域名}.error.log  error;\n    \n    ssl_certificate      {证书}.pem;\n    ssl_certificate_key  {证书}.key;\n    ssl_session_timeout 5m;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n\n    location / {\n        proxy_pass http://imiserver;\n        proxy_redirect off;\n        proxy_set_header Host $host:$server_port;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}WSSserver {\n    listen 443 ssl;\n    server_name {域名};\n    access_log  /var/log/nginx/{域名}.access.log  main;\n    error_log  /var/log/nginx/{域名}.error.log  error;\n    ssl_certificate      {证书}.pem;\n    ssl_certificate_key  {证书}.key;\n\n    # websocket\n    location / { # 全部\n    # location ~* ^/ws/(.+) { # 指定路径\n        proxy_http_version 1.1;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection &quot;upgrade&quot;;\n        proxy_pass http://127.0.0.1:8082/$1?$args; # imi 服务 WebSocket 地址\n    }\n}"},{"id":214,"title":"服务发现（负载均衡）","pageTitle":"服务发现（负载均衡）","url":"components/serviceDiscovery/index.html","content":"服务发现（负载均衡）目录服务发现就是从注册中心获取节点列表。负载均衡就是从节点列表中，通过特定算法，获取本次通信使用的节点。支持的注册中心： Nacos (imi-nacos) Consul Zookeeper (imi-zookeeper)……支持的容器：SwooleWorkerman使用配置Nacos安装：composer require imiphp/imi-nacos:~2.1.0 imiphp/imi-service:~2.1.0配置：@app.beans：[\n    &#039;ServiceDiscovery&#039; =&gt; [\n        &#039;drivers&#039; =&gt; [\n            [\n                &#039;driver&#039;       =&gt; \\Imi\\Nacos\\Service\\NacosServiceDiscoveryDriver::class, // 服务发现驱动\n                // &#039;client&#039; =&gt; \\Imi\\Service\\Discovery\\DiscoveryClient::class, // 服务发现客户端，如无必要不需要修改\n                // 负载均衡配置\n                &#039;loadBalancer&#039; =&gt; \\Imi\\Service\\LoadBalancer\\RandomLoadBalancer::class, // 负载均衡-随机\n                // &#039;loadBalancer&#039; =&gt; \\Imi\\Service\\LoadBalancer\\RoundRobinLoadBalancer::class, // 负载均衡-轮询\n                // &#039;loadBalancer&#039; =&gt; \\Imi\\Service\\LoadBalancer\\WeightLoadBalancer::class, // 负载均衡-权重\n                // 发现服务列表\n                &#039;services&#039; =&gt; [\n                    &#039;serviceName&#039;, // 改为你的服务名称\n                ],\n                &#039;client&#039; =&gt; [\n                    // Nacos 客户端连接配置\n                    &#039;host&#039;                =&gt; &#039;127.0.0.1&#039;, // 主机名\n                    &#039;port&#039;                =&gt; 8848, // 端口号\n                    &#039;prefix&#039;              =&gt; &#039;/&#039;, // 前缀\n                    &#039;username&#039;            =&gt; &#039;nacos&#039;, // 用户名\n                    &#039;password&#039;            =&gt; &#039;nacos&#039;, // 密码\n                    &#039;timeout&#039;             =&gt; 60000, // 网络请求超时时间，单位：毫秒\n                    &#039;ssl&#039;                 =&gt; false, // 是否使用 ssl(https) 请求\n                    &#039;authorizationBearer&#039; =&gt; false, // 是否使用请求头 Authorization: Bearer {accessToken} 方式传递 Token，旧版本 Nacos 需要设为 true\n                ],\n                &#039;cacheTTL&#039; =&gt; 60, // 缓存时间，单位：秒。默认为60秒，设为0不启用缓存\n            ],\n        ],\n    ],\n]获取服务可用节点/** @var \\Imi\\Service\\Discovery\\ServiceDiscovery $serviceDiscovery */\n$serviceDiscovery = \\Imi\\App::getBean(&#039;ServiceDiscovery&#039;);\n$service = $serviceDiscovery-&gt;getInstance(&#039;服务名称&#039;);\n\n$service-&gt;getInstanceId(); // 实例ID，string\n$service-&gt;getServiceId(); // 服务ID，string\n$service-&gt;getWeight(); // 权重，float\n$service-&gt;getUri(); // \\Imi\\Util\\Uri\n$service-&gt;getMetadata(); // 元数据，数组\n\n// 获取服务实例的ip及端口的常用写法\n$uri = $service-&gt;getUri();\n$host = $uri-&gt;getHost();\n$port = $uri-&gt;getPort();"},{"id":213,"title":"服务注册","pageTitle":"服务注册","url":"components/serviceRegistry/index.html","content":"服务注册目录服务注册可以把当前服务注册到注册中心，便于其他服务使用服务发现、负载均衡来获取到某个节点，并与服务进行通信。支持的注册中心： Nacos (imi-nacos) Consul Zookeeper (imi-zookeeper)……支持的容器：SwooleWorkerman使用Nacos安装：composer require imiphp/imi-nacos:~2.1.0 imiphp/imi-service:~2.1.0配置：@app.beans：[\n    &#039;ServiceRegistry&#039; =&gt; [\n        &#039;drivers&#039; =&gt; [\n            [\n                &#039;driver&#039; =&gt; \\Imi\\Nacos\\Service\\NacosServiceRegistry::class, // 驱动类名\n                // 注册的服务列表\n                &#039;services&#039; =&gt; [\n                    &#039;main&#039;, // 格式1：主服务器是 main，子服务器就是子服务器名\n                    // 格式2：数组配置\n                    [\n                        // 所有参数按需设置\n                        &#039;server&#039;     =&gt; &#039;main&#039;, // 主服务器是 main，子服务器就是子服务器名\n                        // &#039;instanceId&#039; =&gt; &#039;实例ID&#039;,\n                        &#039;serviceId&#039;  =&gt; &#039;main_test&#039;,\n                        &#039;weight&#039;     =&gt; 1, // 权重\n                        &#039;uri&#039;        =&gt; &#039;http://127.0.0.1:8080&#039;, // uri\n                        // &#039;host&#039;       =&gt; &#039;127.0.0.1&#039;,\n                        // &#039;port&#039;       =&gt; 8080,\n                        &#039;metadata&#039;   =&gt; [\n                            // &#039;group&#039; =&gt; &#039;DEFAULT_GROUP&#039;, // 分组\n                            // &#039;namespaceId&#039; =&gt; &#039;&#039;, // 命名空间\n                            // &#039;metadata&#039; =&gt; [], // metadata\n                            // &#039;ephemeral&#039; =&gt; true, // 是否为临时实例\n                        ],\n                        // &#039;interface&#039;  =&gt; &#039;eth0&#039;, // 网卡 interface 名，自动获取当前网卡IP时有效\n                    ],\n                ],\n                &#039;client&#039; =&gt; [\n                    // 注册中心客户端连接配置，每个驱动不同\n                    &#039;host&#039;                =&gt; &#039;127.0.0.1&#039;, // 主机名\n                    &#039;port&#039;                =&gt; 8848, // 端口号\n                    &#039;prefix&#039;              =&gt; &#039;/&#039;, // 前缀\n                    &#039;username&#039;            =&gt; &#039;nacos&#039;, // 用户名\n                    &#039;password&#039;            =&gt; &#039;nacos&#039;, // 密码\n                    &#039;timeout&#039;             =&gt; 60000, // 网络请求超时时间，单位：毫秒\n                    &#039;ssl&#039;                 =&gt; false, // 是否使用 ssl(https) 请求\n                    &#039;authorizationBearer&#039; =&gt; false, // 是否使用请求头 Authorization: Bearer {accessToken} 方式传递 Token，旧版本 Nacos 需要设为 true\n                ],\n                &#039;heartbeat&#039; =&gt; 3, // 心跳时间，单位：秒\n            ],\n        ],\n    ],\n]"},{"id":199,"title":"跨进程变量共享","pageTitle":"跨进程变量共享","url":"components/shared-memory.html","content":"跨进程变量共享目录介绍基于 Swoole Shared Memory 开发的 imi 框架跨进程变量共享组件。Composer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-shared-memory&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入本组件\n        &#039;SharedMemory&#039;    =&gt;  &#039;Imi\\SharedMemory&#039;,\n    ],\n    &#039;pools&#039;    =&gt;    [\n        // 客户端连接池\n        &#039;sharedMemory&#039;  =&gt;  [\n            &#039;async&#039; =&gt;  [\n                &#039;pool&#039;    =&gt;    [\n                    &#039;class&#039;        =&gt;    \\Imi\\SharedMemory\\Pool\\ClientPool::class,\n                    &#039;config&#039;    =&gt;    [\n                        &#039;maxResources&#039;    =&gt;    100,\n                        &#039;minResources&#039;    =&gt;    0,\n                    ],\n                ],\n                &#039;resource&#039;  =&gt;  [\n                    // 以下为可选配置\n\n                    // 存储器类型，注意和下面的类名不同\n                    // &#039;storeTypes&#039;    =&gt;  [\n                    //     \\Yurun\\Swoole\\SharedMemory\\Client\\Store\\KV::class,\n                    //     \\Yurun\\Swoole\\SharedMemory\\Client\\Store\\Stack::class,\n                    //     \\Yurun\\Swoole\\SharedMemory\\Client\\Store\\Queue::class,\n                    //     \\Yurun\\Swoole\\SharedMemory\\Client\\Store\\PriorityQueue::class,\n                    //      &#039;name&#039;  =&gt;  &#039;XXXClass&#039;,\n                    // ],\n\n                    // unix socket 文件名，默认会自动放 runtime 目录中\n                    // &#039;socketFile&#039;    =&gt;  &#039;&#039;,\n                ],\n            ],\n        ]\n    ],\n    // 以下为可选配置\n    // &#039;swooleSharedMemory&#039;    =&gt;  [\n        // unix socket 文件名，默认会自动放 runtime 目录中\n        // &#039;socketFile&#039;    =&gt;  &#039;&#039;,\n\n        // 存储器类型，注意和上面的类名不同\n        // &#039;storeTypes&#039;    =&gt;  [\n        //     \\Yurun\\Swoole\\SharedMemory\\Store\\KV::class,\n        //     \\Yurun\\Swoole\\SharedMemory\\Store\\Stack::class,\n        //     \\Yurun\\Swoole\\SharedMemory\\Store\\Queue::class,\n        //     \\Yurun\\Swoole\\SharedMemory\\Store\\PriorityQueue::class,\n        //      &#039;name&#039;  =&gt;  &#039;XXXClass&#039;,\n        // ],\n\n        // 默认连接池名\n        // &#039;defaultPool&#039;   =&gt;  &#039;sharedMemory&#039;\n    // ],\n]在代码中操作：// 方法一\nSharedMemory::use(&#039;KV&#039;, function(\\Yurun\\Swoole\\SharedMemory\\Client\\Store\\KV $kv){\n    $kv-&gt;set(&#039;a&#039;, 1);\n});\n\n// 方法二\n$kv = SharedMemory::getInstance()-&gt;getObject(&#039;KV&#039;);\n$kv-&gt;set(&#039;a&#039;, 1);"},{"id":197,"title":"Smarty 模版引擎","pageTitle":"Smarty 模版引擎","url":"components/smarty.html","content":"Smarty 模版引擎目录介绍支持在 imi 框架中使用 Smarty 模版引擎Composer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-smarty&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。基本使用在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入本组件\n        &#039;Smarty&#039;       =&gt;  &#039;Imi\\Smarty&#039;,\n    ],\n]在服务器的 config/config.php 中配置：[\n    &#039;beans&#039;    =&gt;    [\n        &#039;HtmlView&#039;    =&gt;    [\n            &#039;templatePath&#039;      =&gt;  dirname(__DIR__) . &#039;/template/&#039;,\n            &#039;templateEngine&#039;    =&gt;  &#039;SmartyEngine&#039;,\n            // 支持的模版文件扩展名，优先级按先后顺序\n            &#039;fileSuffixs&#039;        =&gt;    [\n                &#039;tpl&#039;,\n                &#039;html&#039;,\n                &#039;php&#039;\n            ],\n        ],\n        // 可选项\n        &#039;SmartyEngine&#039; =&gt; [\n            // 缓存目录\n            &#039;cacheDir&#039;      =&gt;  null,\n            // 编译目录\n            &#039;compileDir&#039;    =&gt;  null,\n            // 是否开启缓存，默认不开启\n            &#039;caching&#039;       =&gt;  0,\n            // 缓存有效时间\n            &#039;cacheLifetime&#039; =&gt;  0,\n        ],\n    ],\n];进阶使用本组件没有封装大量的配置项，所以当你需要做一些其它设置时，可以监听 IMI.SMARTY.NEW 事件，当首次实例化对象时，触发该事件。事件参数数据如下：[\n    &#039;smarty&#039;        =&gt;  $smarty,        // Smarty 对象\n    &#039;serverName&#039;    =&gt;  $serverName,    // 当前服务器名\n]"},{"id":200,"title":"雪花算法发号器","pageTitle":"雪花算法发号器","url":"components/snowflake.html","content":"雪花算法发号器目录介绍imi 框架的雪花算法生成组件Github: https://github.com/imiphp/imi-snowflakeComposer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-snowflake&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入本组件\n        &#039;snowflake&#039;    =&gt;  &#039;Imi\\Snowflake&#039;,\n    ],\n]配置配置 @app.beans：更多细节可参考godruoyi/php-snowflake组件的文档[\n    &#039;Snowflake&#039;   =&gt;  [\n        &#039;list&#039;  =&gt;  [\n            // 可定义多个配置名称\n            &#039;testBasic&#039; =&gt;  [\n                // &#039;datacenterId&#039;   =&gt; null, // 数据中心ID，为空时为0\n                // &#039;workerId&#039;       =&gt; null, // 工作进程ID，为空时取当前进程ID\n                // &#039;startTimeStamp&#039; =&gt; null, // 开始时间戳，单位：毫秒\n                // &#039;redisPool&#039;      =&gt; null, // Redis 连接池名称，为空取默认连接池\n            ],\n        ],\n    ],\n]注意：当datacenterId或workerId的设置的值大于31时会被替换为一个0-31的随机数！！！生成ID$id = \\Imi\\Snowflake\\SnowflakeUtil::id(&#039;testBasic&#039;);解析ID$array = \\Imi\\Snowflake\\SnowflakeUtil::parseId(&#039;testBasic&#039;, $id);\nvar_dump($array);处理结果格式：array(4) {\n  [&quot;timestamp&quot;]=&gt;\n  string(35) &quot;10100100111111101010001000001110010&quot;\n  [&quot;sequence&quot;]=&gt;\n  string(12) &quot;000000000000&quot;\n  [&quot;workerid&quot;]=&gt;\n  string(5) &quot;00000&quot;\n  [&quot;datacenter&quot;]=&gt;\n  string(5) &quot;00000&quot;\n}"},{"id":227,"title":"ArrayData","pageTitle":"ArrayData","url":"components/struct/ArrayData.html","content":"ArrayData目录数组数据基类，支持使用 a.b.c 方式操作数据$data = [\n    &#039;a&#039; =&gt;  [\n        &#039;b&#039; =&gt;  [\n            &#039;c&#039; =&gt;  [\n                &#039;name&#039;  =&gt;  &#039;imi&#039;,\n            ]\n        ]\n    ]\n];\n$data = new \\Imi\\Util\\ArrayData($data);\n// 3 种不同操作方法，输出都是 imi\nvar_dump($data-&gt;get(&#039;a.b.c.name&#039;));\nvar_dump($data[&#039;a.b.c.name&#039;]);\nvar_dump($data-&gt;{&#039;a.b.c.name&#039;});\n\n$data-&gt;set(&#039;a.id&#039;, 123); // a.id 直接作为key，而不是多级数组\nvar_dump($data[&#039;a.id&#039;]); // false\nvar_dump($data-&gt;get()[&#039;a.id&#039;]); // 123\n\n$data-&gt;setVal(&#039;a.id&#039;, 456);\nvar_dump($data[&#039;a.id&#039;]); // 456\n\n// 第 3 个参数不合并，设置过后，a.b.c.name 将不存在\n$data-&gt;set([\n    &#039;a&#039; =&gt; [\n        &#039;b&#039; =&gt; [\n            &#039;c&#039; =&gt; [\n                &#039;noname&#039; =&gt; true,\n            ],\n        ],\n    ],\n], null, false);\n\n$data-&gt;clear(); // 全部清除"},{"id":229,"title":"ArrayList","pageTitle":"ArrayList","url":"components/struct/ArrayList.html","content":"ArrayList目录限定成员类型的数组列表如果成员类型不正确，会抛出\\InvalidArgumentException异常class TestModel\n{\n    public $id;\n\n    public $name;\n\n    public function __construct($id, $name)\n    {\n        $this-&gt;id = $id;\n        $this-&gt;name = $name;\n    }\n}\n\n// $list = new \\Imi\\Util\\ArrayList(TestModel::class);\n$list = new \\Imi\\Util\\ArrayList(TestModel::class, [\n    new TestModel(1, &#039;a&#039;),\n    new TestModel(2, &#039;b&#039;),\n]);\n\nforeach($list as $index =&gt; $item)\n{\n    var_dump($index, $item);\n}\n\n// 取其中某个成员\n$item0 = $list[0];\n\n// 转为数组\n$arrayList = $list-&gt;toArray();\nvar_dump($arrayList);\n\n// 移除多个成员\n$arrayList-&gt;remove($list[1], $list[2]);\n\n// 清空\n$arrayList-&gt;clear();\n\n// 统计数量\necho $arrayList-&gt;count();"},{"id":232,"title":"Atomic","pageTitle":"Atomic","url":"components/struct/atomic.html","content":"Atomic目录基于 Swoole 提供的 Swoole\\Atomic，直接在配置文件中设置，就可以在worker进程中使用，数据互通。使用时无需加锁！仅 Swoole 可用配置方式在项目配置文件中加入以下节&#039;atomics&#039;    =&gt;    [\n    // 定义名为name1的，初始值为0\n    &#039;name1&#039;,\n    // 定义名为name2的，初始值为10\n    &#039;name2&#039;    =&gt;    10,\n],使用方式use \\Imi\\Swoole\\Util\\AtomicManager;\n\n// 获取 Swoole\\Atomic 对象\n$atomic = AtomicManager::getInstance(&#039;name1&#039;);\n\n// 加1，返回结果\n$number = AtomicManager::add(&#039;name1&#039;);\n\n// 加10，返回结果\n$number = AtomicManager::add(&#039;name1&#039;, 10);\n\n// 减1，返回结果\n$number = AtomicManager::sub(&#039;name1&#039;);\n\n// 减10，返回结果\n$number = AtomicManager::sub(&#039;name1&#039;, 10);\n\n// 获取当前值\n$number = AtomicManager::get(&#039;name1&#039;);\n\n// 设置当前值为100\nAtomicManager::get(&#039;name1&#039;, 100);\n\n// -----------------------------------------------\n\n// 如果当前数值等于100返回true，并将当前数值设置为1\n// 如果当前数值不等于100返回false\n$number = AtomicManager::cmpset(&#039;name1&#039;, 100, 1);\n\n/**\n * 当原子计数的值为0时程序进入等待状态。另外一个进程调用wakeup可以再次唤醒程序。底层基于Linux Futex实现，使用此特性，可以仅用4字节内存实现一个等待、通知、锁的功能。\n * 超时返回false，错误码为EAGAIN，可使用swoole_errno函数获取\n * 成功返回true，表示有其他进程通过wakeup成功唤醒了当前的锁\n * 使用wait/wakeup特性时，原子计数的值只能为0或1，否则会导致无法正常使用\n * 当然原子计数的值为1时，表示不需要进入等待状态，资源当前就是可用。wait函数会立即返回true\n * @param string $name 原子计数对象名称\n * @param float $timeout 指定超时时间，默认为-1，表示永不超时，会持续等待直到有其他进程唤醒\n * @return bool\n */\n$result = AtomicManager::wait(&#039;name1&#039;);\n// 超时时间100毫秒\n$result = AtomicManager::wait(&#039;name1&#039;, 0.1);\n\n/**\n * 唤醒处于wait状态的其他进程。\n * 当前原子计数如果为0时，表示没有进程正在wait，wakeup会立即返回true\n * 当前原子计数如果为1时，表示当前有进程正在wait，wakeup会唤醒等待的进程，并返回true\n * 如果同时有多个进程处于wait状态，$n参数可以控制唤醒的进程数量\n * 被唤醒的进程返回后，会将原子计数设置为0，这时可以再次调用wakeup唤醒其他正在wait的进程\n * @param string $name 原子计数对象名称\n * @param integer $n\n * @return void\n */\nAtomicManager::wakeup(&#039;name1&#039;); // 第二个参数我也不知道干嘛的，swoole文档没写"},{"id":233,"title":"协程 Channel","pageTitle":"协程 Channel","url":"components/struct/co-channel.html","content":"协程 Channel目录基于 Swoole 提供的 Swoole\\Coroutine\\Channel，直接在配置文件中设置，就可以在worker进程中使用，数据互通。Swoole\\Coroutine\\Channel可以作为队列使用，支持多生产者协程和多消费者协程。底层自动实现了协程的切换和调度。仅 Swoole 可用配置方式在项目配置文件中加入以下节&#039;coroutineChannels&#039;    =&gt;    [\n    // 定义名为name1的，通道占用的内存的尺寸为64kb\n    // 当设置为0时，底层将不再设置缓冲区，push和pop操作会立即挂起当前协程。\n    &#039;name1&#039;    =&gt;    [64 * 1024],\n],使用方式use \\Imi\\Swoole\\Util\\CoroutineChannelManager;\n\n// 获取 Swoole\\Coroutine\\Channel 对象\n$channel = CoroutineChannelManager::getInstance(&#039;name1&#039;);\n\n// 向队列中加入一个成员\nCoroutineChannelManager::push(&#039;name1&#039;, &#039;test&#039;);\n// 还支持数组，等一切可以被序列化的值\nCoroutineChannelManager::push(&#039;name1&#039;, [1, 2, 3]);\n\n// 弹出一个成员，如果没有值则为false\n$result = CoroutineChannelManager::pop(&#039;name1&#039;);\n\n// 获取通道的状态\n$result = CoroutineChannelManager::stats(&#039;name&#039;);\n/*\n$result 格式如下：\n[\n    // 消费者数量，表示当前通道为空，有N个协程正在等待其他协程调用push方法生产数据\n    &#039;consumer_num&#039;    =&gt;    1,\n    // 生产者数量，表示当前通道已满，有N个协程正在等待其他协程调用pop方法消费数据\n    &#039;producer_num&#039;  =&gt;    1,\n    // 通道中的元素数量\n    &#039;queue_num&#039;    =&gt;    10,\n    // 通道当前占用的内存字节数\n    &#039;queue_bytes&#039;    =&gt;    1024,\n]\n*/\n\n// 关闭通道。并唤醒所有等待读写的协程。\nCoroutineChannelManager::close(&#039;name1&#039;);\n"},{"id":226,"title":"枚举","pageTitle":"枚举","url":"components/struct/enum.html","content":"枚举目录由于 PHP 本身不支持枚举类型，imi 特别基于注解实现了枚举类。枚举类定义继承Imi\\Enum\\BaseEnum类，然后在类常量上面写上注解@EnumItem，参数是当前常量的文字说明。&lt;?php\nnamespace ImiDemo\\HttpDemo\\MainServer\\Enum;\n\nuse Imi\\Enum\\BaseEnum;\nuse Imi\\Enum\\Annotation\\EnumItem;\n\nclass Status extends BaseEnum\n{\n    /**\n     * @EnumItem(&quot;正确&quot;)\n     */\n    const YES = 1;\n\n    /**\n     * @EnumItem(&quot;错误&quot;)\n     */\n    const NO = 0;\n}使用// 根据名称获得常量值\nStatus::getValue(&#039;YES&#039;);\n\n// 根据值获得文字说明\nStatus::getText(Status::YES);\n\n// 根据值获得 @EnumItem 注解对象\nStatus::getData(Status::YES);\n\n// 获取枚举类中所有名称\nStatus::getNames();\n\n// 获取枚举类中所有值\nStatus::getValues();\n\n// 验证值是否合法;true/false\nStatus::validate(Status::YES);\n\n// 验证值断言，值不合法会抛出异常: \\InvalidArgumentException\nStatus::assert(Status::YES);"},{"id":230,"title":"FilterableList","pageTitle":"FilterableList","url":"components/struct/FilterableList.html","content":"FilterableList目录过滤字段的列表，每一个成员应该是数组或对象$data = [\n    [&#039;id&#039;=&gt;1, &#039;name&#039;=&gt;&#039;a&#039;],\n    [&#039;id&#039;=&gt;2, &#039;name&#039;=&gt;&#039;b&#039;],\n];\n\n// 两个毫无意义的实例化写法\n$list = new FilterableList;\n$list = new FilterableList($data);\n// 只保留 name 字段\n$list = new FilterableList($data, [&#039;name&#039;]);\n$list = new FilterableList($data, [&#039;name&#039;], &#039;allow&#039;);\n// 剔除 name 字段\n$list = new FilterableList($data, [&#039;name&#039;], &#039;deny&#039;);\n\nforeach($list as $index =&gt; $item)\n{\n    var_dump($index, $item);\n}\n\n// 取其中某个成员\n$item0 = $list[0];\n\n// 转为数组\n$arrayList = $list-&gt;toArray();\nvar_dump($arrayList);\n\n// 移除多个成员\n$arrayList-&gt;remove($list[1], $list[2]);\n\n// 清空\n$arrayList-&gt;clear();\n\n// 统计数量\necho $arrayList-&gt;count();"},{"id":228,"title":"LazyArrayObject","pageTitle":"LazyArrayObject","url":"components/struct/LazyArrayObject.html","content":"LazyArrayObject目录同时可以作为数组和对象访问的类// $object = new \\Imi\\Util\\LazyArrayObject;\n$object = new \\Imi\\Util\\LazyArrayObject([\n    &#039;id&#039;    =&gt;  123,\n    &#039;name&#039;  =&gt;  &#039;imi&#039;,\n]);\n\n$object[&#039;id&#039;] = 111;\necho &#039;id:&#039;, $object-&gt;id, PHP_EOL;\n\n$object-&gt;id = 222;\necho &#039;id:&#039;, $object[&#039;id&#039;], PHP_EOL;\n\n$arrayData = $object-&gt;toArray();\nvar_dump($arrayData);"},{"id":234,"title":"MemoryTable","pageTitle":"MemoryTable","url":"components/struct/memory-table.html","content":"MemoryTable目录imi 支持 MemoryTableModel，也支持直接定义和操作MemoryTable。仅 Swoole 可用配置方法// 内存表配置\n&#039;memoryTable&#039;   =&gt;  [\n    // name =&gt; 配置\n    &#039;t1&#039;    =&gt;  [\n        // 定义字段\n        &#039;columns&#039;   =&gt;  [\n            [&#039;name&#039; =&gt; &#039;name&#039;, &#039;type&#039; =&gt; \\Swoole\\Table::TYPE_STRING, &#039;size&#039; =&gt; 16],\n            [&#039;name&#039; =&gt; &#039;quantity&#039;, &#039;type&#039; =&gt; \\Swoole\\Table::TYPE_INT],\n        ],\n        &#039;lockId&#039;    =&gt;  &#039;atomic&#039;, // 锁 ID，非必设。不配置就不允许使用锁，其它的可以正常用\n    ],\n    &#039;ConnectionContext&#039;    =&gt;  [\n        // 指定实现了 Imi\\Util\\MemoryTable\\IMemoryTableOption 接口的来，来定义表结构\n        &#039;class&#039; =&gt;  \\Imi\\Swoole\\Server\\ConnectionContext\\StoreHandler\\MemoryTable\\ConnectionContextOption::class,\n        &#039;lockId&#039;=&gt;  &#039;atomic&#039;, // 同上\n    ],\n],使用方法写入use Imi\\Swoole\\Util\\MemoryTableManager;\n$key = &#039;a&#039;; // 主键\n$value = [\n    &#039;name&#039;      =&gt;  &#039;abc&#039;,\n    &#039;quantity&#039;  =&gt;  123,\n];\nMemoryTableManager::set($tableName, $key, $value);读取// 获取一行\n$row = MemoryTableManager::get($tableName, $key);\n\n// 获取单个字段\n$field = &#039;quantity&#039;;\n$value = MemoryTableManager::get($tableName, $key, $field);删除MemoryTableManager::del($tableName, $key);数据行是否存在MemoryTableManager::exist($tableName, $key);原子自增MemoryTableManager::incr($tableName, $key, $field); // +1\nMemoryTableManager::incr($tableName, $key, $field, 123); // +123原子自减MemoryTableManager::decr($tableName, $key, $field); // -1\nMemoryTableManager::decr($tableName, $key, $field, 123); // -123获取行数MemoryTableManager::count($tableName);加锁执行需要配置 lockIdMemoryTableManager::lock($tableName, function(){\n    // 方法体内部都在锁中执行，执行完自动释放锁\n    $row = MemoryTableManager::get($tableName, $key);\n    $row[&#039;quantity&#039;] = 456;\n    MemoryTableManager::set($tableName, $key, $row);\n});实现 IMemoryTableOption 接口示例代码：&lt;?php\nnamespace Imi\\Swoole\\Server\\ConnectionContext\\StoreHandler\\MemoryTable;\n\nuse Imi\\Util\\MemoryTable\\IMemoryTableOption;\n\n/**\n * Swoole 内存表\n */\nclass ConnectionContextOption implements IMemoryTableOption\n{\n    /**\n     * 获取配置\n     *\n     * @return array\n     */\n    public function getOption($option = null): array\n    {\n        if(!$option)\n        {\n            $option = [];\n        }\n        if(!isset($option[&#039;size&#039;]))\n        {\n            $option[&#039;size&#039;] = 65536;\n        }\n        $option[&#039;columns&#039;] = [\n            [&#039;name&#039; =&gt; &#039;data&#039;, &#039;type&#039; =&gt; \\Swoole\\Table::TYPE_STRING, &#039;size&#039; =&gt; $option[&#039;dataLength&#039;] ?? 1024],\n        ];\n        return $option;\n    }\n\n}"},{"id":40,"title":"单端口支持 WebSocket+Http","pageTitle":"单端口支持 WebSocket+Http","url":"components/swoole/ws_and_http.html","content":"单端口支持 WebSocket+Http目录imi 框架原生支持在同一个项目中，使用一个服务器监听多个端口和协议，例如你要开发一个聊天系统，需要同时支持 HTTP 和 WebSocket 协议，imi 框架可以方便地实现这个功能。需要将服务器声明为 WebSocket 类型，主服务器或子服务器均可。在服务器配置文件中的 beans 配置 HttpDispatcher 和 WebSocketDispatcher 即可实现。这样，在同一个端口下，即可同时支持 HTTP 和 WebSocket 协议，实现代码复用和互相调用。&#039;HttpDispatcher&#039;    =&gt;    [\n    &#039;middlewares&#039;    =&gt;    [\n        \\Imi\\Server\\Http\\Middleware\\RouteMiddleware::class,\n    ],\n],\n&#039;WebSocketDispatcher&#039;    =&gt;    [\n    &#039;middlewares&#039;    =&gt;    [\n        \\Imi\\Server\\WebSocket\\Middleware\\RouteMiddleware::class,\n    ],\n],"},{"id":218,"title":"Swoole Tracker","pageTitle":"Swoole Tracker","url":"components/swoole-tracker.html","content":"Swoole Tracker目录介绍在 imi 框架中接入 Swoole Tracker 监控Swoole Tracker: https://business.swoole.com/tracker/index企业版集成了Facebook的Xhprof工具，可以生成调用堆栈图和火焰图，亦可生成分层分析表格，方便找到程序瓶颈点进行优化。为解决PHP常驻进程的内存泄漏问题，企业版专门针对PHP的内存泄漏检测工具，方便快速的解决和定位内存持续增长问题。Swoole异步/协程模式以及ReactPHP等众多框架最致命的就是阻塞调用，会让并发大大降低，为此我们开发了毫秒级阻塞检测工具，迅速定位导致阻塞的代码。自动抓取FPM、CLI进程数量，统计CPU、内存使用情况。所有工具零部署成本，后台一键开启关闭各种检测，完美支持PHP7。Swoole Tracker &gt;= v2.5.0 版本支持自动生成应用名称并创建应用，无需修改任何代码，生成的应用名称格式为：Swoole的HttpServer：ip:prot其他的Server：ip(hostname):prot即安装好swoole_tracker扩展之后就可以正常使用Swoole Tracker的功能组件基本使用在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-swoole-tracker&quot;: &quot;~2.1.0&quot;\n    }\n}执行 composer update 安装。在项目 config/config.php 中配置：[\n    &#039;components&#039;    =&gt;  [\n        // 引入本组件\n        &#039;SwooleTracker&#039;       =&gt;  &#039;Imi\\SwooleTracker&#039;,\n    ],\n]Http 服务在服务器的 config/config.php 中配置：[\n    &#039;beans&#039;    =&gt;    [\n        &#039;HttpDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                …… // 你的其他中间件\n                \\Imi\\Server\\Http\\Middleware\\RouteMiddleware::class,\n                &quot;SwooleTrackerHttpMiddleware&quot;, // 放在 RouteMiddlware 后\n            ],\n        ],\n        &#039;SwooleTrackerHttpMiddleware&#039;   =&gt;  [\n            &#039;serviceName&#039;   =&gt; &#039;imi-http-example&#039;, // 服务名\n            // &#039;serverIp&#039;      =&gt; null, // 服务器 IP，默认获取当前网卡 IP\n            // &#039;interface&#039;     =&gt; null, // 网卡 interface 名，自动获取当前网卡IP时有效\n            // &#039;successStatusCode&#039; =&gt; 200, // 成功的 Http 状态码\n        ],\n    ],\n];WebSocket 服务在服务器的 config/config.php 中配置：[\n    &#039;beans&#039;    =&gt;    [\n        &#039;WebSocketDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                …… // 你的其他中间件\n                \\Imi\\Server\\WebSocket\\Middleware\\RouteMiddleware::class,\n                &quot;SwooleTrackerWebSocketMiddleware&quot;, // 放在 RouteMiddlware 后\n            ],\n        ],\n        &#039;SwooleTrackerWebSocketMiddleware&#039;  =&gt;  [\n            &#039;serviceName&#039;       =&gt; &#039;imi-websocket-example&#039;, // 服务名\n            // &#039;serverIp&#039;          =&gt; null, // 服务器 IP，默认获取当前网卡 IP\n            // &#039;interface&#039;         =&gt; null, // 网卡 interface 名，自动获取当前网卡IP时有效\n            // &#039;successCode&#039;       =&gt;  500, // 当成功时上报的默认code\n            // &#039;exceptionCode&#039;     =&gt;  500, // 当发生异常时上报的默认code\n            // 指定获取请求方法名的参数，必须有\n            &#039;nameHandler&#039;       =&gt;  function(\\Imi\\Server\\WebSocket\\Message\\IFrame $frame){\n                return $frame-&gt;getFormatData()-&gt;action ?? &#039;unknown&#039;; // 代码仅供参考\n            },\n        ],\n    ],\n];TCP 服务在服务器的 config/config.php 中配置：[\n    &#039;beans&#039;    =&gt;    [\n        &#039;TcpDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                …… // 你的其他中间件\n                \\Imi\\Server\\TcpServer\\Middleware\\RouteMiddleware::class,\n                &quot;SwooleTrackerTCPMiddleware&quot;, // 放在 RouteMiddlware 后\n            ],\n        ],\n        &#039;SwooleTrackerTCPMiddleware&#039;  =&gt;  [\n            &#039;serviceName&#039;       =&gt; &#039;imi-tcp-example&#039;, // 服务名\n            // &#039;serverIp&#039;          =&gt; null, // 服务器 IP，默认获取当前网卡 IP\n            // &#039;interface&#039;         =&gt; null, // 网卡 interface 名，自动获取当前网卡IP时有效\n            // &#039;successCode&#039;       =&gt;  500, // 当成功时上报的默认code\n            // &#039;exceptionCode&#039;     =&gt;  500, // 当发生异常时上报的默认code\n            // 指定获取请求方法名的参数，必须有\n            &#039;nameHandler&#039;       =&gt;  function(\\Imi\\Server\\TcpServer\\Message\\IReceiveData $data){\n                return $data-&gt;getFormatData()-&gt;action ?? &#039;unknown&#039;; // 代码仅供参考\n            },\n        ],\n    ],\n];UDP 服务在服务器的 config/config.php 中配置：[\n    &#039;beans&#039;    =&gt;    [\n        &#039;UdpDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                …… // 你的其他中间件\n                \\Imi\\Server\\UdpServer\\Middleware\\RouteMiddleware::class,\n                &quot;SwooleTrackerUDPMiddleware&quot;, // 放在 RouteMiddlware 后\n            ],\n        ],\n        &#039;SwooleTrackerUDPMiddleware&#039;  =&gt;  [\n            &#039;serviceName&#039;       =&gt; &#039;imi-udp-example&#039;, // 服务名\n            // &#039;serverIp&#039;          =&gt; null, // 服务器 IP，默认获取当前网卡 IP\n            // &#039;interface&#039;         =&gt; null, // 网卡 interface 名，自动获取当前网卡IP时有效\n            // &#039;successCode&#039;       =&gt;  500, // 当成功时上报的默认code\n            // &#039;exceptionCode&#039;     =&gt;  500, // 当发生异常时上报的默认code\n            &#039;nameHandler&#039;       =&gt;  function(\\Imi\\Server\\UdpServer\\Message\\IPacketData $data){\n                return $data-&gt;getFormatData()-&gt;action ?? &#039;unknown&#039;; // 代码仅供参考\n            },\n        ],\n    ],\n];进阶使用如果请求产生异常，自动上报失败，错误码为异常 code。你也可以在代码中指定是否成功和错误码，例子：RequestContext::set(&#039;imi.tracker.success&#039;, false);\nRequestContext::set(&#039;imi.tracker.code&#039;, 19260817);"},{"id":177,"title":"定时任务","pageTitle":"定时任务","url":"components/task/cron.html","content":"定时任务目录说明在实际项目中，我们经常会有一些任务是需要定时执行的。虽然有 cron、crontab、systemd 等系统级内置的，定时任务工具存在。但是他们的一些让人掉头发的配置写法，以及增加运维心智负担，无法适应多实例部署场景等等原因，势必需要在 imi 框架中提供这个功能。设计imi 通过增加一个 CronProcess 进程用于定时任务的调度和执行，使用 Redis 作为数据存储。定时任务支持在以下进程中执行： Task 进程、Worker 进程，也支持新运行一个 Process 进程。支持设置某进程在当前实例/多实例中只运行一个。使用启用定时任务进程必须在项目 config.php 的 beans 中加入配置启用定时任务进程，否则所有定时任务都无法生效。配置代码：&#039;AutoRunProcessManager&#039;   =&gt;  [\n    &#039;processes&#039; =&gt;  [\n        &#039;CronProcess&#039;,\n    ],\n],定义任务协程任务实现 Imi\\Cron\\Contract\\ICronTask 接口、run() 方法，无需手动上报任务完成。&lt;?php\nnamespace Imi\\Test\\HttpServer\\Cron;\n\nuse Imi\\Cron\\Annotation\\Cron;\nuse Imi\\Cron\\Contract\\ICronTask;\n\n/**\n * @Cron(id=&quot;CronRandomWorker&quot;, second=&quot;3n&quot;, type=&quot;random_worker&quot;)\n */\nclass CronRandomWorker implements ICronTask\n{\n    /**\n     * 执行任务\n     *\n     * @param string $id\n     * @param mixed $data\n     * @return void\n     */\n    public function run(string $id, $data): void\n    {\n        var_dump(&#039;random&#039;);\n    }\n\n}Task 任务使用task定时任务时，需要在项目config.php中的服务器配置里，开启task_worker_num参数，否则会报下面的错：Uncaught ErrorException: Swoole\\Server::task(): task method can't be executed without task worker// 主服务器配置\n&#039;mainServer&#039;    =&gt;    [\n    &#039;namespace&#039;    =&gt;    &#039;ImiApp\\ApiServer&#039;,\n    &#039;type&#039;        =&gt;    Imi\\Server\\Type::HTTP,\n    &#039;host&#039;        =&gt;    &#039;0.0.0.0&#039;,\n    &#039;port&#039;        =&gt;    9501,\n    &#039;configs&#039;    =&gt;    [\n        // &#039;worker_num&#039;        =&gt;  8,\n        &#039;task_worker_num&#039;   =&gt;  16, // 必须开启这个参数，否则报错\n    ],\n],与异步任务写法基本一致，多了@Cron注解，并且需要上报任务完成！&lt;?php\nnamespace Imi\\Test\\HttpServer\\Cron;\n\nuse Imi\\Swoole\\Task\\TaskParam;\nuse Imi\\Cron\\Annotation\\Cron;\nuse Imi\\Swoole\\Task\\Annotation\\Task;\nuse Imi\\Cron\\Util\\CronUtil;\nuse Imi\\Swoole\\Task\\Interfaces\\ITaskHandler;\n\n/**\n * @Cron(id=&quot;TaskCron&quot;, second=&quot;3n&quot;, data={&quot;id&quot;:&quot;TaskCron&quot;})\n * @Task(&quot;CronTask1&quot;)\n */\nclass TaskCron implements ITaskHandler\n{\n    /**\n     * 任务处理方法.\n     *\n     * @return mixed\n     */\n    public function handle(TaskParam $param, \\Swoole\\Server $server, int $taskId, int $workerId)\n    {\n        // 上报任务完成\n        CronUtil::reportCronResult($param-&gt;getData()[&#039;id&#039;], true, &#039;&#039;);\n        return date(&#039;Y-m-d H:i:s&#039;);\n    }\n\n    /**\n     * 任务结束时触发.\n     *\n     * @param mixed $data\n     */\n    public function finish(\\Swoole\\Server $server, int $taskId, $data): void\n    {\n    }\n\n}Process 任务与进程写法基本一致，多了@Cron注解，并且需要上报任务完成！&lt;?php\nnamespace Imi\\Test\\HttpServer\\Cron;\n\nuse Imi\\Cli\\ImiCommand;\nuse Imi\\Util\\Args;\nuse Imi\\Swoole\\Process\\Contract\\IProcess;\nuse Imi\\Cron\\Annotation\\Cron;\nuse Imi\\Cron\\Util\\CronUtil;\nuse Imi\\Swoole\\Process\\Annotation\\Process;\nuse Swoole\\Event;\n\n/**\n * @Cron(id=&quot;CronProcess1&quot;, second=&quot;3n&quot;)\n * @Process(&quot;CronProcess1&quot;)\n */\nclass TaskProcess implements IProcess\n{\n    public function run(\\Swoole\\Process $process): void\n    {\n        $success = false;\n        $message = &#039;&#039;;\n        // 获取任务 ID\n        $input = ImiCommand::getInput();\n        $id = $input-&gt;getParameterOption(&#039;--id&#039;);\n        if (false === $id)\n        {\n            return;\n        }\n        try\n        {\n            // 做一些事情\n            // ...\n\n            $success = true;\n        }\n        catch (\\Throwable $th)\n        {\n            $message = $th-&gt;getMessage();\n            throw $th;\n        }\n        finally\n        {\n            // 上报任务完成\n            CronUtil::reportCronResult($id, $success, $message);\n        }\n    }\n\n}定时规则支持注解设定和配置文件设定两种模式，其中配置文件设定，是可以覆盖注解设定的。注解设定注解 @Cron，类 Imi\\Cron\\Annotation\\Cron@Cron(id=&quot;任务唯一ID&quot;, type=&quot;&quot;, year=&quot;&quot;, month=&quot;&quot;, day=&quot;&quot;, hour=&quot;&quot;, minute=&quot;&quot;, second=&quot;&quot;, unique=null, redisPool=&quot;&quot;, lockWaitTimeout=&quot;&quot;, maxExecutionTime=&quot;&quot;, force=false, delayMin=0, delayMax=0, successLog=true)属性id:使用@Cron注解时的任务唯一ID。如果是 Task、Process，默认使用 Task 或 Process + 名称。type:任务类型可选：random_worker-随机工作进程任务all_worker-所有工作进程执行的任务task-后台任务process-进程cron_process-定时任务进程force:每次启动服务强制执行，默认为falseyear:指定任务执行年份，默认为 *。* - 不限制2019 - 指定年2019-2022 - 指定年份区间2019,2021,2022 - 指定多个年份2n - 每 2 年，其它以此类推取值范围：&gt;=1 and &lt;= 2100，不在范围内会抛出异常。在 imi 3.0 中会考虑移除最大到 2100 年的限制。（不过真的有项目能跑到那个时候吗？）month:指定任务执行月份，默认为 *。* - 不限制1 (1 月), -1 (12 月) - 指定月份，支持负数为倒数的月1-6 (1-6 月), -3--1 (10-12 月) - 指定月份区间，支持负数为倒数的月1,3,5,-1 (1、3、5、12 月) - 指定多个月份，支持负数为倒数的月2n - 每 2 个月，其它以此类推取值范围：&gt;=1 and &lt;= 12，不在范围内会抛出异常。day:指定任务执行日期，默认为 *。* - 不限制1 (1 日), -1 (每月最后一天) - 指定日期，支持负数为倒数的日期1-6 (1-6 日), -3--1 (每月倒数 3 天) - 指定日期区间，支持负数为倒数的日期1,3,5,-1 (每月 1、3、5、最后一天) - 指定多个日期，支持负数为倒数的日期2n - 每 2 天，其它以此类推year 1 (一年中的第 1 日), year -1 (每年最后一天) - 指定一年中的日期，支持负数为倒数的日期1-6 (一年中的第 1-6 日), -3--1 (每年倒数 3 天) - 指定一年中的日期区间，支持负数为倒数的日期year 1-6 (一年中的第 1-6 日), year -3--1 (每年倒数 3 天) - 指定一年中的日期区间，支持负数为倒数的日期1,3,5,-1 (每年 1、3、5、最后一天) - 指定一年中的多个日期，支持负数为倒数的日期year 1,3,5,-1 (每年 1、3、5、最后一天) - 指定一年中的多个日期，支持负数为倒数的日期取值范围：&gt;=1 and &lt;= 31，不在范围内会抛出异常。带 year 的取值范围：&gt;=1 and &lt;= 366，不在范围内会抛出异常。week:指定周几执行任务，默认为 *。* - 不限制1 (周一), -1 (周日) - 指定周几（1-7），支持负数为倒数的周1-6 (周一到周六), -3--1 (周五到周日) - 指定周几，支持负数为倒数的周1,3,5,-1 (周一、三、五、日) - 指定多个日期，支持负数为倒数的周取值范围：&gt;=1 and &lt;= 7，不在范围内会抛出异常。hour:指定任务执行小时，默认为 *。* - 不限制0 (0 点), -1 (23 点) - 指定小时，支持负数为倒数的小时1-6 (1-6 店), -3--1 (21-23 点) - 指定小时区间，支持负数为倒数的小时1,3,5,-1 (1、3、5、23 点) - 指定多个小时，支持负数为倒数的小时2n - 每 2 小时，其它以此类推取值范围：&gt;=0 and &lt;= 23，不在范围内会抛出异常。minute:指定任务执行分钟，默认为 *。* - 不限制0 (0 分), -1 (59 分) - 指定分钟，支持负数为倒数的分钟1-6 (1-6 分), -3--1 (57-59 分) - 指定分钟区间，支持负数为倒数的分钟1,3,5,-1 (1、3、5、59 分) - 指定多个分钟，支持负数为倒数的分钟2n - 每 2 分钟，其它以此类推取值范围：&gt;=0 and &lt;= 59，不在范围内会抛出异常。second:指定任务执行秒，默认为 *。* - 不限制0 (0 秒), -1 (59 秒) - 指定秒，支持负数为倒数的秒1-6 (1-6 秒), -3--1 (57-59 秒) - 指定秒区间，支持负数为倒数的秒1,3,5,-1 (1、3、5、59 秒) - 指定多个秒，支持负数为倒数的秒2n - 每 2 秒，其它以此类推取值范围：&gt;=0 and &lt;= 59，不在范围内会抛出异常。unique:定时任务唯一性设置当前实例唯一: current所有实例唯一: all不唯一: nullredisPool:用于锁的 Redis 连接池名lockWaitTimeout:获取锁超时时间，单位：秒maxExecutionTime:最大运行执行时间，单位：秒。该值与分布式锁超时时间共享，默认为 60 秒delayMin、delayMax:最小、最大延迟执行秒数，默认为0。如果有一项不为0，该定时任务就会根据两个值之间的随机秒数（包含两个值），提前或者延后执行。这两个设置主要是防止固定时间执行任务过多，起到分流作用。successLog:是否记录成功日志，默认为 true配置文件设定项目配置文件，beans 节中配置[\n    &#039;CronManager&#039;   =&gt;  [\n        // 启用任务进程终端输出\n        &#039;stdOutput&#039; =&gt; true,\n        // 任务列表定义\n        &#039;tasks&#039; =&gt;  [\n            // 任务唯一ID\n            &#039;taskName&#039;  =&gt;  [\n                // 任务类型，可选：worker-工作进程任务; task-任务; process-进程\n                &#039;type&#039;      =&gt;  &#039;worker&#039;,\n                // 任务执行回调，可以是callable类型，也可以是 task、process 名\n                &#039;task&#039;      =&gt;  mixed,\n                // 定时配置\n                &#039;cron&#039;     =&gt;  [\n                    // 支持多个条件去触发\n                    // 规则同 @Cron 注解\n                    [\n                        &#039;year&#039;  =&gt;  &#039;&#039;,\n                        &#039;month&#039; =&gt;  &#039;&#039;,\n                        &#039;day&#039;   =&gt;  &#039;&#039;,\n                        &#039;week&#039;  =&gt;  &#039;&#039;,\n                        &#039;hour&#039;  =&gt;  &#039;&#039;,\n                        &#039;minute&#039;=&gt;  &#039;&#039;,\n                        &#039;second&#039;=&gt;  &#039;&#039;,\n                    ],\n                ],\n                // 可选配置\n                &#039;data&#039;              =&gt;  null,\n                &#039;unique&#039;            =&gt;  null,\n                &#039;redisPool&#039;         =&gt;  &#039;redis&#039;,\n                &#039;lockWaitTimeout&#039;   =&gt;  10,\n                &#039;maxExecutionTime&#039;  =&gt;  120,\n                &#039;force&#039;             =&gt;  false,\n            ],\n        ],\n    ],\n]动态维护增加定时任务use Imi\\Cron\\Util\\CronUtil;\nuse Imi\\Cron\\Annotation\\Cron;\nuse Imi\\Test\\HttpServer\\Cron\\CronDWorker;\n\n$cron = new Cron;\n$cron-&gt;id = &#039;CronRandomWorkerTest&#039;;\n$cron-&gt;second = &#039;3n&#039;;\n$cron-&gt;type = &#039;random_worker&#039;;\nCronUtil::addCron($cron, CronDWorker::class);移除定时任务use Imi\\Cron\\Util\\CronUtil;\n\nCronUtil::removeCron(&#039;任务ID&#039;);移除所有任务use Imi\\Cron\\Util\\CronUtil;\n\nCronUtil::clear();检测是否存在任务use Imi\\Cron\\Util\\CronUtil;\n\n$hasTasks = CronUtil::hasTask(&#039;任务ID&#039;);\necho &quot;任务ID是否存在: $hasTasks&quot;;获取单个任务use Imi\\Cron\\Util\\CronUtil;\n\n$task = CronUtil::getTask(&#039;任务ID&#039;);\necho &quot;任务#$task-&gt;id : $task-&gt;task&quot;;注：TaskMsg对象属性如下：参数类型说明idstring任务IDtypestring任务类型taskstring任务类cronRulesarray[CronRuleOjbect]运行规则dataarray运行参数unique['current','all',null]唯一性设置redisPoolstring锁连接池名lockWaitTimeoutfloat锁超时时间maxExecutionTimefloat最大运行执行时间lastRunTimeint最近执行时间戳forcebool是否启动服务强制执行获取所有任务use Imi\\Cron\\Util\\CronUtil;\n\n$realTasks = CronUtil::getRealTasks();\n\nforeach ($realTasks as $taskName =&gt; $task) {\n    echo &quot;任务#$taskName : $task-&gt;id&quot;;\n}"},{"id":176,"title":"后台任务","pageTitle":"后台任务","url":"components/task/index.html","content":"后台任务目录说明后台任务仅支持 Swoole配置项目配置文件中mainServer.configs.task_worker_num一定要配置为大于0，否则无法使用后台任务。定义任务执行类&lt;?php\nnamespace Test;\n\nuse Imi\\Swoole\\Task\\TaskParam;\nuse Imi\\Swoole\\Task\\Interfaces\\ITaskHandler;\n\nclass Test implements ITaskHandler\n{\n    /**\n     * 任务处理方法.\n     *\n     * @return mixed\n     */\n    public function handle(TaskParam $param, \\Swoole\\Server $server, int $taskId, int $workerId)\n    {\n        // 投递任务时的数据\n        $data = $param-&gt;getData();\n    }\n\n    /**\n     * 任务结束时触发.\n     *\n     * @param mixed $data\n     */\n    public function finish(\\Swoole\\Server $server, int $taskId, $data): void\n    {\n        \n    }\n}类名无所谓，实现ITaskHandler接口和两个方法即可。投递任务对象投递异步任务对象TaskManager::post(new TaskInfo(\n    // 上面定义的类的实例\n    new TestTask,\n    // 执行任务的参数，构造方法可以接收一个数组\n    new TaskParam([\n        &#039;time&#039;    =&gt;    time(),\n    ])\n));调用后立即返回，不影响下面代码的执行同步投递任务对象TaskManager::postWait(new TaskInfo(\n    // 上面定义的类的实例\n    new TestTask,\n    // 执行任务的参数，构造方法可以接收一个数组\n    new TaskParam([\n        &#039;time&#039;    =&gt;    time(),\n    ])),\n    // 最长等待时间，单位：秒\n    0.5\n);投递任务后阻塞等待执行完毕或超时，返回值为任务执行结果或false协程批量投递任务对象TaskManager::postCo([new TaskInfo(\n    // 上面定义的类的实例\n    new TestTask,\n    // 执行任务的参数，构造方法可以接收一个数组\n    new TaskParam([\n        &#039;time&#039;    =&gt;    time(),\n    ])\n)],\n// 最长等待时间，单位：秒\n0.5);传入数组和超时时间，投递后挂起协程，当全部执行完毕或超时后返回结果。返回值为数组，对应每个任务的执行结果。注解注解定义任务执行类&lt;?php\nnamespace Test;\n\nuse Imi\\Swoole\\Task\\TaskParam;\nuse Imi\\Swoole\\Task\\Annotation\\Task;\nuse Imi\\Swoole\\Task\\Interfaces\\ITaskHandler;\n\n/**\n * @Task(&quot;testTask&quot;)\n */\nclass Test implements ITaskHandler\n{\n    /**\n     * 任务处理方法.\n     *\n     * @return mixed\n     */\n    public function handle(TaskParam $param, \\Swoole\\Server $server, int $taskId, int $workerId)\n    {\n        // 投递任务时的数据\n        $data = $param-&gt;getData();\n    }\n\n    /**\n     * 任务结束时触发.\n     *\n     * @param mixed $data\n     */\n    public function finish(\\Swoole\\Server $server, int $taskId, $data): void\n    {\n        \n    }\n}类名无所谓，实现ITaskHandler接口和两个方法即可。投递任务投递异步任务TaskManager::nPost(\n// 任务名称\n&#039;testTask&#039;\n// 任务参数\n, [\n    &#039;time&#039;    =&gt;    time(),\n]\n);调用后立即返回，不影响下面代码的执行同步投递任务TaskManager::nPostWait(\n    // 任务名称\n    &#039;testTask&#039;\n    // 任务参数\n    , [\n        &#039;time&#039;    =&gt;    time(),\n    ]\n    // 最长等待时间，单位：秒\n    0.5\n);投递任务后阻塞等待执行完毕或超时，返回值为任务执行结果或false协程批量投递任务TaskManager::postCo([\n    [&#039;testTask&#039;, [&#039;time&#039;=&gt;time()]],\n    [&#039;testTask&#039;, [&#039;time&#039;=&gt;time()]],\n],\n// 最长等待时间，单位：秒\n0.5);"},{"id":100,"title":"TCP 控制器","pageTitle":"TCP 控制器","url":"components/tcpServer/controller.html","content":"TCP 控制器目录定义&lt;?php\nnamespace ImiDemo\\TcpDemo\\MainServer\\Controller;\n\nuse Imi\\ConnectionContext;\nuse Imi\\Server\\TcpServer\\Route\\Annotation\\TcpRoute;\nuse Imi\\Server\\TcpServer\\Route\\Annotation\\TcpAction;\nuse Imi\\Server\\TcpServer\\Route\\Annotation\\TcpController;\n\n/**\n * 数据收发测试\n * @TcpController\n */\nclass Test extends \\Imi\\Controller\\TcpController\n{\n    /**\n     * 登录\n     * \n     * @TcpAction\n     * @TcpRoute({&quot;action&quot;=&quot;login&quot;})\n     * @return void\n     */\n    public function login($data)\n    {\n        ConnectionContext::set(&#039;username&#039;, $data-&gt;username);\n        $this-&gt;server-&gt;joinGroup(&#039;g1&#039;, $this-&gt;data-&gt;getClientId());\n        return [&#039;action&#039;=&gt;&#039;login&#039;, &#039;success&#039;=&gt;true];\n    }\n}首先控制器类必须有@TcpController注解，对应动作必须有@TcpAction和@TcpRoute注解。注解@TcpController注释目标：类表明一个类是控制器类属性名称说明server指定当前控制器允许哪些服务器使用。支持字符串或数组，默认为 null 则不限制@TcpRoute指定 Tcp 路由解析规则。// 解析 $data[&#039;action&#039;] === &#039;login&#039;\n@TcpRoute({&quot;action&quot;=&quot;login&quot;})\n// 解析 $data[&#039;a&#039;][&#039;b&#039;][&#039;c&#039;] === &#039;login&#039;\n@TcpRoute({&quot;a.b.c&quot;=&quot;login&quot;})\n// 解析 $data[&#039;a&#039;] == &#039;1&#039; &amp;&amp; $data[&#039;b&#039;] == &#039;2&#039;\n@TcpRoute({&quot;a&quot;=&quot;1&quot;, &quot;b&quot;=&quot;2&quot;})当然对象也是支持的：// 解析 $data-&gt;a-&gt;b-&gt;c === &#039;login&#039;\n@TcpRoute({&quot;a.b.c&quot;=&quot;login&quot;})路由匹配成功，就会执行这个动作。动作响应数据响应当前这个请求直接在方法中返回一个数组或对象，在服务器配置设定的处理器，就会把这个转为对应数据响应给客户端。响应数据：return [&#039;success&#039;=&gt;true];分组发送$this-&gt;server-&gt;groupCall(&#039;组名&#039;, &#039;push&#039;, [&#039;success&#039;=&gt;true]);当然，并不是每个请求都需要有响应数据，什么都不return或者return null就是不响应数据。类属性$server详见：https://doc.imiphp.com/v2.1/core/server.html$data当然，你还可以直接通过请求上下文代理类，在任意地方使用：\\Imi\\Server\\TcpServer\\Message\\Proxy\\ReceiveDataProxy::getFormatData();方法/**\n * 获取客户端的socket id\n * @return int|string\n */\npublic function getClientId();/**\n * 数据内容，可以是文本内容也可以是二进制数据，可以通过opcode的值来判断\n * @return string\n */\npublic function getData();/**\n * 获取格式化后的数据，一般是数组或对象\n * @return mixed\n */\npublic function getFormatData();/**\n * 获取客户端地址\n */\npublic function getClientAddress(): \\Imi\\Util\\Socket\\IPEndPoint;控制器类方法encodeMessage/**\n * 编码消息，把数据编码为发送给客户端的格式\n *\n * @param mixed $data\n * @return mixed\n */\nprotected function encodeMessage($data)"},{"id":97,"title":"错误异常处理","pageTitle":"错误异常处理","url":"components/tcpServer/error.html","content":"错误异常处理目录当程序出现错误或者异常时，我们一般会希望在开发时输出报错信息，在生产环境时隐藏详细的信息。在 imi 中，提供了 Tcp 服务的错误异常默认处理器支持。默认 Tcp 错误处理器：无指定默认处理器配置文件中：return [\n    &#039;beans&#039;    =&gt; [\n        &#039;TcpErrorHandler&#039; =&gt; [\n            // 指定默认处理器\n            &#039;handler&#039; =&gt; \\app\\Error\\TcpErrorHandler::class,\n        ],\n    ],\n];编写处理器如下代码所示，实现IErrorHandler接口，handle()方法返回值为true时则取消继续抛出异常。&lt;?php\nnamespace app\\Error;\n\nuse Imi\\Server\\TcpServer\\Error\\IErrorHandler;\n\nclass TcpErrorHandler implements IErrorHandler\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function handle(\\Throwable $throwable): bool\n    {\n        // 做处理\n        return true;\n    }\n}"},{"id":101,"title":"中间件","pageTitle":"中间件","url":"components/tcpServer/middleware.html","content":"中间件目录开发者可以开发中间件类，对整个TCP请求和响应过程进行自定义处理。注意！最好不要在中间件中使用类属性，可能会造成冲突！定义中间件&lt;?php\nnamespace Imi\\Server\\TcpServer\\Middleware;\n\nuse Imi\\Bean\\Annotation\\Bean;\n\n/**\n * @Bean\n */\nclass RouteMiddleware implements IMiddleware\n{\n    /**\n     * 处理方法\n     *\n     * @param IReceiveData $data\n     * @param IReceiveHandler $handle\n     * @return void\n     */\n    public function process(IReceiveData $data, IReceiveHandler $handler)\n    {\n        // 前置处理\n        \n        // 先执行其它中间件\n        $result = $handler-&gt;handle($data);\n        \n        // 后置处理\n        \n        return $result;\n    }\n\n}全局中间件return [\n    &#039;beans&#039;    =&gt;    [\n        // 中间件\n        &#039;TcpDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                // 中间件\n                \\Imi\\Server\\Tcp\\Middleware\\RouteMiddleware::class,\n            ],\n        ],\n    ],\n];局部中间件注解使用&lt;?php\nnamespace ImiDemo\\TcpDemo\\MainServer\\Controller;\n\nuse Imi\\ConnectionContext;\nuse Imi\\Server\\TcpServer\\Route\\Annotation\\TcpRoute;\nuse Imi\\Server\\TcpServer\\Route\\Annotation\\TcpAction;\nuse Imi\\Server\\TcpServer\\Route\\Annotation\\TcpController;\n\n/**\n * 数据收发测试\n * @TcpController\n */\nclass Test extends \\Imi\\Controller\\TcpController\n{\n    /**\n     * 登录\n     * \n     * @TcpAction\n     * @TcpRoute({&quot;action&quot;=&quot;login&quot;})\n     * @TcpMiddleware(XXX::class)\n     * @TcpMiddleware({XXX::class,XXX2::class})\n     * @return void\n     */\n    public function login($data)\n    {\n    }\n}如上代码，同时支持设置单个和多个中间件中间件分组服务器 config.php：return [\n    &#039;middleware&#039;    =&gt;  [\n        &#039;groups&#039;    =&gt;  [\n            // 组名\n            &#039;test&#039;  =&gt;  [\n                // 中间件列表\n                \\Imi\\Test\\HttpServer\\ApiServer\\Middleware\\Middleware4::class,\n            ],\n        ],\n    ],\n];"},{"id":105,"title":"不使用中间件","pageTitle":"不使用中间件","url":"components/tcpServer/noMiddleware.html","content":"不使用中间件目录imi中内置实现了中间件+控制器方式开发tcp，在一些场景也可以选择不使用，直接监听服务器的receive事件，进行手动处理。监听写法&lt;?php\nnamespace Imi\\Server\\TcpServer\\Listener;\n\nuse Imi\\App;\nuse Imi\\ConnectionContext;\nuse Imi\\RequestContext;\nuse Imi\\Bean\\Annotation\\ClassEventListener;\nuse Imi\\Swoole\\Server\\Event\\Param\\ReceiveEventParam;\nuse Imi\\Swoole\\Server\\Event\\Listener\\IReceiveEventListener;\nuse Imi\\Server\\TcpServer\\Message\\ReceiveData;\n\n/**\n * Receive事件前置处理\n * @ClassEventListener(className=&quot;Imi\\Swoole\\Server\\TcpServer\\Server&quot;,eventName=&quot;receive&quot;,priority=PHP_INT_MAX)\n */\nclass BeforeReceive implements IReceiveEventListener\n{\n    /**\n     * 事件处理方法\n     * @param ReceiveEventParam $e\n     * @return void\n     */\n    public function handle(ReceiveEventParam $e): void\n    {\n        // 如果服务器名不是主服务器就返回\n        if(&#039;main&#039; === $e-&gt;server-&gt;getName())\n        {\n            return;\n        }\n        var_dump($e-&gt;data);\n    }\n}"},{"id":99,"title":"路由","pageTitle":"路由","url":"components/tcpServer/route.html","content":"路由目录启用路由服务器配置文件中加入中间件：return [\n    &#039;beans&#039;    =&gt;    [\n        &#039;TcpDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                \\Imi\\Server\\TcpServer\\Middleware\\RouteMiddleware::class,\n            ],\n        ],\n    ],\n];通过配置注入形式，实现非常灵活的配置，你甚至可以自己另外实现路由中间件，而不用被框架自带的中间件所影响，用哪些中间件都在你的掌控之中！获取当前路由解析结果 (routeResult)$routeResult = RequestContext::get(&#039;routeResult&#039;);$routeResult 定义：/**\n * 路由配置项\n *\n * @var \\Imi\\Server\\TcpServer\\Route\\RouteItem\n */\npublic $routeItem;\n\n/**\n * 参数\n *\n * @var array\n */\npublic $params;\n\n/**\n * 回调\n *\n * @var callable\n */\npublic $callable;$routeResult-&gt;routeItem 定义：/**\n * 注解\n *\n * @var \\Imi\\Server\\TcpServer\\Route\\Annotation\\TcpRoute\n */\npublic $annotation;\n\n/**\n * 回调\n *\n * @var callable\n */\npublic $callable;\n\n/**\n * 中间件列表\n *\n * @var array\n */\npublic $middlewares = [];\n\n/**\n * 其它配置项\n *\n * @var array\n */\npublic $options;"},{"id":204,"title":"TDengine","pageTitle":"TDengine","url":"components/tdengine.html","content":"TDengine目录TDengine 介绍TDengine 是一款开源、高性能、云原生的时序数据库，且针对物联网、车联网、工业互联网、金融、IT 运维等场景进行了优化。TDengine 的代码，包括集群功能，都在 GNU AGPL v3.0 下开源。除核心的时序数据库功能外，TDengine 还提供缓存、数据订阅、流式计算等其它功能以降低系统复杂度及研发和运维成本。项目地址：https://github.com/taosdata/TDengineimi-tdengine封装 tdengine 连接池，支持在 imi 框架中使用。本组件支持 RESTful 和扩展两种方式实现。扩展安装请移步：https://github.com/Yurunsoft/php-tdengine使用引入本组件：composer require imiphp/imi-tdengine配置项目配置文件：(config/config.php)// Swoole 连接池配置，非 Swoole 不要配\n// 连接池必须使用扩展\n&#039;pools&#039;    =&gt; [\n    &#039;连接池名&#039;    =&gt; [\n        &#039;pool&#039;    =&gt; [\n            &#039;class&#039;        =&gt; \\Imi\\TDengine\\Pool\\TDengineExtensionCoroutinePool::class,\n            &#039;config&#039;       =&gt; [\n                &#039;maxResources&#039;    =&gt; 10,\n                &#039;minResources&#039;    =&gt; 0,\n            ],\n        ],\n        &#039;resource&#039;    =&gt; [\n            &#039;host&#039;            =&gt; &#039;127.0.0.1&#039;,\n            &#039;port&#039;            =&gt; 6030,\n            &#039;user&#039;            =&gt; &#039;root&#039;,\n            &#039;password&#039;        =&gt; &#039;taosdata&#039;,\n            &#039;db&#039;              =&gt; &#039;db_test&#039;,\n        ],\n    ],\n],\n\n&#039;beans&#039; =&gt; [\n    // db 配置\n    &#039;TDengine&#039; =&gt; [\n        &#039;defaultPoolName&#039; =&gt; &#039;默认连接名&#039;,\n        &#039;connections&#039;     =&gt; [\n            // 扩展配置，不需要可不配\n            &#039;连接名1&#039; =&gt; [\n                &#039;extension&#039;       =&gt; true, // 必须设为 true\n                &#039;host&#039;            =&gt; &#039;127.0.0.1&#039;,\n                &#039;port&#039;            =&gt; 6030,\n                &#039;user&#039;            =&gt; &#039;root&#039;,\n                &#039;password&#039;        =&gt; &#039;taosdata&#039;,\n                &#039;db&#039;              =&gt; &#039;db_test&#039;,\n            ],\n            // restful 配置，不需要可不配\n            &#039;连接名2&#039; =&gt; [\n                &#039;host&#039;            =&gt; &#039;127.0.0.1&#039;,\n                &#039;hostName&#039;        =&gt; &#039;&#039;, // 域名，没有可不填\n                &#039;port&#039;            =&gt; 6041,\n                &#039;user&#039;            =&gt; &#039;root&#039;,\n                &#039;password&#039;        =&gt; &#039;taosdata&#039;,\n                &#039;db&#039;              =&gt; &#039;db_test&#039;\n                &#039;ssl&#039;             =&gt; false,\n                &#039;timestampFormat&#039; =&gt; \\Yurun\\TDEngine\\Constants\\TimeStampFormat::LOCAL_STRING,\n                &#039;keepAlive&#039;       =&gt; true,\n            ],\n        ],\n    ],\n],模型使用参考：https://github.com/Yurunsoft/tdengine-orm连接操作直接操作连接对象，执行 SQL 语句获取连接对象// 获取默认连接名的连接\n$connection = \\Imi\\TDengine\\Pool\\TDengine::getConnection();\n// 获取指定连接名的连接\n$connection = \\Imi\\TDengine\\Pool\\TDengine::getConnection(&#039;连接名123&#039;);\n// 如果是扩展，$connection 类型为 \\TDengine\\Connection\n// 如果是 restful，$connection 类型为 \\Yurun\\TDEngine\\Client扩展用法查询：// 查询\n$resource = $connection-&gt;query($sql); // 支持查询和插入\n// 获取结果集时间戳字段的精度，0 代表毫秒，1 代表微秒，2 代表纳秒\n$resource-&gt;getResultPrecision();\n// 获取所有数据\n$resource-&gt;fetch();\n// 获取一行数据\n$resource-&gt;fetchRow();\n// 获取字段数组\n$resource-&gt;fetchFields();\n// 获取列数\n$resource-&gt;getFieldCount();\n// 获取影响行数\n$resource-&gt;affectedRows();\n// 获取 SQL 语句\n$resource-&gt;getSql();\n// 获取连接对象\n$resource-&gt;getConnection();\n// 关闭资源（一般不需要手动关闭，变量销毁时会自动释放）\n$resource-&gt;close();参数绑定：// 查询\n$stmt = $connection-&gt;prepare($sql); // 支持查询和插入，参数用?占位\n// 绑定参数方法1\n$stmt-&gt;bindParams(\n    // [字段类型, 值]\n    [TDengine\\TSDB_DATA_TYPE_TIMESTAMP, $time1],\n    [TDengine\\TSDB_DATA_TYPE_INT, 36],\n    [TDengine\\TSDB_DATA_TYPE_FLOAT, 44.5],\n);\n// 绑定参数方法2\n$stmt-&gt;bindParams([\n    // [&#039;type&#039; =&gt; 字段类型, &#039;value&#039; =&gt; 值]\n    [&#039;type&#039; =&gt; TDengine\\TSDB_DATA_TYPE_TIMESTAMP, &#039;value&#039; =&gt; $time2],\n    [&#039;type&#039; =&gt; TDengine\\TSDB_DATA_TYPE_INT, &#039;value&#039; =&gt; 36],\n    [&#039;type&#039; =&gt; TDengine\\TSDB_DATA_TYPE_FLOAT, &#039;value&#039; =&gt; 44.5],\n]);\n// 执行 SQL，返回 Resource，使用方法同 query() 返回值\n$resource = $stmt-&gt;execute();\n// 获取 SQL 语句\n$stmt-&gt;getSql();\n// 获取连接对象\n$stmt-&gt;getConnection();\n// 关闭（一般不需要手动关闭，变量销毁时会自动释放）\n$stmt-&gt;close();字段类型：参数名称说明TDengine\\TSDB_DATA_TYPE_NULLnullTDengine\\TSDB_DATA_TYPE_BOOLboolTDengine\\TSDB_DATA_TYPE_TINYINTtinyintTDengine\\TSDB_DATA_TYPE_SMALLINTsmallintTDengine\\TSDB_DATA_TYPE_INTintTDengine\\TSDB_DATA_TYPE_BIGINTbigintTDengine\\TSDB_DATA_TYPE_FLOATfloatTDengine\\TSDB_DATA_TYPE_DOUBLEdoubleTDengine\\TSDB_DATA_TYPE_BINARYbinaryTDengine\\TSDB_DATA_TYPE_TIMESTAMPtimestampTDengine\\TSDB_DATA_TYPE_NCHARncharTDengine\\TSDB_DATA_TYPE_UTINYINTutinyintTDengine\\TSDB_DATA_TYPE_USMALLINTusmallintTDengine\\TSDB_DATA_TYPE_UINTuintTDengine\\TSDB_DATA_TYPE_UBIGINTubigintrestful 用法// 通过 sql 方法执行 sql 语句\nvar_dump($connection-&gt;sql(&#039;create database if not exists db_test&#039;));\nvar_dump($connection-&gt;sql(&#039;show databases&#039;));\nvar_dump($connection-&gt;sql(&#039;create table if not exists db_test.tb (ts timestamp, temperature int, humidity float)&#039;));\nvar_dump($connection-&gt;sql(sprintf(&#039;insert into db_test.tb values(%s,%s,%s)&#039;, time() * 1000, mt_rand(), mt_rand() / mt_rand())));\n\n$result = $connection-&gt;sql(&#039;select * from db_test.tb&#039;);\n\n$result-&gt;getResponse(); // 获取接口原始返回数据\n\n// 获取列数据\nforeach ($result-&gt;getColumns() as $column)\n{\n    $column-&gt;getName(); // 列名\n    $column-&gt;getType(); // 列类型值\n    $column-&gt;getTypeName(); // 列类型名称\n    $column-&gt;getLength(); // 类型长度\n}\n\n// 获取数据\nforeach ($result-&gt;getData() as $row)\n{\n    echo $row[&#039;列名&#039;]; // 经过处理，可以直接使用列名获取指定列数据\n}\n\n$result-&gt;getStatus(); // 告知操作结果是成功还是失败；同接口返回格式\n\n$result-&gt;getHead(); // 表的定义，如果不返回结果集，则仅有一列“affected_rows”。（从 2.0.17 版本开始，建议不要依赖 head 返回值来判断数据列类型，而推荐使用 column_meta。在未来版本中，有可能会从返回值中去掉 head 这一项。）；同接口返回格式\n\n$result-&gt;getRow(); // 表明总共多少行数据；同接口返回格式"},{"id":182,"title":"定时器","pageTitle":"定时器","url":"components/timer/index.html","content":"定时器目录imi 定时器提供了定时执行和延后执行功能，都是异步支持的。类名：\\Imi\\Timer\\Timer环境支持名称是否支持备注php-fpm×为了保证兼容性，php-fpm 中使用了定时器的话，会立即执行回调。 swoole√  workerman√  调用方法无限执行// 每隔 1 秒执行一次\n$timerId = Timer::tick(1000, function(){\n    // 执行内容\n});只执行一次// 1 秒后执行一次\n$timerId = Timer::after(1000, function(){\n    // 执行内容\n});删除定时器Timer::del($timerId);清空所有定时器Timer::clear();"},{"id":215,"title":"调用链路追踪","pageTitle":"调用链路追踪","url":"components/tracing/index.html","content":"调用链路追踪目录为了应对各种复杂的业务，开发工程师开始采用敏捷开发、持续集成等开发方式。系统架构也从单机大型软件演化成微服务架构。微服务构建在不同的软件集上，这些软件模块可能是由不同团队开发的，可能使用不同的编程语言来实现，还可能发布在多台服务器上。因此，如果一个服务出现问题，可能导致几十个应用都出现服务异常。分布式追踪系统可以记录请求范围内的信息，例如一次远程方法调用的执行过程和耗时，是我们排查系统问题和系统性能的重要工具。所有的链路追踪都或多或少有性能损耗，请根据实际需要在生产环境中使用！支持的中间件： Swoole Tracker Zipkin Jaeger……"},{"id":217,"title":"OpenTracing","pageTitle":"OpenTracing","url":"components/tracing/opentracing.html","content":"OpenTracing目录OpenTracing 是一种分布式系统链路跟踪的设计原则、规范、标准。支持的中间件： Zipkin Jaeger Skywalkingimi-opentracing: https://github.com/imiphp/imi-opentracing配置@app.beans:&#039;Tracer&#039;   =&gt; [\n    // 不同驱动配置不同，请往下翻，看具体的驱动配置说明\n],\n\n// 数据库调用追踪\n&#039;DbTracer&#039; =&gt; [\n    &#039;enable&#039; =&gt; true, // 是否启用，默认 false\n],\n\n// Redis 调用追踪\n&#039;RedisTracer&#039; =&gt; [\n    &#039;enable&#039; =&gt; true, // 是否启用，默认 false\n],启用 HTTP 请求追踪：服务器配置的 beans 中：[\n    &#039;HttpDispatcher&#039;    =&gt; [\n        &#039;middlewares&#039;    =&gt; [\n            \\Imi\\OpenTracing\\Middleware\\HttpRequestTracingMiddleware::class, // 将这个中间件放到最前面\n            // 这里是你的其它中间件\n        ],\n    ],\n]使用开启追踪会造成性能损耗，请根据实际需要在生产环境中使用！追踪方法调用（注解）仅使用容器实例化的对象方法可被追踪&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace app\\Service;\n\nuse Imi\\OpenTracing\\Annotation\\Tag;\nuse Imi\\OpenTracing\\Annotation\\Trace;\n\nclass TestService\n{\n    /**\n     * @Trace(&quot;add&quot;)\n     * @Tag(key=&quot;method.params.a&quot;, value=&quot;{params.0}&quot;)\n     * @Tag(key=&quot;method.params.b&quot;, value=&quot;{params.1}&quot;)\n     * @Tag(key=&quot;method.returnValue&quot;, value=&quot;{returnValue}&quot;)\n     * @Tag(key=&quot;method.message&quot;, value=&quot;{params.0}+{params.1}={returnValue}&quot;)\n     *\n     * @param int|float $a\n     * @param int|float $b\n     *\n     * @return int|float\n     */\n    public function add($a, $b)\n    {\n        return $a + $b;\n    }\n}上面的代码追踪的操作是 add，@Trace 也可以不指定操作名称，默认是：类名::方法名()@Tag 是可选的，记录一些标签数据。{params.0} 就是代入方法的第一个参数值；{returnValue} 是代入方法的返回值。你甚至可以使用 params.0.id、returnValue.name 类似这种写法，获取类型为数组或对象的属性值。手动追踪在当前服务中增加追踪：use Imi\\OpenTracing\\Facade\\Tracer;\n\n// 开始\n$scope = Tracer::startActiveSpan(&#039;write1&#039;);\n\n// ...\n// 这里可以做一些事情\n\n// 结束\n$scope-&gt;close();用一个服务名追踪：use Imi\\OpenTracing\\Facade\\Tracer;\n\n// 创建 Tracer\n$tracer = Tracer::createTracer(&#039;redis&#039;);\n// 开始\n$scope1 = TracerUtil::startRootActiveSpan($tracer, &#039;test1&#039;);\n\n// ...\n// 这里可以做一些事情\n\n// 可以继续在 test1 下增加追踪\n$scope2 = $tracer-&gt;startActiveSpan(&#039;test1-1&#039;);\n// ...\n// 这里可以做一些事情\n// 结束 test1-1\n$scope2-&gt;close();\n\n// ...\n// 这里可以做一些事情\n\n// 结束\n$scope1-&gt;close();\n$tracer-&gt;flush();异常类忽略追踪在异常类上加上 @IgnoredException 注解，捕获到该注解时不会认为错误&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace app\\Exception;\n\nuse Imi\\OpenTracing\\Annotation\\IgnoredException;\nuse RuntimeException;\n\n/**\n * @IgnoredException\n */\nclass GGException extends RuntimeException\n{\n}驱动JaegerJaeger 是受 Dapper 和 OpenZipkin 的启发，由 Uber Technologies 创建的分布式追踪平台，现已捐赠给云原生计算基金会。它可用于监视基于微服务的分布式系统：分布式上下文传播分布式交易监控根本原因分析服务依赖分析性能 / 延迟优化安装 Jaeger 所需组件composer require imiphp/imi-opentracing:~2.1.0 jonahgeorge/jaeger-client-phpJaeger 配置@app.beans:&#039;Tracer&#039;   =&gt; [\n    // 驱动类\n    &#039;driver&#039;  =&gt; \\Imi\\OpenTracing\\Driver\\JaegerTracerDriver::class,\n    // 配置项\n    &#039;options&#039; =&gt; [\n        // 服务名称，自行修改\n        &#039;serviceName&#039; =&gt; &#039;imi-opentracing&#039;,\n        // 客户端配置\n        &#039;config&#039;      =&gt; [\n            // 采样配置\n            // 每次都采样，建议测试用\n            &#039;sampler&#039; =&gt; [\n                &#039;type&#039;  =&gt; Jaeger\\SAMPLER_TYPE_CONST,\n                &#039;param&#039; =&gt; true,\n            ],\n\n            // 概率采样，建议生产用\n            // &#039;sampler&#039; =&gt; [\n            //     &#039;type&#039; =&gt; Jaeger\\SAMPLER_TYPE_PROBABILISTIC,\n            //     &#039;param&#039; =&gt; 0.5, // float [0.0, 1.0]\n            // ],\n\n            // 限流采样，建议生产用\n            // &#039;sampler&#039; =&gt; [\n            //     &#039;type&#039; =&gt; Jaeger\\SAMPLER_TYPE_RATE_LIMITING,\n            //     &#039;param&#039; =&gt; 100 // 每秒最大追踪次数\n            //     &#039;cache&#039; =&gt; [\n            //         &#039;currentBalanceKey&#039; =&gt; &#039;rate.currentBalance&#039; // string\n            //         &#039;lastTickKey&#039; =&gt; &#039;rate.lastTick&#039; // string\n            //     ]\n            // ],\n\n            // 连接配置\n            &#039;local_agent&#039; =&gt; [\n                &#039;reporting_host&#039; =&gt; &#039;127.0.0.1&#039;, // 主机名\n                // 端口\n                // ZIPKIN_OVER_COMPACT_UDP 默认：5775\n                // JAEGER_OVER_BINARY_UDP 默认：6832\n                // JAEGER_OVER_BINARY_HTTP 默认：14268\n                &#039;reporting_port&#039; =&gt; 5775,\n            ],\n            // 通信协议\n            &#039;dispatch_mode&#039; =&gt; \\Jaeger\\Config::ZIPKIN_OVER_COMPACT_UDP, // Zipkin.thrift + UDP，默认\n            &#039;dispatch_mode&#039; =&gt; \\Jaeger\\Config::JAEGER_OVER_BINARY_UDP, // Jaeger.thrift + UDP\n            &#039;dispatch_mode&#039; =&gt; \\Jaeger\\Config::JAEGER_OVER_BINARY_HTTP, //Jaeger.thrift + HTTP\n\n            &#039;logging&#039; =&gt; true,\n            &quot;tags&quot; =&gt; [\n                // 前缀 prefix. 只在 JAEGER_OVER_HTTP, JAEGER_OVER_BINARY 中起作用。\n                // 否则它将被显示为简单的全局标签\n                &quot;process.process-tag-key-1&quot; =&gt; &quot;process-value-1&quot;, // 所有带有`process.`前缀的标签都归入进程部分。\n                &quot;process.process-tag-key-2&quot; =&gt; &quot;process-value-2&quot;, //所有带有`process.`前缀的标签都进入进程部分。\n                &quot;global-tag-key-1&quot; =&gt; &quot;global-tag-value-1&quot;, // 这个标签将被附加到所有的 span 中。\n                &quot;global-tag-key-2&quot; =&gt; &quot;global-tag-value-2&quot;, // 这个标签将被附加到所有的 span 中。\n            ],\n        ],\n    ],\n],Jaeger Dockerdocker-compose.yml:version: &quot;2&quot;\nservices:\n    jaeger:\n        image: jaegertracing/all-in-one:1.38\n        container_name: jaeger\n        ports:\n            - &quot;6831:6831&quot;\n            - &quot;6832:6832&quot;\n            - &quot;5778:5778&quot;\n            - &quot;16686:16686&quot;\n            - &quot;14268:14268&quot;\n            - &quot;9411:9411&quot;仅供开发调试用ZipkinZipkin是 Twitter 的一个开源项目，基于 Google Dapper 实现。可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的 REST API 接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。除了面向开发的API接口之外，它也提供了方便的 UI 组件帮助我们直观的搜索跟踪信息和分析请求链路明细，比如：可以查询某段时间内各用户请求的处理时间等。安装 Zipkin 所需组件composer require imiphp/imi-opentracing:~2.1.0 jcchavezs/zipkin-opentracingZipkin 配置@app.beans:&#039;Tracer&#039;   =&gt; [\n    // 驱动类\n    &#039;driver&#039;  =&gt; \\Imi\\OpenTracing\\Driver\\ZipkinTracerDriver::class,\n    // 配置项\n    &#039;options&#039; =&gt; [\n        // 服务名称，自行修改\n        &#039;serviceName&#039; =&gt; &#039;imi-opentracing&#039;,\n        // 客户端配置\n        &#039;config&#039;      =&gt; [\n            // 采样配置\n            &#039;sampler&#039; =&gt; [\n                // 采样类创建方法\n                // 每次都采样，建议测试用\n                &#039;creator&#039;       =&gt; &#039;\\Zipkin\\Samplers\\BinarySampler::createAsAlwaysSample&#039;,\n                &#039;creatorParams&#039; =&gt; [true],\n\n                // 概率采样，建议生产用\n                // &#039;creator&#039;       =&gt; &#039;\\Zipkin\\Samplers\\PercentageSampler::create&#039;,\n                // &#039;creatorParams&#039; =&gt; [0.5], // float [0.0, 1.0]\n            ],\n            // 连接配置\n            &#039;reporter&#039; =&gt; [\n                &#039;endpoint_url&#039;   =&gt; &#039;http://localhost:9411/api/v2/spans&#039;,\n            ],\n        ],\n    ],\n],Zipkin Dockerdocker-compose.yml:version: &#039;2.4&#039;\nservices:\n  zipkin:\n    image: openzipkin/zipkin:2\n    container_name: zipkin\n    environment:\n      - STORAGE_TYPE=mem\n    ports:\n      # Port used for the Zipkin UI and HTTP Api\n      - 9412:9411仅供开发调试用"},{"id":111,"title":"UDP 控制器","pageTitle":"UDP 控制器","url":"components/udpServer/controller.html","content":"UDP 控制器目录定义&lt;?php\nnamespace ImiDemo\\UdpDemo\\MainServer\\Controller;\n\nuse Imi\\ConnectionContext;\nuse Imi\\Server\\UdpServer\\Route\\Annotation\\UdpRoute;\nuse Imi\\Server\\UdpServer\\Route\\Annotation\\UdpAction;\nuse Imi\\Server\\UdpServer\\Route\\Annotation\\UdpController;\n\n/**\n * 数据收发测试\n * @UdpController\n */\nclass Test extends \\Imi\\Controller\\UdpController\n{\n    /**\n     * 登录\n     * \n     * @UdpAction\n     * @UdpRoute({&quot;action&quot;=&quot;hello&quot;})\n     * @return void\n     */\n    public function hello()\n    {\n        return [\n            &#039;time&#039;    =&gt;    date($this-&gt;data-&gt;getFormatData()-&gt;format),\n        ];\n    }\n\n}首先控制器类必须有@UdpController注解，对应动作必须有@UdpAction和@UdpRoute注解。注解@UdpController注释目标：类表明一个类是控制器类属性名称说明server指定当前控制器允许哪些服务器使用。支持字符串或数组，默认为 null 则不限制@UdpRoute指定 Udp 路由解析规则。// 解析 $data[&#039;action&#039;] === &#039;login&#039;\n@TcpRoute({&quot;action&quot;=&quot;login&quot;})\n// 解析 $data[&#039;a&#039;][&#039;b&#039;][&#039;c&#039;] === &#039;login&#039;\n@TcpRoute({&quot;a.b.c&quot;=&quot;login&quot;})\n// 解析 $data[&#039;a&#039;] == &#039;1&#039; &amp;&amp; $data[&#039;b&#039;] == &#039;2&#039;\n@TcpRoute({&quot;a&quot;=&quot;1&quot;, &quot;b&quot;=&quot;2&quot;})当然对象也是支持的：// 解析 $data-&gt;a-&gt;b-&gt;c === &#039;login&#039;\n@TcpRoute({&quot;a.b.c&quot;=&quot;login&quot;})路由匹配成功，就会执行这个动作。动作响应数据响应当前这个请求直接在方法中返回一个数组或对象，在服务器配置设定的处理器，就会把这个转为对应数据响应给客户端。响应数据：return [&#039;success&#039;=&gt;true];分组发送由于UDP的特性，所以不支持分组发送。如有需要，可根据实际场景自行实现分组。类属性$server详见：https://doc.imiphp.com/v2.1/core/server.html$data当然，你还可以直接通过请求上下文代理类，在任意地方使用：\\Imi\\Server\\UdpServer\\Message\\Proxy\\PacketDataProxy::getFormatData();方法/**\n * 数据内容.\n */\npublic function getData(): string;\n\n/**\n * 获取格式化后的数据，一般是数组或对象\n *\n * @return mixed\n */\npublic function getFormatData();\n\n/**\n * 获取客户端地址\n */\npublic function getClientAddress(): \\Imi\\Util\\Socket\\IPEndPoint;"},{"id":108,"title":"错误异常处理","pageTitle":"错误异常处理","url":"components/udpServer/error.html","content":"错误异常处理目录当程序出现错误或者异常时，我们一般会希望在开发时输出报错信息，在生产环境时隐藏详细的信息。在 imi 中，提供了 Udp 服务的错误异常默认处理器支持。默认 Udp 错误处理器：无指定默认处理器配置文件中：return [\n    &#039;beans&#039;    =&gt; [\n        &#039;UdpErrorHandler&#039; =&gt; [\n            // 指定默认处理器\n            &#039;handler&#039; =&gt; \\app\\Error\\UdpErrorHandler::class,\n        ],\n    ],\n];编写处理器如下代码所示，实现IErrorHandler接口，handle()方法返回值为true时则取消继续抛出异常。&lt;?php\nnamespace app\\Error;\n\nuse Imi\\Server\\UdpServer\\Error\\IErrorHandler;\n\nclass UdpErrorHandler implements IErrorHandler\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function handle(\\Throwable $throwable): bool\n    {\n        // 做处理\n        return true;\n    }\n}"},{"id":112,"title":"中间件","pageTitle":"中间件","url":"components/udpServer/middleware.html","content":"中间件目录开发者可以开发中间件类，对整个UDP请求和响应过程进行自定义处理。注意！最好不要在中间件中使用类属性，可能会造成冲突！定义中间件&lt;?php\nnamespace Imi\\Server\\UdpServer\\Middleware;\n\nuse Imi\\Bean\\Annotation\\Bean;\n\n/**\n * @Bean\n */\nclass RouteMiddleware implements IMiddleware\n{\n    /**\n     * 处理方法\n     *\n     * @param IReceiveData $data\n     * @param IReceiveHandler $handle\n     * @return void\n     */\n    public function process(IPacketData $data, IPacketHandler $handler)\n    {\n        // 前置处理\n        \n        // 先执行其它中间件\n        $result = $handler-&gt;handle($data);\n        \n        // 后置处理\n        \n        return $result;\n    }\n\n}全局中间件return [\n    &#039;beans&#039;    =&gt;    [\n        // 中间件\n        &#039;UdpDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                // 中间件\n                \\Imi\\Server\\Udp\\Middleware\\RouteMiddleware::class,\n            ],\n        ],\n    ],\n];局部中间件注解使用&lt;?php\nnamespace ImiDemo\\UdpDemo\\MainServer\\Controller;\n\nuse Imi\\ConnectionContext;\nuse Imi\\Server\\UdpServer\\Route\\Annotation\\UdpRoute;\nuse Imi\\Server\\UdpServer\\Route\\Annotation\\UdpAction;\nuse Imi\\Server\\UdpServer\\Route\\Annotation\\UdpController;\n\n/**\n * 数据收发测试\n * @UdpController\n */\nclass Test extends \\Imi\\Controller\\UdpController\n{\n    /**\n     * 登录\n     * \n     * @UdpAction\n     * @UdpRoute({&quot;action&quot;=&quot;hello&quot;})\n     * @UdpMiddleware(XXX::class)\n     * @UdpMiddleware({XXX::class,XXX2::class})\n     * @return void\n     */\n    public function hello()\n    {\n        return [\n            &#039;time&#039;    =&gt;    date($this-&gt;data-&gt;getFormatData()-&gt;format),\n        ];\n    }\n\n}\n如上代码，同时支持设置单个和多个中间件中间件分组服务器 config.php：return [\n    &#039;middleware&#039;    =&gt;  [\n        &#039;groups&#039;    =&gt;  [\n            // 组名\n            &#039;test&#039;  =&gt;  [\n                // 中间件列表\n                \\Imi\\Test\\HttpServer\\ApiServer\\Middleware\\Middleware4::class,\n            ],\n        ],\n    ],\n];"},{"id":113,"title":"不使用中间件","pageTitle":"不使用中间件","url":"components/udpServer/noMiddleware.html","content":"不使用中间件目录imi中内置实现了中间件+控制器方式开发tcp，在一些场景也可以选择不使用，直接监听服务器的packet事件，进行手动处理。监听写法&lt;?php\nnamespace Imi\\Swoole\\Server\\UdpServer\\Listener;\n\nuse Imi\\Server\\ServerManager;\nuse Imi\\ConnectionContext;\nuse Imi\\RequestContext;\nuse Imi\\Bean\\Annotation\\ClassEventListener;\nuse Imi\\Swoole\\Server\\Event\\Param\\PacketEventParam;\nuse Imi\\Server\\UdpServer\\Message\\PacketData;\nuse Imi\\Swoole\\Server\\Event\\Listener\\IPacketEventListener;\n\n/**\n * Packet事件前置处理\n * @ClassEventListener(className=&quot;Imi\\Server\\UdpServer\\Server&quot;,eventName=&quot;packet&quot;,priority=PHP_INT_MAX)\n */\nclass BeforePacket implements IPacketEventListener\n{\n    /**\n     * 事件处理方法\n     * @param PacketEventParam $e\n     * @return void\n     */\n    public function handle(PacketEventParam $e): void\n    {\n        // 如果服务器名不是主服务器就返回\n        if(&#039;main&#039; !== $e-&gt;getTarget()-&gt;getName())\n        {\n            return;\n        }\n        var_dump($e-&gt;data);\n\n    }\n}"},{"id":110,"title":"路由","pageTitle":"路由","url":"components/udpServer/route.html","content":"路由目录启用路由服务器配置文件中加入中间件：return [\n    &#039;beans&#039;    =&gt;    [\n        &#039;UdpDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                \\Imi\\Server\\UdpServer\\Middleware\\RouteMiddleware::class,\n            ],\n        ],\n    ],\n];通过配置注入形式，实现非常灵活的配置，你甚至可以自己另外实现路由中间件，而不用被框架自带的中间件所影响，用哪些中间件都在你的掌控之中！获取当前路由解析结果 (routeResult)$routeResult = RequestContext::get(&#039;routeResult&#039;);$routeResult 定义：/**\n * 路由配置项\n *\n * @var \\Imi\\Server\\UdpServer\\Route\\RouteItem\n */\npublic $routeItem;\n\n/**\n * 参数\n *\n * @var array\n */\npublic $params;\n\n/**\n * 回调\n *\n * @var callable\n */\npublic $callable;$routeResult-&gt;routeItem 定义：/**\n * 注解\n *\n * @var \\Imi\\Server\\UdpServer\\Route\\Annotation\\UdpRoute\n */\npublic $annotation;\n\n/**\n * 回调\n *\n * @var callable\n */\npublic $callable;\n\n/**\n * 中间件列表\n *\n * @var array\n */\npublic $middlewares = [];\n\n/**\n * 其它配置项\n *\n * @var array\n */\npublic $options;"},{"id":169,"title":"验证器","pageTitle":"验证器","url":"components/validation/index.html","content":"验证器目录imi 提供了基本数据类型的验证，以及可扩展的验证方法，这一切都可以通过注解来使用。注解@Condition通用验证条件，传入回调进行验证该注解可以写在类、属性、方法上。参数：/**\n * 参数名称\n * 属性注解可省略\n *\n * @var string\n */\npublic $name;\n\n/**\n * 非必验证，只有当值存在才验证\n *\n * @var boolean\n */\npublic $optional = false;\n\n/**\n * 当值不符合条件时的默认值\n *\n * @var mixed\n */\npublic $default;\n\n/**\n * 对结果取反\n *\n * @var boolean\n */\npublic $inverseResult = false;\n\n/**\n * 当验证条件不符合时的信息\n * \n * 支持代入{:value}原始值\n * 支持代入{:data.xxx}所有数据中的某项\n * 支持以{name}这样的形式，代入注解参数值\n *\n * @var string\n */\npublic $message = &#039;{name} validate failed&#039;;\n\n/**\n * 验证回调\n *\n * @var callable\n */\npublic $callable;\n\n/**\n * 参数名数组\n * \n * 支持代入{:value}原始值\n * 支持代入{:data}所有数据\n * 支持代入{:data.xxx}所有数据中的某项\n * 支持以{name}这样的形式，代入注解参数值\n * 如果没有{}，则原样传值\n *\n * @var array\n */\npublic $args = [&#039;{:value}&#039;];\n\n/**\n * 异常类\n *\n * @var string\n */\npublic $exception = null;\n\n/**\n * 异常编码\n *\n * @var integer\n */\npublic $exCode = null;name 支持动态数组对象验证：member.usernamelist1.*.idlist2.** 代表上一级下面的所有值callable 是验证回调，支持：&quot;is_int&quot;、&quot;XXX::check&quot;、{@Inject(&quot;BeanName&quot;), &quot;methodName&quot;}{&quot;$this&quot;, &quot;methodName&quot;}指定当前对象中的方法，但Http验证器中无法使用。方法必须是public或protected。args 是回调方法参数，例子：class TestValidate\n{\n    public $abc = &#039;imi niubi!&#039;;\n\n    /**\n     * @AutoValidation\n     * @Condition(name=&quot;argName&quot;, callable={&quot;$this&quot;, &quot;validate&quot;}, args={&quot;{:value}&quot;, &quot;{:data}&quot;, &quot;{name}&quot;, &quot;{:data.a}&quot;, {&quot;:data.$this.abc&quot;}})\n     */\n    public function test($a, $b)\n    {\n\n    }\n\n    /**\n     * 本方法参数，由 @Condition 的 args 决定\n     * $value 是当前验证参数对应的值，也就是 test() 方法中，$a 参数值\n     * $data 是集合了 test() 方法中所有参数的数组\n     * 你可以用 $data[&#039;b&#039;] 获取 $b 参数值\n     * $name 代表是 @Condition 中的 name 参数，同理可以取到注解中的其它参数值\n     * $a 就是指定传入 test() 方法中 $a 参数值\n     * $vvv 就是指定 test() 方法所在类对象中的 $abc 属性值\n     */\n    public function validate($value, $data, $name, $a, $vvv)\n    {\n        var_dump($value, $data, $name, $a, $vvv);\n        return true;\n    }\n}inverseResult 参数为true时，会对验证回调方法结果取反后，判断是否为truemessage 是验证失败的消息，可以将{name}形式的注解参数值代入，也可以使用{:value}代入验证值。exception和exCode可以设定验证失败时抛出的异常类及异常编码，默认为\\InvalidArgumentException类。除了callable和args以外，其它参数都可以作为其它验证条件注解（如：@Required 等）的参数@Required判断值是否存在@Text文本验证字节验证必须&gt;=6位长度字节，最长不限制：@Text(min=6)字节长度必须&gt;=6 && &lt;=12：@Text(min=6, max=12)PHP 中，UTF-8 编码的中文字，每个字节长度为 3字符验证必须&gt;=6位长度字符，最长不限制：@Text(char=true, min=6)字符长度必须&gt;=6 && &lt;=12：@Text(char=true, min=6, max=12)一个字母是一个字符，一个中文也是一个字符@Integer整数验证验证必须为整数：@Integer验证必须为&gt;=1024的整数：@Integer(min=1024)验证必须为&lt;=1024的整数：@Integer(max=1024)验证必须为&gt;=1 && &lt;=10的整数：@Integer(min=1, max=10)@Decimal小数验证验证必须为小数：@Decimal验证必须为&gt;=10.24的小数：@Decimal(min=10.24)验证必须为&lt;=10.24的小数：@Decimal(max=10.24)验证必须为&gt;=1 && &lt;=10.24的小数：@Decimal(min=1, max=10.24)传入1，结果为false传入1.0，结果为true@Number数值验证，允许是整数或者小数验证必须为数值：@Decimal验证必须为&gt;=10.24的数值：@Decimal(min=10.24)验证必须为&lt;=10.24的数值：@Decimal(max=10.24)验证必须为&gt;=1 && &lt;=10.24的数值：@Decimal(min=1, max=10.24)传入1，结果为true传入1.0，结果为true@InList列表验证，判断值是否存在于列表中@InList(list={1, 2, 3})相当于：$result = in_array($value, [1, 2, 3]);@Compare比较验证注解@Compare(name=&quot;参数名&quot;, value=&quot;被比较值&quot;, operation=&quot;比较符，如：==&quot;)value 可以直接传值，也可以配合 @ValidateValue 注解使用。operation 允许使用：==、!=、===、!==、&lt;、&lt;=、&gt;、&gt;=@ValidateValue指定验证时的值注解@Compare(name=&quot;id&quot;, value=@ValidateValue(&quot;{:data.id}&quot;), operation=&quot;==&quot;)@InEnum用于验证值是否存在于枚举列表中@InEnum(name=&quot;type&quot;, enum=&quot;EnumClass&quot;)@Regex正则验证@Regex(name=&quot;regex&quot;, pattern=&quot;/\\d+/&quot;)可选验证可选验证，只有当值存在时，才对值进行验证。没有该值时不验证，可以用于一些可选参数的验证场景。用法是需要作为可选验证的注解，optional属性设为true即可。@Text(name=&quot;a&quot;, &quot;min&quot;=1, optional=true)自动验证注解：@AutoValidation验证类属性imi 支持在类、属性上使用 @AutoValidation 注解，当构造方法执行完毕后，触发验证。验证失败抛出异常。如下代码，写在类上的注解以及属性上的注解，都因为加了@AutoValidation 注解，所以在构造方法执行完成后，会自动进行验证，验证失败则抛出异常。/**\n * @Bean(&quot;ValidatorTest&quot;)\n * \n * @AutoValidation\n * \n * \n * @InList(name=&quot;in&quot;, list={1, 2, 3}, message=&quot;{:value} 不在列表内&quot;)\n * @Integer(name=&quot;int&quot;, min=0, max=100, message=&quot;{:value} 不符合大于等于{min}且小于等于{max}&quot;)\n * @Required(name=&quot;required&quot;, message=&quot;{name}为必须参数&quot;)\n * @Number(name=&quot;number&quot;, min=0.01, max=999.99, accuracy=2, message=&quot;数值必须大于等于{min}，小于等于{max}，小数点最多保留{accuracy}位小数，当前值为{:value}&quot;)\n * @Text(name=&quot;text&quot;, min=6, max=12, message=&quot;{name}参数长度必须&gt;={min} &amp;&amp; &lt;={max}&quot;)\n * @Condition(name=&quot;my&quot;, callable=&quot;\\ImiDemo\\HttpDemo\\MainServer\\Validator\\Test::myValidate&quot;, args={&quot;{:value}&quot;}, message=&quot;{name}值必须为1&quot;)\n */\nclass Test\n{\n    /**\n     * @Decimal(min=-0.01, max=999.99, accuracy=2, message=&quot;小数必须大于等于{min}，小于等于{max}，小数点最多保留{accuracy}位小数，当前值为{:value}&quot;)\n     *\n     * @var float\n     */\n    public $decimal;\n\n    public function __construct($data = [], $rules = null)\n    {\n        foreach($data as $name =&gt; $value)\n        {\n            $this-&gt;$name = $value;\n        }\n    }\n\n    public static function myValidate($value)\n    {\n        return 1 == $value;\n    }\n}\n验证方法参数在 imi 中，如果你在方法上使用 @AutoValidation 注解，当方法被调用前，会触发验证操作，验证失败则抛出异常。验证的参数是传入方法的参数，如下代码，验证通过则进入方法体中，验证失败会抛出异常。/**\n * @AutoValidation\n * \n * @Required(name=&quot;id&quot;, message=&quot;用户ID为必传参数&quot;)\n * @Integer(name=&quot;id&quot;, min=1, message=&quot;用户ID不符合规则&quot;)\n * @Required(name=&quot;name&quot;, message=&quot;用户姓名为必传参数&quot;)\n * @Text(name=&quot;name&quot;, min=2, message=&quot;用户姓名长度不得少于2位&quot;)\n *\n * @param int $id\n * @param string $name\n * @return void\n */\npublic function test222($id, $name)\n{\n    var_dump($id, $name);\n}手动验证你也可以自己定义一个专门用于验证的类，将数据传入该类，手动调用验证方法。/**\n * @Bean(&quot;ValidatorTest&quot;)\n * \n * @InList(name=&quot;in&quot;, list={1, 2, 3}, message=&quot;{:value} 不在列表内&quot;)\n * @Integer(name=&quot;int&quot;, min=0, max=100, message=&quot;{:value} 不符合大于等于{min}且小于等于{max}&quot;)\n * @Required(name=&quot;required&quot;, message=&quot;{name}为必须参数&quot;)\n * @Number(name=&quot;number&quot;, min=0.01, max=999.99, accuracy=2, message=&quot;数值必须大于等于{min}，小于等于{max}，小数点最多保留{accuracy}位小数，当前值为{:value}&quot;)\n * @Text(name=&quot;text&quot;, min=6, max=12, message=&quot;{name}参数长度必须&gt;={min} &amp;&amp; &lt;={max}&quot;)\n * @Condition(name=&quot;my&quot;, callable=&quot;\\ImiDemo\\HttpDemo\\MainServer\\Validator\\Test::myValidate&quot;, args={&quot;{:value}&quot;}, message=&quot;{name}值必须为1&quot;)\n */\nclass Test extends Validator\n{\n    /**\n     * @Decimal(min=-0.01, max=999.99, accuracy=2, message=&quot;小数必须大于等于{min}，小于等于{max}，小数点最多保留{accuracy}位小数，当前值为{:value}&quot;)\n     *\n     * @var float\n     */\n    public $decimal;\n\n    public function __construct($data = [], $rules = null)\n    {\n        parent::__construct($data, $rules);\n        foreach($data as $name =&gt; $value)\n        {\n            $this-&gt;$name = $value;\n        }\n    }\n\n    public static function myValidate($value)\n    {\n        return 1 == $value;\n    }\n}\n当你使用手动验证时，可以直接new出来使用，不是很有必要使用容器。使用代码示例：$v = new Test([\n    // &#039;decimal&#039;   =&gt;  1.1,\n    // &#039;in&#039;        =&gt;  1,\n    &#039;int&#039;       =&gt;  1,\n    &#039;required&#039;  =&gt;  1,\n    &#039;number&#039;    =&gt;  1,\n    &#039;my&#039;        =&gt;  1,\n]);\n\n// 也可以设置数据\n// $v-&gt;setData([]);\n\n// 验证，当遇到不通过时结束验证流程\n$result = $v-&gt;validate();\nif(!$result)\n{\n    echo &#039;error: &#039;, $v-&gt;getMessage(), PHP_EOL;\n    // 当前错误的注解规则\n    var_dump($v-&gt;getFailRule());\n}\n\n// 验证所有\n$result = $v-&gt;validateAll();\nif(!$result)\n{\n    var_dump(\n        // 所有错误数组，注意每个成员也是个数组，里面可能有多个\n        $v-&gt;getResults()\n        // 所有错误的注解规则\n        , $v-&gt;getFailRules()\n    );\n}\n\n// 获得数据，如果你配置有default属性，并且验证失败，可以获得默认值\n$data = $v-&gt;getData();场景验证定义场景，指定某个场景，只验证指定的几个字段。方法一，注解定义：&lt;?php\nnamespace Imi\\Test\\Component\\Validate\\Classes;\n\nuse Imi\\Validate\\Validator;\nuse Imi\\Validate\\Annotation\\Scene;\nuse Imi\\Validate\\Annotation\\Decimal;\nuse Imi\\Validate\\Annotation\\Integer;\n\n/**\n * @Decimal(name=&quot;decimal&quot;, min=1, max=10, accuracy=2)\n * @Integer(name=&quot;int&quot;, min=0, max=100, message=&quot;{:value} 不符合大于等于{min}且小于等于{max}&quot;)\n * @Scene(name=&quot;a&quot;, fields={&quot;decimal&quot;})\n * @Scene(name=&quot;b&quot;, fields={&quot;int&quot;})\n * @Scene(name=&quot;c&quot;, fields={&quot;decimal&quot;, &quot;int&quot;})\n */\nclass TestSceneAnnotationValidator extends Validator\n{\n\n}方法二，代码定义：&lt;?php\nnamespace Imi\\Test\\Component\\Validate\\Classes;\n\nuse Imi\\Validate\\Validator;\nuse Imi\\Validate\\Annotation\\Decimal;\nuse Imi\\Validate\\Annotation\\Integer;\n\n/**\n * @Decimal(name=&quot;decimal&quot;, min=1, max=10, accuracy=2)\n * @Integer(name=&quot;int&quot;, min=0, max=100, message=&quot;{:value} 不符合大于等于{min}且小于等于{max}&quot;)\n */\nclass TestSceneValidator extends Validator\n{\n    /**\n     * 场景定义.\n     */\n    protected ?array $scene = [\n        &#039;a&#039; =&gt;  [&#039;decimal&#039;],\n        &#039;b&#039; =&gt;  [&#039;int&#039;],\n        &#039;c&#039; =&gt;  [&#039;decimal&#039;, &#039;int&#039;],\n    ];\n\n}选择场景验证：$data = [\n    &#039;decimal&#039;   =&gt;  &#039;a&#039;,\n    &#039;int&#039;       =&gt;  &#039;b&#039;,\n];\n$validator = new TestSceneValidator($data);\n$result = $validator-&gt;setCurrentScene(&#039;a&#039;)-&gt;validate();"},{"id":95,"title":"WebSocket 客户端","pageTitle":"WebSocket 客户端","url":"components/websocketServer/client.html","content":"WebSocket 客户端目录SwooleYurunHttpSwoole 协程 HTTP/WebSocket 客户端非 SwooleWrench"},{"id":82,"title":"错误异常处理","pageTitle":"错误异常处理","url":"components/websocketServer/error.html","content":"错误异常处理目录当程序出现错误或者异常时，我们一般会希望在开发时输出报错信息，在生产环境时隐藏详细的信息。在 imi 中，提供了 WebSocket 服务的错误异常默认处理器支持。默认 WebSocket 错误处理器：无指定默认处理器配置文件中：return [\n    &#039;beans&#039;    =&gt; [\n        &#039;WebSocketErrorHandler&#039; =&gt; [\n            // 指定默认处理器\n            &#039;handler&#039; =&gt; \\app\\Error\\WebSocketErrorHandler::class,\n        ],\n    ],\n];编写处理器如下代码所示，实现IErrorHandler接口，handle()方法返回值为true时则取消继续抛出异常。&lt;?php\nnamespace app\\Error;\n\nuse Imi\\Server\\WebSocket\\Error\\IErrorHandler;\n\nclass WebSocketErrorHandler implements IErrorHandler\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function handle(\\Throwable $throwable): bool\n    {\n        // 做处理\n        return true;\n    }\n}"},{"id":103,"title":"连接分组","pageTitle":"连接分组","url":"components/websocketServer/group.html","content":"连接分组目录imi 支持对 WebSocket 的连接（clientId）进行逻辑分组，你可以方便地对用户进行分组消息推送。所有的分组针对服务器，所以需要 imi 的服务器对象才可以调用下面这些方法，比如在WebSocketController中可以使用RequestContext::getServer()。分组的使用配置服务器配置文件：[\n    &#039;beans&#039; =&gt; [\n        // 分组\n        &#039;ServerGroup&#039; =&gt; [\n            &#039;status&#039;       =&gt; true , // 启用\n            &#039;groupHandler&#039; =&gt; &#039;GroupRedis&#039;, // 分组处理器，目前仅支持 Redis\n        ],\n        // 分组 Redis 驱动\n        &#039;GroupRedis&#039; =&gt; [\n            &#039;redisPool&#039; =&gt; &#039;连接池名&#039;,\n            &#039;redisDb&#039; =&gt; null, // redis中第几个库，为null或不配置则使用连接池中的设置\n            &#039;heartbeatTimespan&#039; =&gt; 5, // 心跳时间，单位：秒.\n            &#039;heartbeatTtl&#039; =&gt; 8, // 心跳数据过期时间，单位：秒.\n            &#039;key&#039; =&gt; &#039;&#039;, // 该服务的分组键，默认为 imi:命名空间:connect_group\n        ],\n        // 分组本地驱动，仅支持当前 Worker 进程\n        &#039;GroupLocal&#039; =&gt; [\n            // 无配置项\n        ],\n    ],\n]分组创建// 创建一个分组\n$this-&gt;server-&gt;createGroup(&#039;分组名称&#039;);\n\n// 创建一个分组，最多允许加入10个连接，-1为不限制\n$this-&gt;server-&gt;createGroup(&#039;分组名称&#039;, 10);加入分组$this-&gt;server-&gt;joinGroup(&#039;分组名称&#039;, $this-&gt;frame-&gt;getClientId());离开分组$this-&gt;server-&gt;leaveGroup(&#039;分组名称&#039;, $this-&gt;frame-&gt;getClientId());连接是否存在于组里$this-&gt;server-&gt;getGroup(&#039;分组名称&#039;)-&gt;isInGroup($this-&gt;frame-&gt;getClientId());获取所有连接$this-&gt;server-&gt;getGroup(&#039;分组名称&#039;)-&gt;getClientIds();获取在组中的连接总数$this-&gt;server-&gt;getGroup(&#039;分组名称&#039;)-&gt;count();获取分组对象// 不存在则为null，否则为\\Imi\\Server\\Group\\Group对象\n$this-&gt;server-&gt;getGroup(&#039;分组名称&#039;);组是否存在$this-&gt;server-&gt;hasGroup(&#039;分组名称&#039;);调用组方法// 遍历分组中所有clientId，调用服务器的push方法，发送message\n$this-&gt;server-&gt;groupCall(&#039;分组名称&#039;, &#039;push&#039;, &#039;message&#039;);\n\n// 发送给组里所有的连接，其它服务器方法一样调用，省去clientId参数即可\n$group-&gt;push(&#039;message&#039;);获取所有分组$this-&gt;server-&gt;getGroups();分组对象详解类\\Imi\\Server\\Group\\Group加入组$group-&gt;join($clientId);离开组$group-&gt;leave($clientId);获取服务器对象当前分组属于哪个服务器，这个是Swoole的服务器对象。$group-&gt;getServer();获取最大客户端数量$group-&gt;getMaxClients();"},{"id":85,"title":"HTTP 控制器","pageTitle":"HTTP 控制器","url":"components/websocketServer/httpController.html","content":"HTTP 控制器目录在 WebSocket 服务器中，如果有需要可以在 HTTP 控制器中自行做握手处理。仅 Swoole 需要指定 WebSocket 数据处理器在控制器中的方法上加上注解：@WSConfig(parserClass=\\Imi\\Server\\DataParser\\JsonArrayParser::class)parserClass 指定的就是处理器类，作用就是接收到数据后自动解码为对象或数组，发送时自动将数组或对象编码为相应数据。内置支持的类详见：https://doc.imiphp.com/v2.1/components/server/dataParser.html此方法指定的处理器，可能会影响 \\Imi\\Server\\Server 工具类的推送消息，强烈建议在配置文件中指定。"},{"id":84,"title":"HTTP 路由","pageTitle":"HTTP 路由","url":"components/websocketServer/httpRoute.html","content":"HTTP 路由目录在 WebSocket 服务器中，HTTP 路由的作用是让指定URI才支持握手，并且如果有需要可以自行做握手处理。用法同 HTTP 服务器，不再细说。仅 Swoole、Workerman 需要"},{"id":88,"title":"中间件","pageTitle":"中间件","url":"components/websocketServer/middleware.html","content":"中间件目录开发者可以开发中间件类，对整个WebSocket请求和响应过程进行自定义处理。注意！最好不要在中间件中使用类属性，可能会造成冲突！定义中间件&lt;?php\nnamespace Imi\\Server\\WebSocket\\Middleware;\n\nuse Imi\\RequestContext;\nuse Imi\\Bean\\Annotation\\Bean;\nuse Imi\\Server\\WebSocket\\Message\\IFrame;\nuse Imi\\Server\\WebSocket\\MessageHandler;\nuse Imi\\Server\\WebSocket\\IMessageHandler;\n\n/**\n * @Bean\n */\nclass RouteMiddleware implements IMiddleware\n{\n    /**\n     * 处理方法\n     *\n     * @param IFrame $frame\n     * @param IMessageHandler $handler\n     * @return void\n     */\n    public function process(IFrame $frame, IMessageHandler $handler)\n    {\n        // 前置处理\n        \n        // 先执行其它中间件\n        $result = $handler-&gt;handle($frame);\n        \n        // 后置处理\n        \n        return $result;\n    }\n\n}全局中间件return [\n    &#039;beans&#039;    =&gt;    [\n        // 中间件\n        &#039;WebSocketDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                // 中间件\n                \\Imi\\Server\\WebSocket\\Middleware\\RouteMiddleware::class,\n            ],\n        ],\n    ],\n];局部中间件注解使用&lt;?php\nnamespace ImiDemo\\WebSocketDemo\\MainServer\\WSController\\Index;\n\nuse Imi\\ConnectionContext;\nuse Imi\\Controller\\WebSocketController;\nuse Imi\\Server\\WebSocket\\Route\\Annotation\\WSRoute;\nuse Imi\\Server\\WebSocket\\Route\\Annotation\\WSAction;\nuse Imi\\Server\\WebSocket\\Route\\Annotation\\WSController;\nuse Imi\\Server\\WebSocket\\Route\\Annotation\\WSMiddleware;\n\n/**\n * 数据收发测试\n * @WSController\n */\nclass Test extends WebSocketController\n{\n    /**\n     * test\n     * \n     * @WSAction\n     * @WSRoute({&quot;action&quot;=&quot;login&quot;})\n     * @WSMiddleware(XXX::class)\n     * @WSMiddleware({XXX::class,XXX2::class})\n     * @return void\n     */\n    public function test($data)\n    {\n    }\n}如上代码，同时支持设置单个和多个中间件中间件分组服务器 config.php：return [\n    &#039;middleware&#039;    =&gt;  [\n        &#039;groups&#039;    =&gt;  [\n            // 组名\n            &#039;test&#039;  =&gt;  [\n                // 中间件列表\n                \\Imi\\Test\\HttpServer\\ApiServer\\Middleware\\Middleware4::class,\n            ],\n        ],\n    ],\n];"},{"id":92,"title":"不使用中间件","pageTitle":"不使用中间件","url":"components/websocketServer/noMiddleware.html","content":"不使用中间件目录imi中内置实现了中间件+控制器方式开发websocket，在一些场景也可以选择不使用，直接监听服务器的message事件，进行手动处理。监听写法&lt;?php\nnamespace ImiDemo\\WebSocketDemo\\MainServer\\Listener;\n\nuse Imi\\Bean\\Annotation\\ClassEventListener;\nuse Imi\\Swoole\\Server\\Event\\Param\\MessageEventParam;\nuse Imi\\Swoole\\Server\\Event\\Listener\\IMessageEventListener;\n\n/**\n * 监听message事件，可以自己做处理\n * 如果不需要默认的处理方式，在配置文件中，把WebSocketDispatcher-middlewares下的中间件去除\n * \n * @ClassEventListener(className=&quot;Imi\\Swoole\\Server\\WebSocket\\Server&quot;,eventName=&quot;message&quot;)\n */\nclass OnMessage implements IMessageEventListener\n{\n    /**\n     * 事件处理方法\n     * @param MessageEventParam $e\n     * @return void\n     */\n    public function handle(MessageEventParam $e): void\n    {\n        // 如果服务器名不是主服务器就返回\n        if(&#039;main&#039; !== $e-&gt;getTarget()-&gt;getName())\n        {\n            return;\n        }\n        var_dump($e-&gt;frame-&gt;data);\n        // $e-&gt;server-&gt;getSwooleServer()-&gt;push($e-&gt;frame-&gt;fd, &#039;返回信息&#039;);\n    }\n}"},{"id":104,"title":"断线重连","pageTitle":"断线重连","url":"components/websocketServer/reconnect.html","content":"断线重连目录使用 WebSocket、Http2、TCP 等长连接协议时，很多场景会需要断线重连功能。我们使用一个标记（UID），来绑定连接。断线重连就是连接断开后，该连接的上下文数据会继续保留，在一定时间内重连，就可以恢复上下文数据。一般用于游戏重连、减少重连后的网络通信、减轻前端开发压力等场景。断线重连视频介绍：https://www.bilibili.com/video/BV1GC4y1s7yf使用文档详见：https://doc.imiphp.com/v2.1/components/websocketServer/session.html"},{"id":86,"title":"路由","pageTitle":"路由","url":"components/websocketServer/route.html","content":"路由目录启用路由服务器配置文件中加入中间件：return [\n    &#039;beans&#039;    =&gt;    [\n        // 配置 http 为了握手，仅 Swoole、Workerman 需要，如果不需要手动判断握手，可以不配置该项\n        &#039;HttpDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                &#039;HandShakeMiddleware&#039;,\n                \\Imi\\Server\\Http\\Middleware\\RouteMiddleware::class,\n            ],\n        ],\n        // WebSocket 配置\n        &#039;WebSocketDispatcher&#039;    =&gt;    [\n            &#039;middlewares&#039;    =&gt;    [\n                \\Imi\\Server\\WebSocket\\Middleware\\RouteMiddleware::class,\n            ],\n        ],\n    ],\n];通过配置注入形式，实现非常灵活的配置，你甚至可以自己另外实现路由中间件，而不用被框架自带的中间件所影响，用哪些中间件都在你的掌控之中！获取握手时的 uri$uri = ConnectionContext::get(&#039;uri&#039;); // 字符串 uri获取当前路由解析结果 (routeResult)$routeResult = RequestContext::get(&#039;routeResult&#039;);$routeResult 定义：/**\n * 路由配置项\n *\n * @var \\Imi\\Server\\WebSocket\\Route\\RouteItem\n */\npublic $routeItem;\n\n/**\n * 参数\n *\n * @var array\n */\npublic $params;\n\n/**\n * 回调\n *\n * @var callable\n */\npublic $callable;$routeResult-&gt;routeItem 定义：/**\n * 注解\n *\n * @var \\Imi\\Server\\WebSocket\\Route\\Annotation\\WSRoute\n */\npublic $annotation;\n\n/**\n * 回调\n *\n * @var callable\n */\npublic $callable;\n\n/**\n * 中间件列表\n *\n * @var array\n */\npublic $middlewares = [];\n\n/**\n * 其它配置项\n *\n * @var array\n */\npublic $options;"},{"id":102,"title":"连接上下文","pageTitle":"连接上下文","url":"components/websocketServer/session.html","content":"连接上下文目录imi 中长连接服务（Http2、WebSocket、TCP）中使用 Imi\\ConnectionContext 类对连接上下文的会话数据进行管理。在整个连接的生命周期中都有效。比如我们可以在客户端发送认证鉴权操作时，向连接上下文中写入当前客户端的id等信息。会话数据可以设置存储器，用于将会话数据保存在不同的地方，满足各种需求。常见使用use Imi\\ConnectionContext;\n\n// 取值\necho ConnectionContext::get(&#039;name&#039;);\necho ConnectionContext::get(&#039;name&#039;, &#039;默认值&#039;);\n\n// 赋值\nConnectionContext::set(&#039;name&#039;, &#039;value&#039;);\n\n// 获取所有数据\n$array = ConnectionContext::getContext();\n\n// 使用回调并且自动加锁进行操作，回调用返回数据会保存进连接上下文\nConnectionContext::use(function($data){\n    // 本方法体会在锁中执行\n    var_dump($data); // 读取数据\n    $data[&#039;aaa&#039;] = 222;\n    return $data; // 写入数据，不return也可以，就是不修改\n});方法列表上下文操作可以参考（请求上下文）/**\n * 为当前连接创建上下文.\n */\npublic static function create(array $data = []): void;\n\n/**\n * 从某个连接上下文中，加载到当前上下文或指定上下文中.\n */\npublic static function load(int $fromClientId, ?int $toClientId = null): void;\n\n/**\n * 销毁当前连接的上下文.\n *\n * @param int|string|null $clientId\n */\npublic static function destroy($clientId = null): void;\n\n/**\n * 判断当前连接上下文是否存在.\n *\n * @param int|string|null $clientId\n */\npublic static function exists($clientId = null): bool;\n\n/**\n * 获取上下文数据.\n *\n * @param mixed           $default\n * @param int|string|null $clientId\n *\n * @return mixed\n */\npublic static function get(?string $name = null, $default = null, $clientId = null);\n\n/**\n * 设置上下文数据.\n *\n * @param string          $name\n * @param mixed           $value\n * @param int|string|null $clientId\n */\npublic static function set(?string $name, $value, $clientId = null): void;\n\n/**\n * 批量设置上下文数据.\n *\n * @param int|string|null $clientId\n */\npublic static function muiltiSet(array $data, $clientId = null): void;\n\n/**\n * 使用回调并且自动加锁进行操作，回调用返回数据会保存进连接上下文.\n *\n * @param int|string|null $clientId\n */\npublic static function use(callable $callable, $clientId = null): void;\n\n/**\n * 获取一个闭包的值并将其持久化, 下次请求将直接从连接上下文中获取.\n *\n * @param int|string|null $clientId\n *\n * @return mixed\n */\npublic static function remember(string $key, \\Closure $closure, $clientId = null, ?string $serverName = null);\n\n/**\n * 销毁一个上下文记住的值\n */\npublic static function unset(string $key): void;\n\n/**\n * 获取当前上下文.\n *\n * @param int|string|null $clientId\n */\npublic static function getContext($clientId = null): array;\n\n/**\n * 绑定一个标记到当前连接.\n *\n * @param int|string|null $clientId\n */\npublic static function bind(string $flag, $clientId = null): void;\n\n/**\n * 绑定一个标记到当前连接，如果已绑定返回false.\n *\n * @param int|string|null $clientId\n */\npublic static function bindNx(string $flag, $clientId = null): bool;\n\n/**\n * 取消绑定.\n *\n * @param int|string $clientId\n * @param int|null   $keepTime 旧数据保持时间，null 则不保留\n */\npublic static function unbind(string $flag, $clientId, ?int $keepTime = null): void;\n\n/**\n * 使用标记获取连接编号.\n *\n * @return array\n */\npublic static function getClientIdByFlag(string $flag);\n\n/**\n * 使用标记获取连接编号.\n *\n * @param string[] $flags\n */\npublic static function getClientIdsByFlags(array $flags): array;\n\n/**\n * 使用连接编号获取标记.\n *\n * @param int|string $clientId\n */\npublic static function getFlagByClientId($clientId): ?string;\n\n/**\n * 使用连接编号获取标记.\n *\n * @param int[]|string[] $clientIds\n *\n * @return string[]\n */\npublic static function getFlagsByClientIds(array $clientIds): array;\n\n/**\n * 使用标记获取旧的连接编号.\n */\npublic static function getOldClientIdByFlag(string $flag): ?int;\n\n/**\n * 恢复标记对应连接中的数据.\n */\npublic static function restore(string $flag, ?int $toClientId = null): void;\n\n/**\n * 获取当前连接号.\n *\n * @return int|string|null\n */\npublic static function getClientId();\n会话存储器Local 本地变量存储器本地变量存储，性能最高，适用于单机部署场景。如果使用 Swoole 模式，只建议在 SWOOLE_BASE 模式下使用&#039;beans&#039; =&gt;  [\n    &#039;ConnectionContextStore&#039;   =&gt;  [\n        &#039;handlerClass&#039;  =&gt;  \\Imi\\Server\\ConnectionContext\\StoreHandler\\Local::class,\n    ],\n    &#039;ConnectionContextLocal&#039;    =&gt;    [\n        &#039;lockId&#039;    =&gt;  null, // 非必设，可以用锁来防止数据错乱问题\n    ],\n],Redis 存储器数据储存在 Redis 中，需要将多实例服务的 key 设为不同，防止冲突。&#039;beans&#039; =&gt;  [\n    &#039;ConnectionContextStore&#039;   =&gt;  [\n        &#039;handlerClass&#039;  =&gt;  \\Imi\\Server\\ConnectionContext\\StoreHandler\\Redis::class,\n    ],\n    &#039;ConnectionContextRedis&#039;    =&gt;    [\n        &#039;redisPool&#039;    =&gt; &#039;redis&#039;, // Redis 连接池名称\n        &#039;redisDb&#039;      =&gt; null, // redis中第几个库，为null或不配置则使用连接池中的设置\n        &#039;key&#039;          =&gt; &#039;imi:connect_context&#039;, // 键\n        &#039;heartbeatTimespan&#039; =&gt; 5, // 心跳时间，单位：秒\n        &#039;heartbeatTtl&#039; =&gt; 8, // 心跳数据过期时间，单位：秒\n        &#039;dataEncode&#039;=&gt;  &#039;serialize&#039;, // 数据写入前编码回调\n        &#039;dataDecode&#039;=&gt;  &#039;unserialize&#039;, // 数据读出后处理回调\n        &#039;lockId&#039;    =&gt;  null, // 非必设，可以用锁来防止数据错乱问题\n    ],\n],Swoole MemoryTable 存储器数据储存在 Swoole 内存表中，适用于单机部署场景。此方案只为解决《我可以不用，但你不能没有》的问题，除非你真的很了解 Swoole Table，否则千万别用。&#039;beans&#039; =&gt;  [\n    &#039;ConnectionContextStore&#039;   =&gt;  [\n        &#039;handlerClass&#039;  =&gt;  \\Imi\\Swoole\\Server\\ConnectionContext\\StoreHandler\\MemoryTable::class,\n    ],\n    &#039;ConnectionContextMemoryTable&#039; =&gt;  [\n        &#039;tableName&#039; =&gt;  &#039;ConnectionContext&#039;, // tableName 你需要实现定义 MemoryTable，请查看相关章节\n        &#039;dataEncode&#039;=&gt;  &#039;serialize&#039;, // 数据写入前编码回调\n        &#039;dataDecode&#039;=&gt;  &#039;unserialize&#039;, // 数据读出后处理回调\n        &#039;lockId&#039;    =&gt;  null, // 非必设，因为如果用 MemoryTable，默认是用 MemoryTable 的 Lock\n    ],\n],Workerman Gateway 连接上下文处理器适用于使用 Workerman Gateway 模式，支持分布式。在 Swoole 中使用 Workerman Gateway 模式也可以用&#039;beans&#039; =&gt;  [\n    &#039;ConnectionContextStore&#039;   =&gt;  [\n        &#039;handlerClass&#039;  =&gt;  \\Imi\\WorkermanGateway\\Server\\ConnectionContext\\StoreHandler\\ConnectionContextGateway::class,\n    ],\n    &#039;ConnectionContextGateway&#039; =&gt;  [\n\n    ],\n],"},{"id":87,"title":"WebSocket 控制器","pageTitle":"WebSocket 控制器","url":"components/websocketServer/websocketController.html","content":"WebSocket 控制器目录所有从客户端发过来的数据都会打进控制器，我们开发项目时候，处理请求基本都是在控制器里做。定义&lt;?php\nnamespace ImiDemo\\WebSocketDemo\\MainServer\\WSController\\Index;\n\nuse Imi\\ConnectionContext;\nuse Imi\\Controller\\WebSocketController;\nuse Imi\\Server\\WebSocket\\Route\\Annotation\\WSRoute;\nuse Imi\\Server\\WebSocket\\Route\\Annotation\\WSAction;\nuse Imi\\Server\\WebSocket\\Route\\Annotation\\WSController;\n\n/**\n * 数据收发测试\n * @WSController\n */\nclass Test extends WebSocketController\n{\n    /**\n     * 登录\n     * \n     * @WSAction\n     * @WSRoute({&quot;action&quot;=&quot;login&quot;})\n     * @return void\n     */\n    public function login($data)\n    {\n        ConnectionContext::set(&#039;username&#039;, $data-&gt;username);\n        $this-&gt;server-&gt;joinGroup(&#039;g1&#039;, $this-&gt;frame-&gt;getClientId());\n        return [&#039;success&#039;=&gt;true];\n    }\n}首先控制器类必须有@WSController注解，对应动作必须有@WSAction和@WSRoute注解。注解@WSController注释目标：类表明一个类是控制器类属性名称说明routehttp 路由。如果设置，则只有握手指定 http 路由，才可以触发该 WebSocket 路由server指定当前控制器允许哪些服务器使用。支持字符串或数组，默认为 null 则不限制通常：@WSController指定匹配 http 路由：// 只有握手 /test 这个路径才可以触发该 WebSocket 动作\n@WSController(route=&quot;/test&quot;)@WSRoute指定 WebSocket 路由解析规则。// 解析 $data[&#039;action&#039;] === &#039;login&#039;\n@WSRoute({&quot;action&quot;=&quot;login&quot;})\n// 解析 $data[&#039;a&#039;][&#039;b&#039;][&#039;c&#039;] === &#039;login&#039;\n@WSRoute({&quot;a.b.c&quot;=&quot;login&quot;})\n// 解析 $data[&#039;a&#039;] == &#039;1&#039; &amp;&amp; $data[&#039;b&#039;] == &#039;2&#039;\n@WSRoute({&quot;a&quot;=&quot;1&quot;, &quot;b&quot;=&quot;2&quot;})当然对象也是支持的：// 解析 $data-&gt;a-&gt;b-&gt;c === &#039;login&#039;\n@WSRoute({&quot;a.b.c&quot;=&quot;login&quot;})指定匹配 http 路由：// 只有握手 /test 这个路径才可以触发该 WebSocket 动作\n@WSRoute(condition={&quot;action&quot;=&quot;login&quot;}, route=&quot;/test&quot;)路由匹配成功，就会执行这个动作。动作响应数据响应当前这个请求直接在方法中返回一个数组或对象，在Http 控制器中@WSConfig中设定的处理器，就会把这个转为对应数据响应给客户端。return [&#039;success&#039;=&gt;true];分组发送$this-&gt;server-&gt;groupCall(&#039;组名&#039;, &#039;push&#039;, [&#039;success&#039;=&gt;true]);当然，并不是每个请求都需要有响应数据，什么都不return或者return null就是不响应数据。类属性$server详见：https://doc.imiphp.com/v2.1/core/server.html$frame当然，你还可以直接通过请求上下文代理类，在任意地方使用：\\Imi\\Server\\WebSocket\\Message\\Proxy\\FrameProxy::getFormatData();方法公用方法：/**\n * 获取客户端的socket id.\n *\n * @return int|string\n */\npublic function getClientId();\n\n/**\n * 数据内容，可以是文本内容也可以是二进制数据，可以通过opcode的值来判断.\n */\npublic function getData(): string;\n\n/**\n * 获取格式化后的数据，一般是数组或对象\n *\n * @return mixed\n */\npublic function getFormatData();\n\n/**\n * WebSocket的OpCode类型，可以参考WebSocket协议标准文档\n * WEBSOCKET_OPCODE_TEXT = 0x1 ，文本数据\n * WEBSOCKET_OPCODE_BINARY = 0x2 ，二进制数据.\n */\npublic function getOpcode(): int;\n\n/**\n * 表示数据帧是否完整.\n */\npublic function isFinish(): bool;\n\n/**\n * 获取客户端地址\n */\npublic function getClientAddress(): \\Imi\\Util\\Socket\\IPEndPoint;Swoole 方法：/**\n * 获取 \\Swoole\\Websocket\\Frame 对象\n */\npublic function getSwooleWebSocketFrame(): \\Swoole\\Websocket\\Frame;"},{"id":"645b0aa9f3bd97.85993400","title":"WebSocket 路由","pageTitle":"WebSocket 路由","url":"components/websocketServer/websocketRoute.html","content":"WebSocket 路由目录通过@WSConfig中设置的数据处理器，把接收到的数据转为数组或对象后，根据路由注解或配置，解析并匹配为对应方法。@WSRoute 用法参考"},{"id":36,"title":"PHP-FPM","pageTitle":"PHP-FPM","url":"container/php-fpm.html","content":"PHP-FPM目录imi v2.0 版本开始，支持运行在 PHP-FPM 环境中。组件引入：composer require imiphp/imi-fpm核心特性特性是否支持Http✔Http2 WebSocket TCP UDP MQTT 性能优化移除不必要的组件移除没有用到的组件，比如 Swoole、Workerman 等项目设为非 debug 模式项目配置文件中，设置：[\n    &#039;debug&#039; =&gt; false,\n]当然你也可以在项目 Main 文件中，设置 imi 为非 debug 模式：\\Imi\\App::setDebug(false);生成运行时缓存在生产环境中，我们建议你每次部署都重新生成运行时缓存，以获得性能提升。生成项目缓存命令：vendor/bin/imi-cli imi/buildRuntime --app-namespace &quot;项目命名空间&quot; --runtimeMode=fpm生成后，会在 .runtime 目录中生成 runtime，部署更新项目时需要手动删除如果你是开发时，建议生成框架运行时缓存：vendor/bin/imi-cli imi/buildImiRuntime --app-namespace &quot;项目命名空间&quot; --runtimeMode=fpm生成后，会在 .runtime 目录中生成 imi-runtime，更新框架后需要手动删除配置优化在项目配置文件中配置：return [\n    &#039;imi&#039; =&gt; [\n        &#039;annotation&#039; =&gt; [\n            &#039;cache&#039; =&gt; true, // 启用注解解析文件缓存；修改代码不生效时，修改注解需要删除 `.runtime/annotation` 目录缓存\n        ],\n        &#039;bean&#039; =&gt; [\n            &#039;fileCache&#039; =&gt; true, // 启用 bean 文件缓存；修改代码不生效时，需要删除 `.runtime/classes` 目录缓存\n        ],\n    ],\n];命令启动开发服务: vendor/bin/imi-cli fpm/start此命令仅限于开发使用，正式环境推荐配合 Nginx 或 Apache 运行"},{"id":57,"title":"服务器配置","pageTitle":"服务器配置","url":"container/roadrunner/serverConfig.html","content":"服务器配置目录imi 项目配置：[\n    // 服务器配置，写死\n    &#039;roadRunnerServer&#039; =&gt; [\n        &#039;main&#039; =&gt; [\n            &#039;namespace&#039; =&gt; &#039;ImiApp\\ApiServer&#039;, // Http 服务的命名空间，为空则使用项目命名空间\n        ],\n    ],\n\n    // 日志配置\n    &#039;logger&#039; =&gt; [\n        &#039;channels&#039; =&gt; [\n            &#039;imi&#039; =&gt; [\n                &#039;handlers&#039; =&gt; [\n                    // 命令行下的日志\n                    [\n                        &#039;env&#039;       =&gt; [&#039;cli&#039;],\n                        &#039;class&#039;     =&gt; \\Imi\\Log\\Handler\\ConsoleHandler::class,\n                        &#039;formatter&#039; =&gt; [\n                            &#039;class&#039;     =&gt; \\Imi\\Log\\Formatter\\ConsoleLineFormatter::class,\n                            &#039;construct&#039; =&gt; [\n                                &#039;format&#039;                     =&gt; null,\n                                &#039;dateFormat&#039;                 =&gt; &#039;Y-m-d H:i:s&#039;,\n                                &#039;allowInlineLineBreaks&#039;      =&gt; true,\n                                &#039;ignoreEmptyContextAndExtra&#039; =&gt; true,\n                            ],\n                        ],\n                    ],\n                    // RoadRunner worker 下日志\n                    [\n                        &#039;env&#039;       =&gt; [&#039;roadrunner&#039;],\n                        &#039;class&#039;     =&gt; \\Monolog\\Handler\\StreamHandler::class,\n                        &#039;construct&#039; =&gt; [\n                            &#039;stream&#039;  =&gt; &#039;php://stderr&#039;,\n                        ],\n                        &#039;formatter&#039; =&gt; [\n                            &#039;class&#039;     =&gt; \\Monolog\\Formatter\\LineFormatter::class,\n                            &#039;construct&#039; =&gt; [\n                                &#039;format&#039;                     =&gt; null,\n                                &#039;dateFormat&#039;                 =&gt; &#039;Y-m-d H:i:s&#039;,\n                                &#039;allowInlineLineBreaks&#039;      =&gt; true,\n                                &#039;ignoreEmptyContextAndExtra&#039; =&gt; true,\n                            ],\n                        ],\n                    ],\n                    // 文件日志\n                    [\n                        &#039;class&#039;     =&gt; \\Monolog\\Handler\\RotatingFileHandler::class,\n                        &#039;construct&#039; =&gt; [\n                            &#039;filename&#039; =&gt; dirname(__DIR__) . &#039;/logs/log.log&#039;, // 路径可以自定义\n                        ],\n                        &#039;formatter&#039; =&gt; [\n                            &#039;class&#039;     =&gt; \\Monolog\\Formatter\\LineFormatter::class,\n                            &#039;construct&#039; =&gt; [\n                                &#039;dateFormat&#039;                 =&gt; &#039;Y-m-d H:i:s&#039;,\n                                &#039;allowInlineLineBreaks&#039;      =&gt; true,\n                                &#039;ignoreEmptyContextAndExtra&#039; =&gt; true,\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    &#039;beans&#039; =&gt; [\n        // 热更新配置\n        &#039;hotUpdate&#039;    =&gt;    [\n            // &#039;status&#039;    =&gt;    false, // 关闭热更新去除注释，不设置即为开启，建议生产环境关闭\n\n            // --- 文件修改时间监控 ---\n            // &#039;monitorClass&#039;    =&gt;    \\Imi\\HotUpdate\\Monitor\\FileMTime::class,\n            // &#039;timespan&#039;    =&gt;    1, // 检测时间间隔，单位：秒\n\n            // --- Inotify 扩展监控 ---\n            // &#039;monitorClass&#039;    =&gt;    \\Imi\\HotUpdate\\Monitor\\Inotify::class,\n            // &#039;timespan&#039;    =&gt;    0, // 检测时间间隔，单位：秒，使用扩展建议设为0性能更佳\n\n            // &#039;includePaths&#039;    =&gt;    [], // 要包含的路径数组\n            // &#039;excludePaths&#039;    =&gt;    [], // 要排除的路径数组，支持通配符*\n            // &#039;defaultPath&#039;    =&gt;    [], // 设为数组则覆盖默认的监控路径\n        ],\n    ],\n].rr.yaml 配置：server:\n  command: &quot;php bin/bootstrap.php&quot; # 项目 Worker 启动文件\n\nhttp:\n  # 配置监听地址\n  address: 0.0.0.0:8080\n  pool:\n    num_workers: 2 # 设置进程数量\n  # 静态文件访问配置\n  static:\n    dir: &quot;.&quot;\n    forbid: [&quot;&quot;]\n    allow: [&quot;.txt&quot;, &quot;.php&quot;]\n    calculate_etag: false\n    weak: false\n    request:\n      input: &quot;custom-header&quot;\n    response:\n      output: &quot;output-header&quot;\n\nrpc:\n  listen: tcp://127.0.0.1:6001具体请查阅 RoadRunner 官方文档：https://roadrunner.dev/docs"},{"id":56,"title":"RoadRunner","pageTitle":"RoadRunner","url":"container/roadrunner.html","content":"RoadRunner目录RoadRunner 是一款开源（MIT 协议）高性能 PHP 应用服务器、负载均衡器和进程管理器。它支持作为服务运行，能够在每个项目的基础上扩展功能。RoadRunner 包括 PSR-7/PSR-17 兼容的 HTTP 和 HTTP/2 服务器，可用于取代传统的 Nginx+FPM 设置，具有更高的性能和灵活性。RoadRunner Github：https://github.com/spiral/roadrunnerRoadRunner 官方文档：https://roadrunner.dev/docs组件引入：composer require imiphp/imi-roadrunner核心特性特性是否支持Http✔Http2✔WebSocket TCP UDP MQTT 命令启动服务: vendor/bin/imi-cli rr/start停止服务: vendor/bin/imi-cli rr/stop重载服务: vendor/bin/imi-cli rr/reload以上所有命令都支持以下参数：  -w, --workDir[=WORKDIR]              工作路径\n  -c, --config[=CONFIG]                配置文件路径，默认 .rr.yaml环境变量名称默认值描述IMI_ROADRUNNER_BINARYfalseRoadRunner 二进制文件路径，如果不指定则自动寻找"},{"id":49,"title":"Swoole 事件列表","pageTitle":"Swoole 事件列表","url":"container/swoole/events.html","content":"Swoole 事件列表目录Swoole 环境事件IMI.SWOOLE.MAIN_COROUTINE.ENDSwoole 主协程执行完毕事件，此事件在协程中事件参数：无IMI.SWOOLE.MAIN_COROUTINE.AFTERSwoole 主协程执行完毕后置事件，此事件在非协程中事件参数：无IMI.SWOOLE.SERVER.BEFORE_STARTSwoole 服务器开始前事件参数：无IMI.MAIN_SERVER.WORKER.START.APP在项目中监听 WorkerStart 事件事件参数：class WorkerStartEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * Worker进程ID\n     * @var int\n     */\n    public $workerId;\n}IMI.PROCESS_POOL.PROCESS.BEGIN自定义进程池中的进程开始事件事件参数：string $name, \\Swoole\\Process\\Pool $pool, int $workerId, int $workerNum, array $args, int $ipcType, string $msgQueueKeyIMI.PROCESS_POOL.PROCESS.END自定义进程池中的进程结束事件事件参数：string $name, \\Swoole\\Process\\Pool $pool, int $workerId, int $workerNum, array $args, int $ipcType, string $msgQueueKeySwoole Server 全局事件IMI.MAIN_SERVER.STARTOnStart事件参数：class StartEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n}IMI.MAIN_SERVER.SHUTDOWNOnShutdown事件参数：class ShutdownEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n}IMI.MAIN_SERVER.WORKER.STARTOnWorkerStart事件参数：class WorkerStartEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * Worker进程ID\n     * @var int\n     */\n    public $workerId;\n}IMI.MAIN_SERVER.WORKER.STOPOnWorkerStop事件参数：class WorkerStopEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * Worker进程ID\n     * @var int\n     */\n    public $workerId;\n}IMI.MAIN_SERVER.MANAGER.STARTOnManagerStart事件参数：class ManagerStartEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n}IMI.MAIN_SERVER.MANAGER.STOPOnManagerStop事件参数：class ManagerStopEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n}IMI.MAIN_SERVER.TASKOnTask事件参数：class TaskEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 任务ID\n     * @var int\n     */\n    public $taskId;\n\n    /**\n     * worker进程ID\n     * @var int\n     */\n    public $workerId;\n\n    /**\n     * 任务数据\n     * @var mixed\n     */\n    public $data;\n}IMI.MAIN_SERVER.FINISHOnFinish事件参数：class FinishEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 任务ID\n     * @var int\n     */\n    public $taskId;\n\n    /**\n     * 任务数据\n     * @var mixed\n     */\n    public $data;\n}IMI.MAIN_SERVER.PIPE_MESSAGEOnPipeMessage事件参数：class PipeMessageEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * Worker进程ID\n     * @var int\n     */\n    public $workerId;\n\n    /**\n     * 消息内容，可以是任意PHP类型\n     * @var mixed\n     */\n    public $message;\n}IMI.MAIN_SERVER.WORKER_ERROROnWorkerError事件参数：class WorkerErrorEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * Worker进程ID\n     * @var int\n     */\n    public $workerId;\n\n    /**\n     * Worker进程PID\n     *\n     * @var int\n     */\n    public $workerPid;\n    \n    /**\n     * 退出的状态码，范围是 1 ～255\n     *\n     * @var int\n     */\n    public $exitCode;\n\n    /**\n     * 进程退出的信号\n     *\n     * @var int\n     */\n    public $signal;\n}Swoole Server 对象事件对象事件是由多个服务器对象发出的，监听多个端口即认定为多个服务器。Http Server事件监听：@ClassEventListener(className=&quot;Imi\\Swoole\\Server\\Http\\Server&quot;, eventName=&quot;事件名&quot;)Http 请求事件事件名：request事件参数：class RequestEventParam extends EventParam\n{\n    /**\n     * swoole 请求对象\n     * @var \\Imi\\Server\\Http\\Message\\Request\n     */\n    public $request;\n\n    /**\n     * swoole 响应对象\n     * @var \\Imi\\Server\\Http\\Message\\Response\n     */\n    public $response;\n}Swoole 关闭连接事件事件名：close事件参数：class CloseEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 客户端连接的标识符\n     * @var int|string\n     */\n    public $clientId;\n\n    /**\n     * 来自那个reactor线程\n     *\n     * @var int\n     */\n    public $reactorId;\n}WebSocket Server事件监听：@ClassEventListener(className=&quot;Imi\\Swoole\\Server\\WebSocket\\Server&quot;, eventName=&quot;事件名&quot;)WebSocket 握手事件事件名：handShake握手事件事件参数：class HandShakeEventParam extends EventParam\n{\n    /**\n     * swoole 请求对象\n     * @var \\Imi\\Server\\Http\\Message\\Request\n     */\n    public $request;\n\n    /**\n     * swoole 响应对象\n     * @var \\Imi\\Server\\Http\\Message\\Response\n     */\n    public $response;\n}握手后打开连接事件事件名：open握手完成后打开连接事件事件参数：class OpenEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     *\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 客户端连接的标识符.\n     *\n     * @var \\Imi\\Server\\Http\\Message\\Request\n     */\n    public $request;\n}消息事件事件名：message事件参数：class MessageEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * swoole 数据帧对象\n     * @var \\swoole_websocket_frame\n     */\n    public $frame;\n}WebSocket 连接关闭事件事件名：close事件参数：class CloseEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 客户端连接的标识符\n     * @var int|string\n     */\n    public $clientId;\n\n    /**\n     * 来自那个reactor线程\n     *\n     * @var int\n     */\n    public $reactorId;\n}非 WebSocket 连接关闭事件事件名：disconnect只有非 WebSocket 连接关闭时才会触发该事件。事件参数：class DisconnectEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 客户端连接的标识符\n     * @var int|string\n     */\n    public $clientId;\n}TCP Server事件监听：@ClassEventListener(className=&quot;Imi\\Swoole\\Server\\TcpServer\\Server&quot;, eventName=&quot;事件名&quot;)连接事件事件名：connect事件参数：class ConnectEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 客户端连接的标识符\n     * @var int|string\n     */\n    public $clientId;\n\n    /**\n     * Reactor线程ID\n     * @var int\n     */\n    public $reactorId;\n}接收数据事件事件名：receive事件参数：class ReceiveEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 客户端连接的标识符\n     * @var int|string\n     */\n    public $clientId;\n\n    /**\n     * Reactor线程ID\n     * @var int\n     */\n    public $reactorId;\n\n    /**\n     * 接收到的数据\n     *\n     * @var string\n     */\n    public $data;\n}TCP 连接关闭事件事件名：close事件参数：class CloseEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 客户端连接的标识符\n     * @var int|string\n     */\n    public $clientId;\n\n    /**\n     * 来自那个reactor线程\n     *\n     * @var int\n     */\n    public $reactorId;\n}UDP Server事件监听：@ClassEventListener(className=&quot;Imi\\Swoole\\Server\\UdpServer\\Server&quot;, eventName=&quot;事件名&quot;)包事件事件名：packet事件参数：class PacketEventParam extends EventParam\n{\n    /**\n     * 服务器对象\n     * @var \\Imi\\Swoole\\Server\\Base\n     */\n    public $server;\n\n    /**\n     * 数据\n     * @var string\n     */\n    public $data;\n\n    /**\n     * 客户端信息\n     *\n     * @var array\n     */\n    public $clientInfo;\n}"},{"id":37,"title":"Swoole","pageTitle":"Swoole","url":"container/swoole.html","content":"Swoole目录imi v0.0.1 版本开始，支持运行在 Swoole 环境中。组件引入：composer require imiphp/imi-swoole核心特性特性是否支持Http✔Http2✔WebSocket✔TCP✔UDP✔MQTT✔命令启动服务: vendor/bin/imi-swoole swoole/start停止服务: vendor/bin/imi-swoole swoole/stop重载服务: vendor/bin/imi-swoole swoole/reload重载服务仅干掉所有 Worker 进程，让他们重新启动，并不能代替冷重启，有些代码是无法靠重载更新的。"},{"id":55,"title":"Workerman 事件列表","pageTitle":"Workerman 事件列表","url":"container/workerman/events.html","content":"Workerman 事件列表目录Workerman Server 全局事件IMI.WORKERMAN.SERVER.BUFFER_DRAINonBufferDrain事件参数：名称描述server服务器对象clientId连接IDconnectionWorkerman Connection 对象IMI.WORKERMAN.SERVER.BUFFER_FULLonBufferFull事件参数：名称描述server服务器对象clientId连接IDconnectionWorkerman Connection 对象IMI.WORKERMAN.SERVER.CLOSEonClose事件参数：名称描述server服务器对象clientId连接IDconnectionWorkerman Connection 对象IMI.WORKERMAN.SERVER.CONNECTonConnect事件参数：名称描述server服务器对象clientId连接IDconnectionWorkerman Connection 对象IMI.WORKERMAN.SERVER.ERRORonError事件参数：名称描述server服务器对象clientId连接IDconnectionWorkerman Connection 对象code错误代码msg错误信息IMI.WORKERMAN.SERVER.WORKER_RELOADonWorkerReload事件参数：名称描述server服务器对象workerWorkerman Worker 对象IMI.WORKERMAN.SERVER.WORKER_STARTonWorkerStart事件参数：名称描述server服务器对象workerWorkerman Worker 对象IMI.WORKERMAN.SERVER.WORKER_STOPonWorkerStop事件参数：名称描述server服务器对象workerWorkerman Worker 对象IMI.WORKERMAN.SERVER.HTTP.REQUESThttp onMessage事件参数：名称描述server服务器对象requestRequest 对象responseResponse 对象IMI.WORKERMAN.SERVER.WEBSOCKET.CONNECTwebsocket onWebSocketConnect事件参数：名称描述server服务器对象connectionWorkerman Connection 对象clientId连接IDrequestRequest 对象responseResponse 对象IMI.WORKERMAN.SERVER.WEBSOCKET.MESSAGEwebsocket onMessage事件参数：名称描述server服务器对象connectionWorkerman Connection 对象clientId连接IDdata原始数据frame\\Imi\\Workerman\\Cron\\Protocol\\Frame 对象IMI.WORKERMAN.SERVER.TCP.MESSAGEtcp onMessage事件参数：名称描述server服务器对象connectionWorkerman Connection 对象clientId连接IDdata原始数据IMI.WORKERMAN.SERVER.UDP.MESSAGEudp onMessage事件参数：名称描述server服务器对象connectionWorkerman Connection 对象data原始数据packetData\\Imi\\Workerman\\Server\\Udp\\Message\\PacketData 对象"},{"id":51,"title":"服务器配置","pageTitle":"服务器配置","url":"container/workerman/serverConfig.html","content":"服务器配置目录return [\n    // Workerman 服务器配置\n    &#039;workermanServer&#039; =&gt; [\n        // 服务器名，http 也可以改成 abc 等等，完全自定义\n        &#039;http&#039; =&gt; [\n            // 指定服务器命名空间\n            &#039;namespace&#039; =&gt; &#039;Imi\\Workerman\\Test\\HttpServer\\ApiServer&#039;,\n            // 服务器类型\n            &#039;type&#039;      =&gt; Imi\\Workerman\\Server\\Type::HTTP, // HTTP、WEBSOCKET、TCP、UDP\n            &#039;host&#039;      =&gt; &#039;0.0.0.0&#039;,\n            &#039;port&#039;      =&gt; 8080,\n            // socket的上下文选项，参考：http://doc3.workerman.net/315128\n            &#039;context&#039;   =&gt; [],\n            &#039;configs&#039;   =&gt; [\n                // 支持设置 Workerman 参数\n            ],\n            // 服务器容器绑定\n            &#039;beans&#039; =&gt; [\n                &#039;aaa&#039; =&gt; XXX::class,\n            ],\n        ],\n        // 下面可以继续加入其它协议其它端口的服务\n        &#039;websocket&#039; =&gt; [\n            &#039;namespace&#039;   =&gt; &#039;Imi\\Workerman\\Test\\AppServer\\WebSocketServer&#039;,\n            &#039;type&#039;        =&gt; Imi\\Workerman\\Server\\Type::WEBSOCKET,\n            &#039;host&#039;        =&gt; &#039;0.0.0.0&#039;,\n            &#039;port&#039;        =&gt; 13002,\n            &#039;shareWorker&#039; =&gt; &#039;http&#039;, // 与名字叫 http 的服务，共享 worker 进程\n            &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::TEXT, // 配置 WebSocket 纯文本通信协议\n            // &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::BINARY, // 配置 WebSocket 二进制通信协议\n            &#039;configs&#039;     =&gt; [\n            ],\n        ],\n    ],\n    &#039;workerman&#039; =&gt; [\n        // 设置给 Worker 类静态属性的配置\n        &#039;worker&#039; =&gt; [\n            \n        ],\n    ],\n];"},{"id":50,"title":"Workerman","pageTitle":"Workerman","url":"container/workerman.html","content":"Workerman目录imi v2.0 版本开始，支持运行在 Workerman 环境中。组件引入：composer require imiphp/imi-workerman核心特性特性是否支持Http✔Http2✔WebSocket✔TCP✔UDP✔MQTT 命令启动服务: vendor/bin/imi-workerman workerman/start停止服务: vendor/bin/imi-workerman workerman/stop注意事项send buffer full and drop package这个问题一般出现在，服务器循环发送数据给客户端，导致塞满发送缓冲区。解决办法：如果你是 Workerman，可以在入口文件中加上：// 发送缓冲区大小，单位：字节。可以根据需要调整，不建议设置得很大，会浪费内存\n\\Workerman\\Connection\\TcpConnection::$defaultMaxSendBufferSize = 2 * 1024 * 1024;如果你是 Workerman Gateway，可以在服务器配置中的 configs 加上相应配置：[\n    &#039;gateway&#039; =&gt; [\n        &#039;namespace&#039;   =&gt; &#039;Imi\\WorkermanGateway\\Test\\AppServer\\Gateway&#039;,\n        &#039;type&#039;        =&gt; Imi\\WorkermanGateway\\Workerman\\Server\\Type::GATEWAY,\n        &#039;socketName&#039;  =&gt; &#039;websocket://0.0.0.0:8081&#039;, // 网关监听的地址\n        &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::TEXT, // 配置 WebSocket 纯文本通信协议\n        // &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::BINARY, // 配置 WebSocket 二进制通信协议\n        &#039;configs&#039;     =&gt; [\n            &#039;lanIp&#039;           =&gt; &#039;127.0.0.1&#039;,\n            &#039;startPort&#039;       =&gt; 12900,\n            &#039;registerAddress&#039; =&gt; &#039;127.0.0.1:13004&#039;,\n            // 发送缓冲区大小，单位：字节。可以根据需要调整，不建议设置得很大，会浪费内存\n            &#039;sendToClientBufferSize&#039; =&gt; 2 * 1024 * 1024,\n        ],\n    ],\n]"},{"id":27,"title":"内置常量列表","pageTitle":"内置常量列表","url":"core/consts.html","content":"内置常量列表目录名称描述参考值IMI_IN_PHAR是否运行在 phar 模式falseIMI_RUNNING_ROOT工作路径/project-httpIMI_PHAR_BUILD_TIMEphar 构建时间的时间2022-01-01T00:00:00+08:00IMI_PHAR_BUILD_GIT_HASHphar 构建时的 Git commit hashd2968049be531d98ec3a0d7230323ca21fb65334IMI_PHAR_BUILD_GIT_BRANCHphar 构建时的 Git 分支masterIMI_PHAR_BUILD_GIT_TAGphar 构件时的 Git Tagv1.0.0"},{"id":15,"title":"容器","pageTitle":"容器","url":"core/container.html","content":"容器目录imi 框架的容器采用了依赖注入 (Dependency Injection，简称 DI) 的设计模式，用于管理和注入对象及其依赖关系。imi 框架的容器包括全局容器、服务器容器和请求上下文容器。在 imi 框架中，通过注解实现的功能，对象如果是直接 new 出来的，是不会生效的，必须使用容器！因为 imi 框架的容器可以管理对象及其依赖关系，并实现依赖注入。使用容器可以更方便地管理对象的生命周期和依赖关系，提高应用程序的可维护性和性能表现。实例化对象实例化对象用法可以代替 new。// 具体的类名\n\\Imi\\Bean\\BeanFactory::newInstance(XXX::class);\n// 传入构造方法的参数\n\\Imi\\Bean\\BeanFactory::newInstance(XXX::class, 1, 2);容器分类全局容器服务器容器（继承全局容器）请求上下文容器（继承服务器容器或全局容器）全局单例容器（不支持 AOP、注解等）全局容器全局容器是全局共享的，用于存储应用程序中的单例对象。全局容器存活于框架整个生命周期，是一种全局的、共享的容器，可以被整个应用程序的代码访问。获取对象：$object = \\Imi\\App::getBean(&#039;XXX&#039;);\n$object = \\Imi\\App::getBean(&#039;XXX&#039;, 1, 2, 3); // 支持实例化参数\n\n// 获取容器对象\n$container = \\Imi\\App::getContainer();\n$object = $container-&gt;get(&#039;XXX&#039;);配置类别名：方法一-注解：&lt;?php\nuse Imi\\Bean\\Annotation\\Bean;\n\n/**\n * @Bean(&quot;XXX&quot;)\n */\nclass Test\n{\n\n}方法二-项目配置文件：[\n    &#039;imi&#039; =&gt; [\n        &#039;beans&#039; =&gt; [\n            &#039;XXX&#039; =&gt; Test::class,\n        ],\n    ],\n]如上配置后，就可以使用 \\Imi\\App::getBean(&#039;XXX&#039;) 等方式实例化了同理，你甚至可以使用自己写的类，配置覆盖 imi 内置的同名类动态绑定：use Imi\\App;\n\n// 绑定\nApp::getContainer()-&gt;bind(&#039;aaa&#039;, XXX::class);\n\n// 绑定带参数，非单例模式，禁用递归依赖\nApp::getContainer()-&gt;bind(&#039;aaa&#039;, XXX::class, \\Imi\\Bean\\Annotation\\Bean::INSTANCE_TYPE_EACH_NEW, false);\n\n// 实例化，带缓存\n$obj = App::getBean(&#039;aaa&#039;);\n\n// 实例化，带参数，不缓存\n$obj = App::getBean(&#039;aaa&#039;, 1);\n\n// 绑定回调\nApp::getContainer()-&gt;bindCallable(&#039;bbb&#039;, function(string $id, int $a) {\n    var_dump($id); // aaa\n    var_dump($a);  // 123\n    // 返回你要实例化的对象，这里只是示例\n    return new \\stdClass;\n});\n$obj = App::getBean(&#039;aaa&#039;, 123);\n\n// 设置实例\nApp::getContainer()-&gt;set(&#039;ccc&#039;, new \\stdClass);\nApp::getContainer()-&gt;getBean(&#039;ccc&#039;);禁用递归依赖可以规避服务启动后，第一次访问概率报错问题服务器容器服务器容器是针对每个子服务器独立的，用于存储服务器级别的对象。服务器容器中存储的对象是针对目标服务器的，不同服务器之间的容器是互相独立的。在服务器容器中，目前存储了该服务器的路由对象及配置等等。比如，如果你的项目同时监听了 Http、TCP 两个协议端口，那么在 Http 请求接口进来时，通过服务器容器获取到的对象只会是该 Http 服务独有的，在 TCP 服务中是无法访问的。获取对象：$object = \\Imi\\Server\\ServerManager::getServer(&#039;main&#039;)-&gt;getBean(&#039;XXX&#039;);\n\n// 获取容器对象\n$container = \\Imi\\Server\\ServerManager::getServer(&#039;main&#039;)-&gt;getContainer();\n$object = $container-&gt;get(&#039;XXX&#039;);配置类别名：方法一-注解：&lt;?php\nuse Imi\\Bean\\Annotation\\Bean;\n\n/**\n * @Bean(&quot;XXX&quot;)\n */\nclass Test\n{\n\n}方法二-项目配置文件：默认情况下继承全局容器配置，服务器容器配置因环境不同而有所差异，具体细节可以参考各环境的服务器配置文档。动态绑定：use Imi\\Server\\ServerManager;\n\n// 绑定\nServerManager::getServer()-&gt;getContainer()-&gt;bind(&#039;aaa&#039;, XXX::class);\n\n// 绑定带参数，非单例模式，禁用递归依赖\nServerManager::getServer()-&gt;getContainer()-&gt;bind(&#039;aaa&#039;, XXX::class, \\Imi\\Bean\\Annotation\\Bean::INSTANCE_TYPE_EACH_NEW, false);\n\n// 实例化，带缓存\n$obj = ServerManager::getServer()-&gt;getContainer()-&gt;getBean(&#039;aaa&#039;);\n\n// 实例化，带参数，不缓存\n$obj = ServerManager::getServer()-&gt;getContainer()-&gt;getBean(&#039;aaa&#039;, 1);禁用递归依赖可以规避服务启动后，第一次访问概率报错问题请求上下文容器请求上下文容器是当前请求有效的容器，请求结束时即销毁。请求上下文容器中存储的对象是针对当前请求有效的，请求结束后会自动销毁。有关更多细节可以参考请求上下文。请求上下文容器可以为每个请求提供独立的容器实例，以存储请求处理中所需的对象，例如请求参数、数据库连接等。请求上下文容器的使用可以避免多个请求之间的对象冲突，提高应用程序的可靠性和稳定性。获取对象：$object = \\Imi\\RequestContext::getBean(&#039;XXX&#039;);\n\n// 获取容器对象\n$container = \\Imi\\RequestContext::getContainer();\n$object = $container-&gt;get(&#039;XXX&#039;);配置类别名：方法一-注解：&lt;?php\nuse Imi\\Bean\\Annotation\\Bean;\n\n/**\n * @Bean(&quot;XXX&quot;)\n */\nclass Test\n{\n\n}方法二-项目配置文件：继承全局容器或服务器容器配置动态绑定：请求上下文容器：use Imi\\RequestContext;\n\n// 绑定\nRequestContext::getContainer()-&gt;bind(&#039;aaa&#039;, XXX::class);\n\n// 绑定带参数，非单例模式，禁用递归依赖\nRequestContext::getContainer()-&gt;bind(&#039;aaa&#039;, XXX::class, \\Imi\\Bean\\Annotation\\Bean::INSTANCE_TYPE_EACH_NEW, false);\n\n// 实例化，带缓存\n$obj = RequestContext::getBean(&#039;aaa&#039;);\n\n// 实例化，带参数，不缓存\n$obj = RequestContext::getBean(&#039;aaa&#039;, 1);禁用递归依赖可以规避服务启动后，第一次访问概率报错问题全局单例容器全局单例容器可以用于实例化全局共享的单例对象，该对象不会被 AOP、注解等功能所影响，只是单纯的单例。可以通过全局单例容器在整个应用程序中共享同一个对象实例，提高应用程序的性能和效率。获取对象：$object = \\Imi\\App::getSingleton(&#039;XXX&#039;);配置类别名：同全局容器动态绑定：同全局容器全局容器实例化全局容器实例化方法可以用于每次调用时实例化并返回新的对象，同时 AOP、注解等功能仍然有效。通过全局容器实例化方法可以轻松地获取到全局范围内的新对象，可以为每个调用提供独立的对象实例，避免对象冲突和资源浪费。实例化对象：$object = \\Imi\\App::newInstance(&#039;XXX&#039;);\n$object = \\Imi\\App::newInstance(&#039;XXX&#039;, 1, 2, 3); // 支持实例化参数配置类别名：同全局容器动态绑定：同全局容器容器对象类 (Bean)在容器中，可以通过 getBean() 方法来获取已经注册的 Bean 对象。在调用 getBean() 方法时，可以传递带有完整命名空间的类名或者别名。如果需要定义别名，可以使用 @Bean 注解进行定义。除此之外，在 Bean 类中还可以定义一个名为 __init() 的方法，该方法会作为第二个构造方法被执行。具体的执行顺序为：__construct() -&gt; injectProps() -&gt; __init()。其中，injectProps() 方法用于属性注入，具体内容可以参考 AOP 章节的相关内容。定义：namespace Test;\n\n/**\n * 下面两种写法相同（注意实际不要写多个 Bean 注解）\n * @Bean(&quot;MyTest&quot;)\n * @Bean(name=&quot;MyTest&quot;)\n *\n * 下面是禁用递归依赖和设置实例化类型，可以根据实际情况设置\n * @Bean(name=&quot;MyTest&quot;, instanceType=\\Imi\\Bean\\Annotation\\Bean::INSTANCE_TYPE_SINGLETON, recursion=false)\n *\n * 下面是限制生效的环境，支持一个或多个\n * @Bean(name=&quot;MyTest&quot;, env=&quot;swoole&quot;)\n * @Bean(name=&quot;MyTest&quot;, env={&quot;swoole&quot;, &quot;workerman&quot;})\n */\nclass ABCDEFG\n{\n    public function __construct($id)\n    {\n        echo &#039;first&#039;, PHP_EOL;\n    }\n\n    public function __init($id)\n    {\n        echo &#039;second first&#039;, PHP_EOL;\n    }\n}获得实例：App::getBean(&#039;MyTest&#039;);\nApp::getBean(\\Test\\ABCDEFG::class);注解继承默认情况下，子类继承父类时，父类的注解是不会生效的。但是有时候我们需要让父类的注解生效。在这种情况下，可以在类、方法、属性或常量上使用 @Inherit 注解来实现。类名：Imi\\Bean\\Annotation\\Inherit参数：/**\n * 允许的注解类，为 null 则不限制，支持字符串或数组\n *\n * @var string|string[]\n */\npublic $annotation;例子：下面是一个模型的例子，我们可以在父类中定义一些结构，然后在子类中编写自定义代码。如果重新生成模型的父类代码，这些自定义代码不会被覆盖掉。父类：&lt;?php\nnamespace Imi\\Test\\Component\\Model\\Base;\n\nuse Imi\\Model\\Model;\nuse Imi\\Model\\Annotation\\Table;\nuse Imi\\Model\\Annotation\\Column;\nuse Imi\\Model\\Annotation\\Entity;\n\n/**\n * ArticleBase\n * @Entity\n * @Table(name=&quot;tb_article&quot;, id={&quot;id&quot;})\n * @property int $id\n * @property string $title\n * @property string $content\n * @property string $time\n */\nabstract class ArticleBase extends Model\n{\n    /**\n     * id\n     * @Column(name=&quot;id&quot;, type=&quot;int&quot;, length=10, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=true, primaryKeyIndex=0, isAutoIncrement=true)\n     * @var int\n     */\n    protected $id;\n\n    /**\n     * 获取 id\n     *\n     * @return int\n     */\n    public function getId()\n    {\n        return $this-&gt;id;\n    }\n\n    /**\n     * 赋值 id\n     * @param int $id id\n     * @return static\n     */\n    public function setId($id)\n    {\n        $this-&gt;id = $id;\n        return $this;\n    }\n\n    /**\n     * title\n     * @Column(name=&quot;title&quot;, type=&quot;varchar&quot;, length=255, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var string\n     */\n    protected $title;\n\n    /**\n     * 获取 title\n     *\n     * @return string\n     */\n    public function getTitle()\n    {\n        return $this-&gt;title;\n    }\n\n    /**\n     * 赋值 title\n     * @param string $title title\n     * @return static\n     */\n    public function setTitle($title)\n    {\n        $this-&gt;title = $title;\n        return $this;\n    }\n\n    /**\n     * content\n     * @Column(name=&quot;content&quot;, type=&quot;mediumtext&quot;, length=0, accuracy=0, nullable=false, default=&quot;&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var string\n     */\n    protected $content;\n\n    /**\n     * 获取 content\n     *\n     * @return string\n     */\n    public function getContent()\n    {\n        return $this-&gt;content;\n    }\n\n    /**\n     * 赋值 content\n     * @param string $content content\n     * @return static\n     */\n    public function setContent($content)\n    {\n        $this-&gt;content = $content;\n        return $this;\n    }\n\n    /**\n     * time\n     * @Column(name=&quot;time&quot;, type=&quot;timestamp&quot;, length=0, accuracy=0, nullable=false, default=&quot;CURRENT_TIMESTAMP&quot;, isPrimaryKey=false, primaryKeyIndex=-1, isAutoIncrement=false)\n     * @var string\n     */\n    protected $time;\n\n    /**\n     * 获取 time\n     *\n     * @return string\n     */\n    public function getTime()\n    {\n        return $this-&gt;time;\n    }\n\n    /**\n     * 赋值 time\n     * @param string $time time\n     * @return static\n     */\n    public function setTime($time)\n    {\n        $this-&gt;time = $time;\n        return $this;\n    }\n\n}子类：&lt;?php\nnamespace Imi\\Test\\Component\\Model;\n\nuse Imi\\Bean\\Annotation\\Inherit;\nuse Imi\\Test\\Component\\Model\\Base\\ArticleBase;\n\n/**\n * Article\n * @Inherit\n */\nclass Article extends ArticleBase\n{\n\n}配置扫描命名空间应用启动时，会扫描配置文件中指定的命名空间，所有被扫描到的类才可以通过容器来获取。在项目和子服务器的配置文件中，可以通过配置来指定需要扫描的命名空间。return [\n    &#039;beanScan&#039;  =&gt;  [\n        &#039;ImiApp\\Model&#039;,\n        &#039;ImiApp\\Service&#039;,\n    ],\n];imi v2.0 版本开始已经不一定需要配置 beanScan 了"},{"id":26,"title":"环境变量列表","pageTitle":"环境变量列表","url":"core/env.html","content":"环境变量列表名称默认值描述IMI_SCAN_STATISTICStrue是否输出扫描阶段的日志"},{"id":20,"title":"事件列表","pageTitle":"事件列表","url":"core/events.html","content":"事件列表目录imi 框架事件IMI.INITED框架初始化事件事件参数：无IMI.APP_RUN应用运行事件事件参数：无IMI.APP.INIT项目初始化事件，执行比 IMI.APP_RUN 要晚事件参数：无IMI.COMMAND.BEFORE命令行执行前置事件事件参数：无IMI.COMMAND.AFTER命令行执行后置事件事件参数：无IMI.LOAD_RUNTIME_INFO加载 runtime 事件，在此事件中，绝对可以使用 App::getRuntimeInfo() 获取到数据。IMI.SERVER.CREATE.BEFORE创建服务器对象前置操作，主服务器+子服务器，每个创建前都会触发！事件参数：无IMI.SERVER.CREATE.AFTER创建服务器对象前置后作，主服务器+子服务器，每个创建后都会触发！事件参数：无IMI.SERVERS.CREATE.BEFORE创建服务器对象前置后作，只会触发一次！事件参数：无IMI.SERVERS.CREATE.AFTER创建服务器对象前置后作，只会触发一次！事件参数：无IMI.SERVER.WORKER_START服务器 worker 进程启动事件此事件常驻内存容器下，都会触发调用事件参数：\\Imi\\Server\\Contract\\IServer $server, int $workerIdIMI.SERVER.WORKER_STOP服务器 worker 进程停止事件事件参数：\\Imi\\Server\\Contract\\IServer $server, int $workerId此事件常驻内存容器下，都会触发调用IMI.PROCESS.BEGIN自定义进程开始事件事件参数：string $name, $processIMI.PROCESS.END自定义进程结束事件事件参数：string $name, $processIMI.SERVER.GROUP.JOIN服务器逻辑分组加入事件事件参数：\\Imi\\Server\\Contract\\IServer $server, string $groupName, $clientIdIMI.SERVER.GROUP.LEAVE服务器逻辑分组离开事件事件参数：\\Imi\\Server\\Contract\\IServer $server, string $groupName, $clientIdIMI.REQUEST_CONTENT.CREATE请求上下文创建事件事件参数：无IMI.REQUEST_CONTENT.DESTROY请求上下文销毁事件事件参数：无IMI.QUICK_START_BEFORE快速启动前置事件IMI.QUICK_START_AFTER快速启动后置事件"},{"id":22,"title":"错误转为异常捕获","pageTitle":"错误转为异常捕获","url":"core/handleError.html","content":"错误转为异常捕获目录imi 框架底层支持将错误转为异常，可以通过 try...catch 来捕获。在 config.php 中的 beans 配置[\n    &#039;ErrorLog&#039;  =&gt;  [\n        // &#039;level&#039; =&gt;  E_ALL, // 报告所有错误，这是默认值\n        // &#039;level&#039; =&gt;  E_ALL &amp; ~E_NOTICE, // 报告 E_NOTICE 之外的所有错误\n\n        // 错误捕获级别，捕获到的错误都会做处理，此为默认值\n        &#039;catchLevel&#039; =&gt; E_ALL | E_STRICT,\n        // 抛出异常的错误级别，除此之外全部记录日志，此为默认值\n        &#039;exceptionLevel&#039; =&gt; E_ERROR | E_PARSE | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_RECOVERABLE_ERROR | E_WARNING | E_CORE_WARNING | E_COMPILE_WARNING | E_USER_WARNING,\n    ],\n]错误级别参考：https://www.php.net/manual/zh/errorfunc.constants.php抛出的异常类为 \\ErrorException"},{"id":14,"title":"生命周期","pageTitle":"生命周期","url":"core/lifeCycle.html","content":"生命周期目录imi 是基于 Swoole 开发的框架，所以最好先了解 Swoole，以便了解各种名词概念。框架生命周期框架的生命周期大致分为以下几个阶段：加载配置 → 加载入口 → 加载或扫描运行时 → 初始化 → 运行"},{"id":25,"title":"长连接分布式解决方案","pageTitle":"长连接分布式解决方案","url":"core/long-connection-distributed.html","content":"长连接分布式解决方案目录imi v2.0 开始，新增了长连接分布式解决方案。该方案支持在 TCP、WebSocket 长连接服务中，轻松实现原生分布式推送功能。使用分布式解决方案时，你对连接的绑定、分组、推送等操作，底层都会自动实现逻辑，极大地降低了心智负担，可以说是一把梭！组件引入：composer require imiphp/imi-workerman-gatewayDemo: composer create-project imiphp/project-websocket:~2.0模式消息队列模式AMQPimi v2.0 开始，新增了支持 RabbitMQ 或其他支持 AMQP 协议的消息队列。使用发布订阅模式，每个消费者（Worker 进程）都是一个绑定到交换机的独立队列。需要注意的是，无法准确判断指定连接是否存在于其他服务，需要业务层面自行实现。此外，所有模式都不推荐使用持久化特性，因为没有实际意义。此模式仅支持 SwooleAMQP 一把梭模式会忽略 routingKey，将所有队列都接收所有指令，使用起来简单易用，但是性能相对较差。用法：项目配置文件：&#039;imi&#039; =&gt; [\n    &#039;beans&#039; =&gt; [\n        &#039;ServerUtil&#039; =&gt; &#039;AmqpServerUtil&#039;,\n    ],\n],\n&#039;beans&#039; =&gt; [\n    &#039;AmqpServerUtil&#039; =&gt; [\n        // &#039;amqpName&#039; =&gt; null, // amqp 连接名称\n        // 交换机配置，同 AMQP 组件的 @Exchange 注解参数\n        &#039;exchangeConfig&#039; =&gt; [\n            &#039;name&#039; =&gt; &#039;imi_server_util_test&#039;, // 交换机名\n            &#039;type&#039; =&gt; \\PhpAmqpLib\\Exchange\\AMQPExchangeType::FANOUT, // fanout 模式\n        ],\n        // 队列配置，同 AMQP 组件的 @Queue 注解参数\n        &#039;queueConfig&#039; =&gt; [\n            &#039;name&#039;    =&gt; &#039;imi_server_util_&#039;, // 每个进程中的队列名前缀，如果是多实例部署，请设为不同的\n            &#039;durable&#039; =&gt; false, // 非持久化\n        ],\n        // &#039;consumerClass&#039; =&gt; &#039;AmqpServerConsumer&#039;, // 消费者类，如有需要可以覆盖自己实现\n        // &#039;publisherClass&#039; =&gt; &#039;AmqpServerPublisher&#039;, // 发布者类，如有需要可以覆盖自己实现\n    ],\n],AMQP 路由模式在路由模式下，队列会根据指定的 routing key 接收指定的消息。使用路由模式需要配置对应的 GroupHandler 和 ConnectionContextHandler。当绑定、解绑 Group 或者更改 flag 时，对应的交换机、队列、routing key 也会被绑定和解绑。因此，在消费者接收消息时，只会接收与自己相关的消息。用法：项目配置文件：&#039;imi&#039; =&gt; [\n    &#039;beans&#039; =&gt; [\n        &#039;ServerUtil&#039; =&gt; &#039;AmqpServerUtil&#039;,\n    ],\n],\n&#039;beans&#039; =&gt; [\n    &#039;ServerGroup&#039; =&gt; [\n        &#039;groupHandler&#039; =&gt; &#039;GroupAmqp&#039;, // 配置对应的 GroupHandler\n    ],\n    &#039;ConnectionContextStore&#039;   =&gt; [\n        &#039;handlerClass&#039;  =&gt; &#039;ConnectionContextAmqp&#039;, // 配置对应的 ConnectionContextHandler\n    ],\n    &#039;AmqpServerUtil&#039; =&gt; [\n        // &#039;amqpName&#039; =&gt; null, // amqp 连接名称\n        // 交换机配置，同 AMQP 组件的 @Exchange 注解参数\n        &#039;exchangeConfig&#039; =&gt; [\n            &#039;name&#039; =&gt; &#039;imi_server_util_test&#039;, // 交换机名\n            &#039;type&#039; =&gt; \\PhpAmqpLib\\Exchange\\AMQPExchangeType::DIRECT, // direct 模式\n        ],\n        // 队列配置，同 AMQP 组件的 @Queue 注解参数\n        &#039;queueConfig&#039; =&gt; [\n            &#039;name&#039;    =&gt; &#039;imi_server_util_&#039;, // 每个进程中的队列名前缀，如果是多实例部署，请设为不同的\n            &#039;durable&#039; =&gt; false, // 非持久化\n        ],\n        // &#039;consumerClass&#039; =&gt; &#039;AmqpServerConsumer&#039;, // 消费者类，如有需要可以覆盖自己实现\n        // &#039;publisherClass&#039; =&gt; &#039;AmqpServerPublisher&#039;, // 发布者类，如有需要可以覆盖自己实现\n    ],\n],Redis该方案采用 Redis 发布订阅实现，每个运行实例都连接到 Redis 并订阅，当有消息发布时，Redis 会发送给所有订阅的服务器，服务器再进行消息的推送，从而实现了原生分布式推送功能。这个解决方案是基于 Redis 的发布订阅机制实现的，可以轻松地在多个服务器之间共享消息。因为 Redis 是一种高性能的内存数据库，所以它可以轻松处理大量消息，从而确保在分布式环境下推送消息的效率和可靠性。此模式仅支持 Swoole用法：项目配置文件：&#039;imi&#039; =&gt; [\n    &#039;beans&#039; =&gt; [\n        &#039;ServerUtil&#039; =&gt; &#039;RedisServerUtil&#039;,\n    ],\n],\n&#039;beans&#039; =&gt; [\n    &#039;RedisServerUtil&#039; =&gt; [\n        &#039;redisName&#039; =&gt; null, // 配置的 Redis 连接名称，为 null 则使用默认\n        &#039;channel&#039; =&gt; &#039;imi:RedisServerUtil:channel&#039;, // 发布订阅的频道名，不同服务请设为不同的，以防冲突\n    ],\n],网关模式Workerman GatewayWorkerman Gateway 是一个成熟的实现方案，可以实现分布式消息推送，同时也支持不断线更新业务代码。这使得它特别适合处理海量设备的物联网项目。在使用 Workerman Gateway 的过程中，需要注意编写的代码运行在 Worker 进程中，因此需要单独配置 Worker 类型的服务器配置。这与纯粹的 Swoole、Workerman 服务配置略有不同。如果您想了解更多关于 Workerman Gateway 的知识，可以参考其官方文档：http://doc4.workerman.net/此模式支持 Swoole、WorkermanSwoole 用法：项目配置文件：[\n    // 主服务器配置（子服务器配置同理）\n    &#039;mainServer&#039;    =&gt; defined(&#039;SWOOLE_VERSION&#039;) ? [\n        &#039;namespace&#039;    =&gt; &#039;服务命名空间&#039;,\n        &#039;type&#039;         =&gt; \\Imi\\WorkermanGateway\\Swoole\\Server\\Type::BUSINESS_WEBSOCKET, // WebSocket 业务服务器\n        // &#039;type&#039;         =&gt; \\Imi\\WorkermanGateway\\Swoole\\Server\\Type::BUSINESS_TCP, // TCP 业务服务器\n        &#039;mode&#039;         =&gt; \\SWOOLE_BASE,\n        //网关配置\n        &#039;workermanGateway&#039; =&gt; [\n            // worker 名称，在不同的 worker 实例中必须不同，一般推荐环境变量来修改\n            &#039;workerName&#039;           =&gt; &#039;websocketWorker&#039;,\n            &#039;registerAddress&#039;      =&gt; &#039;127.0.0.1:13004&#039;, // 注册中心地址\n            &#039;worker_coroutine_num&#039; =&gt; swoole_cpu_num(), // 每个 Worker 进程中的工作协程数量\n            // 待处理任务通道长度\n            &#039;channel&#039;              =&gt; [\n                &#039;size&#039; =&gt; 1024,\n            ],\n        ],\n    ] : [],\n    &#039;swoole&#039; =&gt; [\n        &#039;imi&#039; =&gt; [\n            &#039;beans&#039; =&gt; [\n                &#039;ServerUtil&#039; =&gt; Imi\\WorkermanGateway\\Swoole\\Server\\Util\\GatewayServerUtil::class,\n            ],\n        ],\n    ],\n]配置好后用 vendor/bin/imi-swoole swoole/start 启动服务即可。Workerman 用法：项目配置文件：[\n    // Workerman 服务器配置\n    &#039;workermanServer&#039; =&gt; [\n        // Worker 配置\n        // worker 名称 websocket，在不同的 worker 实例中必须不同，一般推荐环境变量来修改\n        &#039;websocket&#039; =&gt; [\n            &#039;namespace&#039;   =&gt; &#039;服务命名空间&#039;,\n            &#039;type&#039;        =&gt; Imi\\WorkermanGateway\\Workerman\\Server\\Type::BUSINESS_WEBSOCKET, // WebSocket 业务服务器\n            // &#039;type&#039;        =&gt; Imi\\WorkermanGateway\\Workerman\\Server\\Type::BUSINESS_TCP, // TCP 业务服务器\n            &#039;configs&#039;     =&gt; [\n                &#039;registerAddress&#039; =&gt; &#039;127.0.0.1:13004&#039;, // 注册中心地址\n                &#039;count&#039;           =&gt; 2,\n            ],\n        ],\n        // 其它监听端口的服务，可以不要\n        &#039;http&#039; =&gt; [\n            &#039;namespace&#039; =&gt; &#039;Imi\\WorkermanGateway\\Test\\AppServer\\ApiServer&#039;,\n            &#039;type&#039;      =&gt; Imi\\Workerman\\Server\\Type::HTTP,\n            &#039;host&#039;      =&gt; \\Imi\\env(&#039;SERVER_HOST&#039;, &#039;127.0.0.1&#039;),\n            &#039;port&#039;      =&gt; 13000,\n            &#039;configs&#039;   =&gt; [\n                &#039;registerAddress&#039; =&gt; &#039;127.0.0.1:13004&#039;,\n            ],\n        ],\n    ],\n    &#039;workerman&#039; =&gt; [\n        &#039;imi&#039; =&gt; [\n            &#039;beans&#039; =&gt; [\n                &#039;ServerUtil&#039; =&gt; Imi\\WorkermanGateway\\Workerman\\Server\\Util\\GatewayServerUtil::class,\n            ],\n        ],\n    ],\n]按上面的配置好后，如果你的网关和注册中心是单独运行的，那么已经可以跑了。如果你希望用 imi 来启动网关和注册中心，可以参考如下配置。在 @app.workermanServer 配置中加入：[\n    // 注册中心服务\n    &#039;register&#039; =&gt; [\n        &#039;namespace&#039;   =&gt; &#039;Imi\\WorkermanGateway\\Test\\AppServer\\Register&#039;,\n        &#039;type&#039;        =&gt; Imi\\WorkermanGateway\\Workerman\\Server\\Type::REGISTER,\n        &#039;host&#039;        =&gt; &#039;0.0.0.0&#039;,\n        &#039;port&#039;        =&gt; 13004,\n        &#039;configs&#039;     =&gt; [\n        ],\n    ],\n    // 网关服务\n    &#039;gateway&#039; =&gt; [\n        &#039;namespace&#039;   =&gt; &#039;Imi\\WorkermanGateway\\Test\\AppServer\\Gateway&#039;,\n        &#039;type&#039;        =&gt; Imi\\WorkermanGateway\\Workerman\\Server\\Type::GATEWAY,\n        &#039;socketName&#039;  =&gt; &#039;websocket://0.0.0.0:13002&#039;,\n        &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::TEXT, // 配置 WebSocket 纯文本通信协议\n        // &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::BINARY, // 配置 WebSocket 二进制通信协议\n        &#039;configs&#039;     =&gt; [\n            &#039;lanIp&#039;           =&gt; &#039;127.0.0.1&#039;,\n            &#039;startPort&#039;       =&gt; 12900,\n            &#039;registerAddress&#039; =&gt; &#039;127.0.0.1:13004&#039;,\n        ],\n    ],\n]配置好后用 vendor/bin/imi-workerman workerman/start 启动服务即可。"},{"id":21,"title":"中间件","pageTitle":"中间件","url":"core/middleware.html","content":"中间件目录中间件是一种常见的设计模式，用于在请求处理的前后执行某些操作，例如身份验证、数据验证、日志记录、性能分析等。中间件可以拦截请求，进行某些操作，再将请求传递给下一个中间件或控制器进行处理。在 imi 中，http、WebSocket、TCP、UDP 服务都使用了中间件，下面简单介绍一下中间件的执行顺序。中间件是按顺序开始执行的，但是后执行的中间件先执行完毕。先执行完毕的中间件，返回结果给前面的中间件。前面的中间件不一定会采用获得的结果，它有可能对这个结果做修改。举个简单的例子：A、B、C三个中间件，执行顺序为：先进A，再进B，再进C，C执行完，B执行完，A执行完"},{"id":17,"title":"Partial","pageTitle":"Partial","url":"core/partial.html","content":"Partial目录imi 的 Partial 特性是从 C# 中借鉴而来，可以将一个类的部分分成几个文件来书写，使用trait编写，并在注解中加上 @Partial，可以方便地注入。在实际开发中，Partial 特性有以下应用场景：多人协作开发，可以将不同的方法分配给不同的人开发，每个人只需要在自己的文件中编写，不用担心冲突问题。类的方法特别多，并且无法很好地拆分，此时可以将类分成几个文件来维护。有一些类是通过工具生成的，如果我们在类里编写了自己的代码，又需要重新生成一些内容，这时候会覆盖我们编写的代码。使用 Partial 在另一个文件中开发，不会被覆盖掉。使用方法需要被注入的类：&lt;?php\nnamespace Imi\\Test\\Component\\Partial\\Classes;\n\nuse Imi\\Bean\\Annotation\\Bean;\n\n/**\n * @Bean(&quot;PartialClassA&quot;)\n */\nclass PartialClassA\n{\n    public function test1()\n    {\n        return 1;\n    }\n\n}\n定义 Partial：&lt;?php\nnamespace Imi\\Test\\Component\\Partial\\Partial\n{\n    use Imi\\Bean\\Annotation\\Partial;\n\n    /**\n     * @Partial(Imi\\Test\\Component\\Partial\\Classes\\PartialClassA::class)\n     */\n    trait TPartialClassA1\n    {\n        public $test2Value = 2;\n\n        public function test2()\n        {\n            return $this-&gt;test2Value;\n        }\n\n    }\n\n}\n\n// 以下为方便 IDE 提示而写，非必须\nnamespace Imi\\Test\\Component\\Partial\\Classes\n{\n    // 必须用这个括起来，代码不会执行，但是 IDE 提示有效\n    if(false)\n    {\n        class PartialClassA\n        {\n            public $test2Value;\n\n            public function test2()\n            {\n\n            }\n        }\n    }\n\n}调用：/** @var \\Imi\\Test\\Component\\Partial\\Classes\\PartialClassA $test */\n$test = App::getBean(&#039;PartialClassA&#039;);\nvar_dump($test-&gt;test1());\n// 原类中没定义，但通过 partial 可以正常调用\n// 通过反射也可以获取到，是实实在在存在的方法和属性\nvar_dump($test-&gt;test2());\nvar_dump($test-&gt;test2Value);注意事项：命名空间 namespace 必须用 {} 括起来。下面一部分代码是为方便 IDE 提示而写，非必须。如果写，则必须在里面写 if(false){}，否则会出现重复定义类错误！被注入的类、Partial 定义类。使用被注入类对象时，必须通过容器，否则不生效。"},{"id":23,"title":"内部进程间通讯","pageTitle":"内部进程间通讯","url":"core/processCommunication.html","content":"内部进程间通讯目录为了方便进程内部通讯，进行数据交换。imi v1.2.0 版本新增了内部进程间通讯封装。我们只需要使用 Server::sendMessage() 发送，使用监听事件接收就行了。支持： Swoole、WorkermanSwooleWorker 进程使用 Swoole 提供的 sendMessage() 和 onPipeMessage 事件 实现。在 onPipeMessage 事件中，收到指定结构的数据，就会触发相应事件。类名：Imi\\Swoole\\Server\\Server用户进程imi 实现的 Unix Socket 双向通信，Swoole 自带的 pipe 无法实现双向通信。向进程发送消息：use Imi\\Swoole\\Process\\ProcessManager;\n$process = ProcessManager::getProcessWithManager(&#039;XXXProcess&#039;);\n\n// 返回 bool 类型\n$process-&gt;sendUnixSocketMessage(&#039;动作名&#039;);\n$process-&gt;sendUnixSocketMessage(&#039;动作名&#039;, 123); // 第二个参数可以带任意类型的变量，如果是对象必须可被序列化进程监听消息：监听事件：IMI.PROCESS.PIPE_MESSAGE事件参数类：\\Imi\\Swoole\\Process\\Event\\Param\\PipeMessageEventParam&lt;?php\nuse Imi\\Bean\\Annotation\\Listener;\nuse Imi\\Event\\EventParam;\nuse Imi\\Event\\IEventListener;\nuse Imi\\Server\\ServerManager;\nuse Imi\\Swoole\\Process\\Event\\Param\\PipeMessageEventParam;\n\n/**\n * @Listener(eventName=&quot;IMI.PROCESS.PIPE_MESSAGE&quot;)\n */\nclass MyListener implements IEventListener\n{\n    /**\n     * @param PipeMessageEventParam $e\n     */\n    public function handle(EventParam $e): void\n    {\n        var_dump($e-&gt;action); // 获取动作名\n        var_dump($e-&gt;data); // 获取数据\n\n        // 返回发送方数据（非必须）\n        $e-&gt;process-&gt;sendUnixSocketMessageByConnection($e-&gt;connection, &#039;动作名&#039;);\n        $e-&gt;process-&gt;sendUnixSocketMessageByConnection($e-&gt;connection, &#039;动作名&#039;, 123); // 第二个参数可以带任意类型的变量，如果是对象必须可被序列化\n    }\n}Workerman使用 Channel分布式通讯组件 实现。类名：Imi\\Workerman\\Server\\Server介绍数据结构[\n    &#039;action&#039;    =&gt;  &#039;动作名&#039;, // 此字段固定\n    // 其它参数任意增加即可\n]事件名称IMI.PIPE_MESSAGE.动作名代码示例发送use Imi\\Swoole\\Server\\Server;\n\n// 发送给所有 Worker 进程\nServer::sendMessage(&#039;test&#039;, [\n    &#039;time&#039;  =&gt;  time(),\n]);\n\n// 发送给 WorkerId 为 1 的进程\nServer::sendMessage(&#039;test&#039;, [\n    &#039;time&#039;  =&gt;  time(),\n], 1);监听事件名称为：IMI.PIPE_MESSAGE.test&lt;?php\nnamespace App\\Listener;\n\nuse Imi\\Event\\EventParam;\nuse Imi\\Event\\IEventListener;\nuse Imi\\Bean\\Annotation\\Listener;\n\n/**\n * @Listener(&quot;IMI.PIPE_MESSAGE.test&quot;)\n */\nclass TestMessage implements IEventListener\n{\n    /**\n     * 事件处理方法\n     * @param EventParam $e\n     * @return void\n     */\n    public function handle(EventParam $e): void\n    {\n        $data = $e-&gt;getData()[&#039;data&#039;];\n        var_dump($data[&#039;time&#039;]); // 接收到了上面发送来的 time\n    }\n\n}发送并获取返回数据思路：一般来讲，发送消息不像 http 请求，一定会有响应结果。但有时候，我们需要获取返回数据。办法很简单，比如：发送数据动作名为 testRequest，再定义一个 testResponse 动作监听用于接收数据即可。再使用 Channel 挂起协程等待响应结果，完美！暂时只有 Swoole 支持发送请求并等待响应：use Imi\\Swoole\\Server\\Server;\nuse Imi\\Swoole\\Util\\Co\\ChannelContainer;\n\n// 生成一个随机ID\n$id = uniqid(&#039;&#039;, true);\n\ntry {\n    $channel = ChannelContainer::getChannel($id);\n    // 发送给 WorkerId 为 1 的进程\n    Server::sendMessage(&#039;testRequest&#039;, [\n        &#039;time&#039;  =&gt;  time(),\n    ], 1);\n    // 通过 Channel 获取结果，超时时间可以自行设置，这里是 30 秒\n    $result = $channel-&gt;pop(30);\n    if(false === $result)\n    {\n        throw new \\RuntimeException(&#039;Receive error&#039;);\n    }\n    var_dump($result[&#039;datetime&#039;]); // 返回结果\n} finally {\n    ChannelContainer::removeChannel($id);\n}监听请求：事件名称为：IMI.PIPE_MESSAGE.testRequest&lt;?php\nnamespace App\\Listener;\n\nuse Imi\\Event\\EventParam;\nuse Imi\\Event\\IEventListener;\nuse Imi\\Bean\\Annotation\\Listener;\nuse Imi\\Swoole\\Server\\Server;\n\n/**\n * @Listener(&quot;IMI.PIPE_MESSAGE.testRequest&quot;)\n */\nclass TestRequestMessage implements IEventListener\n{\n    /**\n     * 事件处理方法\n     * @param EventParam $e\n     * @return void\n     */\n    public function handle(EventParam $e): void\n    {\n        $data = $e-&gt;getData()[&#039;data&#039;];\n        $datetime = date(&#039;Y-m-d H:i:s&#039;, $data[&#039;time&#039;]);\n\n        // 发送响应结果\n        Server::sendMessage(&#039;testResponse&#039;, [\n            &#039;messageId&#039; =&gt;  $data[&#039;messageId&#039;];\n            &#039;datetime&#039;  =&gt;  $datetime,\n        ], $e-&gt;getData()[&#039;workerId&#039;]);\n    }\n\n}监听响应：暂时只有 Swoole 支持事件名称为：IMI.PIPE_MESSAGE.testResponse&lt;?php\nnamespace App\\Listener;\n\nuse Imi\\Event\\EventParam;\nuse Imi\\Event\\IEventListener;\nuse Imi\\Bean\\Annotation\\Listener;\nuse Imi\\Swoole\\Server\\Server;\nuse Imi\\Swoole\\Util\\Co\\ChannelContainer;\n\n/**\n * @Listener(&quot;IMI.PIPE_MESSAGE.testResponse&quot;)\n */\nclass TestResponseMessage implements IEventListener\n{\n    /**\n     * 事件处理方法\n     * @param EventParam $e\n     * @return void\n     */\n    public function handle(EventParam $e): void\n    {\n        $data = $e-&gt;getData()[&#039;data&#039;];\n        if(ChannelContainer::hasChannel($data[&#039;messageId&#039;]))\n        {\n            // 推结果进 Channel\n            ChannelContainer::push($data[&#039;messageId&#039;], $data);\n        }\n    }\n\n}"},{"id":42,"title":"进程名称管理","pageTitle":"进程名称管理","url":"core/processNameManager.html","content":"进程名称管理目录imi 为启动出来的进程统一管理了进程名，你可以在 @app.process 中自定义，其默认设置为：&#039;process&#039;   =&gt;  [\n    &#039;master&#039;        =&gt;  &#039;imi:master:{namespace}&#039;,\n    &#039;manager&#039;       =&gt;  &#039;imi:manager:{namespace}&#039;,\n    &#039;worker&#039;        =&gt;  &#039;imi:worker-{workerId}:{namespace}&#039;,\n    &#039;taskWorker&#039;    =&gt;  &#039;imi:taskWorker-{workerId}:{namespace}&#039;,\n    &#039;process&#039;       =&gt;  &#039;imi:process-{processName}:{namespace}&#039;,\n    &#039;processPool&#039;   =&gt;  &#039;imi:process-pool-{processPoolName}-{workerId}:{namespace}&#039;,\n    &#039;tool&#039;          =&gt;  &#039;imi:{toolName}/{toolOperation}:{namespace}&#039;,\n]目前仅支持 Swoole"},{"id":28,"title":"单文件运行 imi（快速启动）","pageTitle":"单文件运行 imi（快速启动）","url":"core/quickStart.html","content":"单文件运行 imi（快速启动）目录单文件运行 imi 是指在不需要搭建 imi 项目结构的情况下，通过一个 PHP 文件即可启动 imi 服务器，比如可以直接在命令行中运行该文件。imi v2.1.7 开始支持了单文件运行 imi。使用场景需要在 imi 环境中，单独执行一段代码。使用方法在项目下创建 test.php：&lt;?php\n\ndeclare(strict_types=1);\n\nuse Imi\\App;\nuse Imi\\Cli\\CliApp;\n\n// 加载 autoload.php 必不可少\nrequire __DIR__ . &#039;/vendor/autoload.php&#039;;\n\n// 第一个参数传入项目根目录\n// 第二个参数是各种模式的 App 类。CliApp 也可以换成 SwooleApp 等类。\nApp::runApp(__DIR__, CliApp::class, function () {\n    // 你自己的代码写在这\n    echo &#039;Test quick start&#039;, \\PHP_EOL;\n});Swoole 环境使用：\nuse Imi\\Swoole\\SwooleApp;\nuse function Swoole\\Coroutine\\run;\n\n// 加载 autoload.php 必不可少\nrequire __DIR__ . &#039;/vendor/autoload.php&#039;;\n\nrun(function () {\n    App::runApp(__DIR__, SwooleApp::class, function () {\n        echo &#039;Test swoole quick start&#039;, \\PHP_EOL;\n    });\n});直接执行：php test.php正常输出：Test quick start"},{"id":16,"title":"请求上下文","pageTitle":"请求上下文","url":"core/requestContext.html","content":"请求上下文目录请求上下文（Request Context）是一个保存了当前请求相关信息的容器，它可以在一个请求的生命周期内被使用，可以用来获取当前请求的相关信息，如请求的 URI、请求参数、响应信息等。在 imi 中，请求上下文的实现是基于 Swoole 协程上下文（Coroutine Context）的，因此在 Swoole 环境下，请求上下文实际上就是协程上下文。而在非 Swoole 环境下，如 PHP-FPM，请求上下文则是一个全局上下文对象。无论在哪个环境中，使用请求上下文都需要通过 Imi\\RequestContext 类来获取。上下文中容器操作$object = \\Imi\\RequestContext::getBean(&#039;XXX&#039;);\n$object = \\Imi\\RequestContext::getServerBean(&#039;XXX&#039;);\n$object = \\Imi\\RequestContext::newInstance(&#039;XXX&#039;);\n\n$container = \\Imi\\RequestContext::getContainer();\n$object = $container-&gt;get(&#039;XXX&#039;);上下文中的数据存储获取上下文对象// @var ArrayObject $cxt\n$cxt = \\Imi\\RequestContext::getContext();在上下文中存取值\\Imi\\RequestContext::get(&#039;myKey&#039;, &#039;default&#039;);\n\\Imi\\RequestContext::set(&#039;myKey&#039;, &#039;123456&#039;);\n\\Imi\\RequestContext::unset(&#039;myKey&#039;);批量在上下文中设置值\\Imi\\RequestContext::muiltiSet([\n    &#039;myKey1&#039; =&gt; &#039;123456&#039;,\n    &#039;myKey2&#039; =&gt; &#039;456789&#039;,\n    &#039;myKey3&#039; =&gt; &#039;123456&#039;,\n]);在闭包中获取上下文操作并返回值// 返回`123`\n$result = \\Imi\\RequestContext::use(function (ArrayObject $cxt) {\n    $cxt[&#039;myKey2&#039;] = &#039;789&#039;;\n    unset($cxt[&#039;myKey3&#039;]);\n\n    return &#039;123&#039;;\n});执行一个闭包并再上下文中记住其返回值// 返回值`3`并写入上下文中存储\n$result = \\Imi\\RequestContext::remember(&#039;myKey3&#039;, function () {\n    return 1 + 2;\n});"},{"id":24,"title":"Server 对象","pageTitle":"Server 对象","url":"core/server.html","content":"Server 对象目录每个服务器、每个协议端口，在 imi 中都有一个 Server 对象。如何拿到 Server 对象在控制器中:$this-&gt;server在任意地方:\\Imi\\RequestContext::getServer();公共方法/**\n * 获取服务器名称.\n */\npublic function getName(): string;\n\n/**\n * 获取协议名称.\n */\npublic function getProtocol(): string;\n\n/**\n * 获取配置信息.\n */\npublic function getConfig(): array;\n\n/**\n * 获取容器对象\n */\npublic function getContainer(): Container;\n\n/**\n * 获取Bean对象\n *\n * @param mixed $params\n */\npublic function getBean(string $name, ...$params): object;\n\n/**\n * 是否为长连接服务\n */\npublic function isLongConnection(): bool;\n\n/**\n * 是否支持 SSL.\n */\npublic function isSSL(): bool;\n\n/**\n * 开启服务\n */\npublic function start(): void;\n\n/**\n * 终止服务\n */\npublic function shutdown(): void;\n\n/**\n * 重载服务\n */\npublic function reload(): void;\n\n/**\n * 调用服务器方法.\n *\n * @param mixed ...$args\n *\n * @return mixed\n */\npublic function callServerMethod(string $methodName, ...$args);Swoole Server 独有方法/**\n * 获取 swoole 服务器对象\n */\npublic function getSwooleServer(): Server;\n\n/**\n * 获取 swoole 监听端口.\n */\npublic function getSwoolePort(): Port;\n\n/**\n * 是否为子服务器.\n */\npublic function isSubServer(): bool;\n\n/**\n * 组是否存在.\n */\npublic function hasGroup(string $groupName): bool;\n\n/**\n * 创建组，返回组对象\n */\npublic function createGroup(string $groupName, int $maxClients = -1): Group;\n\n/**\n * 获取组对象，不存在返回null.\n */\npublic function getGroup(string $groupName): ?Group;\n\n/**\n * 加入组，组不存在则自动创建.\n *\n * @param int|string $clientId\n */\npublic function joinGroup(string $groupName, $clientId): void;\n\n/**\n * 离开组，组不存在则自动创建.\n *\n * @param int|string $clientId\n */\npublic function leaveGroup(string $groupName, $clientId): void;\n\n/**\n * 调用组方法.\n *\n * @param mixed ...$args\n *\n * @return mixed\n */\npublic function groupCall(string $groupName, string $methodName, ...$args);\n\n/**\n * 获取所有组列表.\n *\n * @return \\Imi\\Server\\Group\\Group[]\n */\npublic function getGroups(): array;Workerman Server 独有方法/**\n * 获取 Workerman Worker 对象\n */\npublic function getWorker(): Worker;\n\n/**\n * 组是否存在.\n */\npublic function hasGroup(string $groupName): bool;\n\n/**\n * 创建组，返回组对象\n */\npublic function createGroup(string $groupName, int $maxClients = -1): Group;\n\n/**\n * 获取组对象，不存在返回null.\n */\npublic function getGroup(string $groupName): ?Group;\n\n/**\n * 加入组，组不存在则自动创建.\n *\n * @param int|string $clientId\n */\npublic function joinGroup(string $groupName, $clientId): void;\n\n/**\n * 离开组，组不存在则自动创建.\n *\n * @param int|string $clientId\n */\npublic function leaveGroup(string $groupName, $clientId): void;\n\n/**\n * 调用组方法.\n *\n * @param mixed ...$args\n *\n * @return mixed\n */\npublic function groupCall(string $groupName, string $methodName, ...$args);\n\n/**\n * 获取所有组列表.\n *\n * @return \\Imi\\Server\\Group\\Group[]\n */\npublic function getGroups(): array;PHP-FPM Server 独有方法无"},{"id":39,"title":"Swoole 子服务器（单项目多端口多协议）","pageTitle":"Swoole 子服务器（单项目多端口多协议）","url":"core/subServer.html","content":"Swoole 子服务器（单项目多端口多协议）目录imi 原生支持一个项目，单次启动，监听多个端口多个协议。比如你要做一个聊天系统，http 用于注册、登录、上传文件等等，WebSocket 用于即时通讯。http 和 WebSocket 同时做在一个项目中，代码之间没有隔阂，可以方便地互相调用和复用。这种方式还能大大减少服务器的启动数量，节约服务器资源。子服务器配置项目配置文件：[\n    // 子服务器（端口监听）配置\n    &#039;subServers&#039;    =&gt;    [\n        // 子服务器别名\n        &#039;alias1&#039;    =&gt;    [\n            // 指定服务器命名空间\n            &#039;namespace&#039;    =&gt;    &#039;ImiDemo\\HttpDemo\\MainServer&#039;,\n            // 服务器类型(http/WebSocket/TcpServer/UdpServer)\n            &#039;type&#039;        =&gt;    \\Imi\\Swoole\\Server\\Type::HTTP,\n            // 监听的IP地址，可选\n            &#039;host&#039;        =&gt;    &#039;0.0.0.0&#039;,\n            // 监听的端口\n            &#039;port&#039;        =&gt;    8080,\n            // 参考 swoole sockType，可选\n            &#039;sockType&#039;    =&gt;    SWOOLE_SOCK_TCP,\n            // 同步连接，当连接事件执行完后，才执行 receive 事件。仅 TCP、WebSocket 有效\n            &#039;syncConnect&#039; =&gt; true,\n            &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::TEXT, // 配置 WebSocket 纯文本通信协议\n            // &#039;nonControlFrameType&#039; =&gt; \\Imi\\Server\\WebSocket\\Enum\\NonControlFrameType::BINARY, // 配置 WebSocket 二进制通信协议\n            // 服务器配置，参数用法同\\Swoole\\Server-&gt;set($configs)\n            &#039;configs&#039;    =&gt;    [\n            ],\n            // 容器绑定\n            &#039;beans&#039; =&gt; [\n                &#039;aaa&#039; =&gt; XXX::class,\n            ],\n        ],\n    ],\n]子服务器命名空间配置在子服务器命名空间所在目录，需要创建一个 Main.php 入口文件。&lt;?php\nnamespace ImiApp\\ApiServer;\n\nuse Imi\\Main\\BaseMain;\n\nclass Main extends BaseMain\n{\n    public function __init(): void\n    {\n        // 可以做一些初始化操作\n    }\n\n}子服务器配置文件文件：config/config.php&lt;?php\nreturn [\n    // 加载子配置文件，可以使用 \\Imi\\Config::get(&#039;@server.子服务名.别名1.xxx&#039;) 获取\n    &#039;configs&#039;    =&gt;    [\n        &quot;别名1&quot;    =&gt;    &#039;配置文件路径1&#039;,\n        &quot;别名2&quot;    =&gt;    &#039;配置文件路径2&#039;,\n        ……\n    ],\n\n    // 如果配置了 configs.别名1，这里的值会被上面的文件覆盖\n    &#039;别名1&#039; =&gt; [],\n\n    // bean扫描目录，指定命名空间，建议省略\n    // &#039;beanScan&#039;    =&gt;    [\n    //     &#039;ImiDemo\\WebSocketDemo\\Listener&#039;,\n    // ],\n];"},{"id":257,"title":"控制器生成","pageTitle":"控制器生成","url":"dev/generate/controller.html","content":"控制器生成目录生成一个 Http Controller必选参数：name 生成的 Controller 类名namespace 生成的 Controller 所在命名空间可选参数：--prefix 路由前缀，不传则为类名--render 渲染方式，默认为json，可选：html/json/xml--rest 是否生成 RESTful 风格，默认 false--override 是否覆盖已存在的文件，请慎重！(true/false)示例：vendor/bin/imi-xxx generate/httpController 控制器名 &quot;命名空间&quot;\n\nvendor/bin/imi-xxx generate/httpController 控制器名 &quot;命名空间&quot; --rest(xxx 根据运行模式不同而不同)"},{"id":255,"title":"模型生成","pageTitle":"模型生成","url":"dev/generate/model.html","content":"模型生成目录生成数据库中所有表的模型文件，支持 MySQL、PgSQL 虚拟列。生成 MySQL 表模型必选参数：namespace 生成的Model所在命名空间可选参数：--database 数据库名，不传则取连接池默认配置的库名--baseClass 生成时所继承的基类（自行实现务必继承框架的模型类），默认Imi\\Model\\Model，可选--poolName 连接池名称，不传则取默认连接池--prefix 传值则去除该表前缀--include 要包含的表名，以半角逗号分隔--exclude 要排除的表名，以半角逗号分隔--override 是否覆盖已存在的文件，请慎重！true-全覆盖;false-不覆盖;base-覆盖基类;model-覆盖模型类;默认缺省状态为false--config 配置文件。true-项目配置；false-忽略配置；php配置文件名-使用该配置文件。默认为true--basePath 指定命名空间对应的基准路径，可选--entity 序列化时是否使用驼峰命名(true or false),默认true,可选--sqlSingleLine 生成的SQL为单行,默认false,可选--lengthCheck 是否检查字符串字段长度,可选--ddlEncode DDL 编码函数,可选--ddlDecode DDL 解码函数,可选--bean 模型对象是否作为 bean 类使用,默认 true,可选--incrUpdate 模型是否启用增量更新，默认false，可选示例：vendor/bin/imi-xxx generate/model &quot;命名空间&quot;(xxx 根据运行模式不同而不同)相关配置-MySQL默认情况下，生成模型工具是无需任何配置的。一般在大型项目中，我们会对项目进行模块划分。每个模块有自己的模型、控制器等等。这时候，模型文件必然不能生成在同一个命名空间下。imi 支持两种自定义模型生成目标的配置方式。按命名空间指定-MySQL项目配置文件：[\n    &#039;tools&#039;  =&gt;  [\n        &#039;generate/model&#039;    =&gt;  [\n            &#039;namespace&#039; =&gt;  [\n                &#039;命名空间1&#039; =&gt;  [\n                    // 在该命名空间下，允许生成的表\n                    &#039;tables&#039;    =&gt;  [\n                        &#039;表1&#039;, // 用法1\n                        // 用法2，支持指定参数\n                        &#039;表2&#039; =&gt; [\n                            // 下面所有字段都是非必须的，需要改哪个写哪个\n                            &#039;withRecords&#039; =&gt; false, // 备份表记录\n                            &#039;fields&#039; =&gt; [\n                                &#039;字段名&#039; =&gt; [\n                                    &#039;typeDefinition&#039; =&gt; false,\n                                ],\n                            ],\n                            &#039;bean&#039; =&gt; true, // 模型对象是否作为 bean 类使用\n                            &#039;incrUpdate&#039; =&gt; false, // 模型是否启用增量更新\n                        ],\n                    ],\n                    // 备份哪些表的记录，不建议所有表都备份数据，一般用于字典表、默认数据等情况，即将废弃，推荐在 tables 中配置\n                    &#039;withRecords&#039;   =&gt;  [\n                        &#039;表1&#039;,\n                    ],\n                ],\n                &#039;命名空间2&#039; =&gt;  [\n                    &#039;tables&#039;    =&gt;  [\n                        &#039;表3&#039;,\n                        &#039;表4&#039;,\n                    ],\n                ],\n            ]\n        ],\n    ],\n]按表指定-MySQL项目配置文件：[\n    &#039;tools&#039;  =&gt;  [\n        &#039;generate/model&#039;    =&gt;  [\n            &#039;relation&#039;  =&gt;  [\n                &#039;表名1&#039;   =&gt;  [\n                    &#039;namespace&#039; =&gt;  &#039;生成到的命名空间&#039;,\n                    // 是否备份记录，不建议所有表都备份数据，一般用于字典表、默认数据等情况\n                    &#039;withRecords&#039; =&gt; true,\n                    &#039;fields&#039; =&gt; [\n                        &#039;字段名&#039; =&gt; [\n                            &#039;typeDefinition&#039; =&gt; false,\n                        ],\n                    ],\n                ],\n                &#039;表名2&#039;   =&gt;  [\n                    &#039;namespace&#039; =&gt;  &#039;生成到的命名空间&#039;,\n                ],\n            ],\n        ],\n    ],\n]即将废弃，推荐使用 按命名空间指定生成 PostgreSQL 表模型必选参数：namespace 生成的Model所在命名空间可选参数：--database 数据库名，不传则取连接池默认配置的库名--baseClass 生成时所继承的基类（自行实现务必继承框架的模型类），默认Imi\\Model\\Model，可选--poolName 连接池名称，不传则取默认连接池--prefix 传值则去除该表前缀--include 要包含的表名，以半角逗号分隔--exclude 要排除的表名，以半角逗号分隔--override 是否覆盖已存在的文件，请慎重！true-全覆盖;false-不覆盖;base-覆盖基类;model-覆盖模型类;默认缺省状态为false--config 配置文件。true-项目配置；false-忽略配置；php配置文件名-使用该配置文件。默认为true--basePath 指定命名空间对应的基准路径，可选--entity 序列化时是否使用驼峰命名(true or false),默认true,可选--lengthCheck 是否检查字符串字段长度,可选示例：vendor/bin/imi-cli generate/pgModel &quot;命名空间&quot;相关配置-PostgreSQL默认情况下，生成模型工具是无需任何配置的。一般在大型项目中，我们会对项目进行模块划分。每个模块有自己的模型、控制器等等。这时候，模型文件必然不能生成在同一个命名空间下。imi 支持两种自定义模型生成目标的配置方式。按表指定-PostgreSQL项目配置文件：[\n    &#039;tools&#039;  =&gt;  [\n        &#039;generate/model&#039;    =&gt;  [\n            &#039;relation&#039;  =&gt;  [\n                &#039;表名1&#039;   =&gt;  [\n                    &#039;namespace&#039; =&gt;  &#039;生成到的命名空间&#039;,\n                    // 是否备份记录，不建议所有表都备份数据，一般用于字典表、默认数据等情况\n                    &#039;withRecords&#039; =&gt; true,\n                    &#039;fields&#039; =&gt; [\n                        &#039;字段名&#039; =&gt; [\n                            &#039;typeDefinition&#039; =&gt; false,\n                        ],\n                    ],\n                ],\n                &#039;表名2&#039;   =&gt;  [\n                    &#039;namespace&#039; =&gt;  &#039;生成到的命名空间&#039;,\n                ],\n            ],\n        ],\n    ],\n]按命名空间指定-PostgreSQL项目配置文件：[\n    &#039;tools&#039;  =&gt;  [\n        &#039;generate/model&#039;    =&gt;  [\n            &#039;namespace&#039; =&gt;  [\n                &#039;命名空间1&#039; =&gt;  [\n                    // 在该命名空间下，允许生成的表\n                    &#039;tables&#039;    =&gt;  [\n                        &#039;表1&#039;,\n                        &#039;表2&#039;,\n                    ],\n                    // 备份哪些表的记录，不建议所有表都备份数据，一般用于字典表、默认数据等情况\n                    &#039;withRecords&#039;   =&gt;  [\n                        &#039;表1&#039;,\n                    ],\n                ],\n                &#039;命名空间2&#039; =&gt;  [\n                    &#039;tables&#039;    =&gt;  [\n                        &#039;表3&#039;,\n                        &#039;表4&#039;,\n                    ],\n                ],\n            ]\n        ],\n    ],\n]"},{"id":201,"title":"Swagger API 文档生成","pageTitle":"Swagger API 文档生成","url":"dev/generate/swagger.html","content":"Swagger API 文档生成目录支持在项目中使用 Swagger 注解语法，运行命令，生成 Swagger 文件。Swagger 是最流行的 API 开发工具，它遵循 OpenAPI Specification（OpenAPI 规范，也简称 OAS）。Swagger 可以贯穿于整个 API 生态，如 API 的设计、编写 API 文档、测试和部署。Swagger 是一种通用的，和编程语言无关的 API 描述规范。imi-apidoc 基于 zircote/swagger-php 开发，100% 支持写法。Github: https://github.com/imiphp/imi-apidocComposer本项目可以使用composer安装，遵循psr-4自动加载规则，在你的 composer.json 中加入下面的内容:{\n    &quot;require&quot;: {\n        &quot;imiphp/imi-apidoc&quot;: &quot;~2.1.0&quot;\n    }\n}然后执行 composer update 安装。使用说明可以参考 example、tests 目录示例。项目配置文件：[\n    &#039;components&#039;    =&gt;  [\n        &#039;ApiDoc&#039;  =&gt;  &#039;Imi\\ApiDoc&#039;,\n    ],\n]Swagger 书写文档说明：https://zircote.github.io/swagger-php/Demo:&lt;?php\nnamespace ImiApp\\ApiServer\\Controller;\n\nuse Imi\\Server\\Http\\Route\\Annotation\\Route;\nuse Imi\\Server\\Http\\Route\\Annotation\\Action;\nuse Imi\\Controller\\SingletonHttpController;\nuse Imi\\Server\\Http\\Route\\Annotation\\Controller;\n\n/**\n * @OA\\Info(title=&quot;My First API&quot;, version=&quot;0.1&quot;)\n * @Controller(&quot;/&quot;)\n */\nclass IndexController extends SingletonHttpController\n{\n    /**\n     * @Action\n     * @Route(&quot;/&quot;)\n     * \n     *\n     * @return void\n     */\n    public function index()\n    {\n\n    }\n\n    /**\n     * @Action\n     * @Route(url=&quot;login&quot;, method=&quot;POST&quot;)\n     *\n     * @param string $username 用户名\n     * @param integer $password 密码\n     * \n     * @return void\n     */\n    public function login(string $username, int $password)\n    {\n\n    }\n\n    /**\n     * @Action\n     * @Route(&quot;register&quot;)\n     * @OA\\Get(\n     *     path=&quot;/register&quot;,\n     *     @OA\\Response(response=&quot;200&quot;, description=&quot;An example resource&quot;)\n     * )\n     *\n     * @param string $username 用户名\n     * @param integer $password 密码\n     * @param string $birthday 生日\n     * \n     * @return void\n     */\n    public function register(string $username, int $password\n    , string $birthday)\n    {\n\n    }\n\n    /**\n     * @Action\n     *\n     * @param int $id\n     * @return void\n     */\n    public function get(int $id)\n    {\n\n    }\n\n}imi-apidoc 会根据 @Route 注解、@param 注释，自动补足相关信息。让你不必为每个接口都书写 Swagger 注解，提升开发效率。当然，如果希望更加个性化的信息设置，还是要自己去书写的！生成命令：Yaml 格式: vendor/bin/imi-swoole doc/api api.ymlJson 格式: vendor/bin/imi-swoole doc/api api.json指定扫描的命名空间：vendor/bin/imi-swoole doc/api api.json --namespace &quot;ImiApp\\Controller1,ImiApp\\Controller2&quot;效果："},{"id":256,"title":"从模型生成表","pageTitle":"从模型生成表","url":"dev/generate/table.html","content":"从模型生成表目录根据模型中 DDL 注解定义，生成表注意，本工具是删除重建表，会丢失数据，生产环境慎重使用！imi v1.2.3 版本支持PostgreSQL 暂不支持从模型生成表可选参数：--namespace 模型所在命名空间，支持半角逗号分隔传多个，默认不传则为全部--database 数据库名，不传则取连接池默认配置的库名--poolName 连接池名称，不传则取默认连接池--include 要包含的表名，以半角逗号分隔--exclude 要排除的表名，以半角逗号分隔--override 是否覆盖已存在的表，请慎重！true-全覆盖;false-不覆盖;默认缺省状态为false示例：vendor/bin/imi-xxx generate/table(xxx 根据运行模式不同而不同)事件监听IMI.GENERATE_MODEL.BEFORE生成表工具的前置操作IMI.GENERATE_MODEL.AFTER生成表工具的后置操作"},{"id":254,"title":"","pageTitle":"","url":"dev/generate.html","content":""},{"id":253,"title":"介绍","pageTitle":"介绍","url":"dev/intro.html","content":"介绍目录框架自带文件：vendor/bin/imi-xxx (xxx 根据运行模式不同而不同)用框架自带执行命令行，需要手动传入--app-namesapce &quot;项目命名空间&quot;参数"},{"id":48,"title":"进程工具","pageTitle":"进程工具","url":"dev/process-swoole.html","content":"进程工具目录启动进程开启一个进程，可以任意添加参数必选参数：name 进程名称，通过@Process注解定义可选参数：--redirectStdinStdout 重定向子进程的标准输入和输出。启用此选项后，在子进程内输出内容将不是打印屏幕，而是写入到主进程管道。读取键盘输入将变为从管道中读取数据。默认为阻塞读取。--pipeType 管道类型，启用$redirectStdinStdout后，此选项将忽略用户参数，强制为1。如果子进程内没有进程间通信，可以设置为 0示例：vendor/bin/imi-swoole process/start 进程名称\n\n# 跟上进程需要获取的参数\nvendor/bin/imi-swoole process/start 进程名称 --a 1 --b 2运行进程运行一个进程与启动进程不同，直接在启动的进程中执行进程逻辑，一般推荐使用本方法必选参数：name 进程名称，通过@Process注解定义示例：vendor/bin/imi-swoole process/run 进程名称启动进程池基于Swoole\\Process\\Pool实现，可以设定进程数量。需要在进程中人为写上循环，否则进程一旦结束，会立即拉起一个新进程。必选参数：name 进程池名称，通过@ProcessPool注解定义可选参数：--worker 进程数量，不传则根据注解配置设定（注解不设置则为1）--ipcType 进程间通信的模式，默认为0表示不使用任何进程间通信特性，不传则根据注解配置设定--msgQueueKey 消息队列键，不传则根据注解配置设定"},{"id":54,"title":"进程工具","pageTitle":"进程工具","url":"dev/process-workerman.html","content":"进程工具目录启动进程开启一个进程，可以任意添加参数必选参数：name 进程名称，通过@Process注解定义示例：vendor/bin/imi-cli process/start 进程名称\n\n# 跟上进程需要获取的参数\nvendor/bin/imi-cli process/start 进程名称 --a 1 --b 2"},{"id":258,"title":"自己动手开发命令行工具","pageTitle":"自己动手开发命令行工具","url":"dev/tool.html","content":"自己动手开发命令行工具目录imi 的命令行工具使用注解来定义注解@CommandImi\\Cli\\Annotation\\Command，写在类上，用于定义工具名称属性名称说明name工具名称description操作描述separator定义命令名称分割符，默认：/@CommandActionImi\\Cli\\Annotation\\CommandAction，写在方法上，用于定义工具动作名称属性名称说明name工具动作名称co是否自动开启协程，默认为true@ArgumentImi\\Cli\\Annotation\\Argument，写在方法上，可以有多个，用于定义工具参数属性名称说明name参数名称type参数类型，支持：string/int/float/boolean/array/boolean_negatable，也可以使用\\Imi\\Cli\\ArgType::XXXdefault默认值required是否是必选参数，默认falsecomments注释to将参数值绑定到指定名称的参数@OptionImi\\Cli\\Annotation\\Option，写在方法上，可以有多个，用于可选项参数属性名称说明name参数名称shortcut参数短名称type参数类型，支持：string/int/float/boolean/array/boolean_negatable，也可以使用\\Imi\\Cli\\ArgType::XXXdefault默认值required是否是必选参数，默认falsecomments注释to将参数值绑定到指定名称的参数工具定义namespace ImiApp\\Tool;\n\nuse Imi\\Cli\\Annotation\\Command;\nuse Imi\\Cli\\Annotation\\CommandAction;\nuse Imi\\Cli\\Annotation\\Option;\nuse Imi\\Cli\\Annotation\\Argument;\nuse Imi\\Cli\\Contract\\BaseCommand;\n\n/**\n * @Command(&quot;test&quot;)\n */\nclass Test extends BaseCommand\n{\n    /**\n     * @CommandAction(name=&quot;hello&quot;, description=&quot;Hello world&quot;)\n     * @Argument(name=&quot;content&quot;, type=\\Imi\\Cli\\ArgType::STRING)\n     * @Option(name=&quot;username&quot;, type=\\Imi\\Cli\\ArgType::STRING, default=&quot;默认值&quot;)\n     */\n    public function hello(string $content, string $username): void\n    {\n        echo &quot;{$username}: {$content}&quot;, PHP_EOL;\n\n        // 通过 input 对象获取参数\n        $this-&gt;input-&gt;getArgument(&#039;content&#039;);\n        $this-&gt;input-&gt;getOption(&#039;username&#039;);\n\n        // 通过 output 对象输出\n        $this-&gt;output-&gt;writeln(&quot;{$username}: {$content}&quot;);\n    }\n\n}工具调用imi 工具名称/动作名称 -参数名 参数值上面的例子调用示例：imi test/hello &quot;content内容&quot; --username yurun全局任意地方获取 input、output 对象use Imi\\Cli\\ImiCommand;\n$input = ImiCommand::getInput();\n$output = ImiCommand::getOutput();"},{"id":268,"title":"ElasticSearch","pageTitle":"ElasticSearch","url":"other/elasticsearch.html","content":"ElasticSearch目录ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。使用首先需要引入 Guzzle-Swoole：composer require yurunsoft/guzzle-swoole实例化时候这么写即可：$client = \\Elasticsearch\\ClientBuilder::create()-&gt;setHosts([&#039;192.168.0.233:9200&#039;])\n                                                -&gt;setHandler(new \\Yurun\\Util\\Swoole\\Guzzle\\Ring\\SwooleHandler()) // 关键是这句\n                                                -&gt;build();"},{"id":267,"title":"Guzzle","pageTitle":"Guzzle","url":"other/guzzle.html","content":"Guzzle目录Guzzle 是一个 PHP 的 HTTP 客户端，用来轻而易举地发送请求，并集成到我们的WEB服务上。Guzzle 被国内外广泛用于各种第三方 SDK 中，如果你正在寻找某某 SDK 的协程化支持，那么你来对啦！宇润曾经申请将 SwooleHttpClientHandler 集成到 Guzzle 核心，并且引入一个全局默认请求器的设置功能，由于一些原因并没有通过。传送门：https://github.com/guzzle/guzzle/pull/2128上有政策，下有对策，于是就有了 Guzzle-Swoole当然，如果你是希望自己编写 http 请求代码，这里更推荐使用：YurunHttp介绍让 Guzzle 支持 Swoole 协程，这个项目目的就是这么简单明了！Guzzle-Swoole 是 Guzzle 的处理器（Handler），并没有对 Guzzle 本身代码进行修改，理论上可以兼容后续版本。支持 Ring Handler，可以用于 elasticsearch/elasticsearch 等包中。使用Composer:&quot;yurunsoft/guzzle-swoole&quot;:&quot;~2.0&quot;全局设定处理器&lt;?php\nrequire dirname(__DIR__) . &#039;/vendor/autoload.php&#039;;\n\nuse GuzzleHttp\\Client;\nuse Yurun\\Util\\Swoole\\Guzzle\\SwooleHandler;\nuse GuzzleHttp\\DefaultHandler;\n\nDefaultHandler::setDefaultHandler(SwooleHandler::class);\n\ngo(function(){\n    $client = new Client();\n    $response = $client-&gt;request(&#039;GET&#039;, &#039;http://www.baidu.com&#039;, [\n        &#039;verify&#039;    =&gt;  false,\n    ]);\n    var_dump($response-&gt;getStatusCode());\n});\n手动指定 Swoole 处理器use GuzzleHttp\\Client;\nuse GuzzleHttp\\HandlerStack;\nuse Yurun\\Util\\Swoole\\Guzzle\\SwooleHandler;\n\ngo(function(){\n    $handler = new SwooleHandler();\n    $stack = HandlerStack::create($handler);\n    $client = new Client([&#039;handler&#039; =&gt; $stack]);\n    $response = $client-&gt;request(&#039;GET&#039;, &#039;http://www.baidu.com&#039;, [\n        &#039;verify&#039;    =&gt;  false,\n    ]);\n    var_dump($response-&gt;getBody()-&gt;__toString(), $response-&gt;getHeaders());\n});更加详细的示例代码请看test目录下代码。"},{"id":271,"title":"第三方支付 SDK","pageTitle":"第三方支付 SDK","url":"other/paysdk.html","content":"第三方支付 SDK目录PaySDK 是 PHP 集成支付 SDK ，集成了支付宝、微信支付的支付接口和其它相关接口的操作。可以轻松嵌入支持 PHP &gt;= 5.4 的任何系统中，2.0 版现已支持 Swoole 协程环境。支持的支付接口支付宝即时到账-电脑网站支付（老）即时到账-手机网站支付（老）当面付手机网站支付电脑网站支付APP支付服务端单笔转账到支付宝账户海外支付（电脑网站、手机网站、APP、扫码）海关报关其它辅助交易接口（退款、查询等）微信支付刷卡支付公众号支付扫码支付APP支付H5支付小程序支付企业付款到零钱企业付款到银行卡海外支付（刷卡、公众号、扫码、APP）海关报关其它辅助交易接口（退款、查询等）安装在您的composer.json中加入配置：{\n    &quot;require&quot;: {\n        &quot;yurunsoft/pay-sdk&quot;: &quot;~2.1&quot;\n    }\n}然后执行composer update命令。Swoole 协程环境支持在 WorkerStart 事件中加入：\\Yurun\\Util\\YurunHttp::setDefaultHandler(&#039;Yurun\\Util\\YurunHttp\\Handler\\Swoole&#039;);在支付、退款异步通知中，需要赋值 Swoole 的 Request 和 Response 对象，或者遵循 PSR-7 标准的对象即可。imi 框架中使用imi 是基于 PHP Swoole 的高性能协程应用开发框架，它支持 HttpApi、WebSocket、TCP、UDP、MQTT 服务的开发。在 Swoole 的加持下，相比 php-fpm 请求响应能力，I/O密集型场景处理能力，有着本质上的提升。imi 框架拥有丰富的功能组件，可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网（IOT）、车联网、智能家居等领域。可以使企业 IT 研发团队的效率大大提升，更加专注于开发创新产品。https://www.imiphp.com//**\n * 这是一个在控制器中的动作方法\n * @Action\n */\npublic function test()\n{\n    $payNotify = new class extends \\Yurun\\PaySDK\\Weixin\\Notify\\Pay\n    {\n        /**\n         * 后续执行操作\n         * @return void\n         */\n        protected function __exec()\n        {\n\n        }\n    };\n    $context = RequestContext::getContext();\n    // 下面两行很关键\n    $payNotify-&gt;swooleRequest = $context[&#039;request&#039;];\n    $payNotify-&gt;swooleResponse = $context[&#039;response&#039;];\n\n    $sdk-&gt;notify($payNotify);\n\n    // 这句话必须填写\n    return $payNotify-&gt;swooleResponse;\n}"},{"id":270,"title":"第三方授权 SDK","pageTitle":"第三方授权 SDK","url":"other/yurun-oauth-login.html","content":"第三方授权 SDK目录YurunOAuthLogin 是一个PHP 第三方登录授权 SDK，集成了QQ、微信、微博、Github等常用接口。可以轻松嵌入支持 PHP &gt;= 5.4 的任何系统中，2.0 版现已支持 Swoole 协程环境。支持的登录平台QQ、QQ 小程序微信网页扫码、微信公众号、微信小程序微博百度GithubGiteeCoding开源中国(OSChina)CSDN后续将不断添加新的平台支持，也欢迎你来提交PR，一起完善！安装在您的composer.json中加入配置：{\n    &quot;require&quot;: {\n        &quot;yurunsoft/yurun-oauth-login&quot;: &quot;~2.0&quot;\n    }\n}代码实例自v1.2起所有方法统一参数调用，如果需要额外参数的可使用对象属性赋值，具体参考test目录下的测试代码。下面代码以QQ接口举例，完全可以把QQ字样改为其它任意接口字样使用。实例化$qqOAuth = new \\Yurun\\OAuthLogin\\QQ\\OAuth2(&#039;appid&#039;, &#039;appkey&#039;, &#039;callbackUrl&#039;);登录$url = $qqOAuth-&gt;getAuthUrl();\n$_SESSION[&#039;YURUN_QQ_STATE&#039;] = $qqOAuth-&gt;state;\nheader(&#039;location:&#039; . $url);回调处理// 获取accessToken\n$accessToken = $qqOAuth-&gt;getAccessToken($_SESSION[&#039;YURUN_QQ_STATE&#039;]);\n\n// 调用过getAccessToken方法后也可这么获取\n// $accessToken = $qqOAuth-&gt;accessToken;\n// 这是getAccessToken的api请求返回结果\n// $result = $qqOAuth-&gt;result;\n\n// 用户资料\n$userInfo = $qqOAuth-&gt;getUserInfo();\n\n// 这是getAccessToken的api请求返回结果\n// $result = $qqOAuth-&gt;result;\n\n// 用户唯一标识\n$openid = $qqOAuth-&gt;openid;解决第三方登录只能设置一个回调域名的问题// 解决只能设置一个回调域名的问题，下面地址需要改成你项目中的地址，可以参考test/QQ/loginAgent.php写法\n$qqOAuth-&gt;loginAgentUrl = &#039;http://localhost/test/QQ/loginAgent.php&#039;;\n\n$url = $qqOAuth-&gt;getAuthUrl();\n$_SESSION[&#039;YURUN_QQ_STATE&#039;] = $qqOAuth-&gt;state;\nheader(&#039;location:&#039; . $url);Swoole 协程环境支持\\Yurun\\Util\\YurunHttp::setDefaultHandler(&#039;Yurun\\Util\\YurunHttp\\Handler\\Swoole&#039;);"},{"id":269,"title":"YurunHttp","pageTitle":"YurunHttp","url":"other/yurunhttp.html","content":"YurunHttp目录YurunHttp 是开源的 PHP HTTP 类库，支持链式操作，简单易用。支持所有常见的 GET、POST、PUT、DELETE、UPDATE 等请求方式，支持 Http2、WebSocket、浏览器级别 Cookies 管理、上传下载、设置和读取 header、Cookie、请求参数、失败重试、限速、代理、证书等。使用手册：http://doc.yurunsoft.com/YurunHttp使用{\n    &quot;require&quot;: {\n        &quot;yurunsoft/yurun-http&quot;: &quot;^4.0.0&quot;\n    }\n}Swoole 协程模式&lt;?php\nuse Yurun\\Util\\YurunHttp;\nuse Yurun\\Util\\HttpRequest;\n\n// 设置默认请求处理器为 Swoole\nYurunHttp::setDefaultHandler(\\Yurun\\Util\\YurunHttp\\Handler\\Swoole::class);\n\n// Swoole 处理器必须在协程中调用\ngo(&#039;test&#039;);\n\nfunction test()\n{\n    $http = new HttpRequest;\n    $response = $http-&gt;get(&#039;http://www.baidu.com&#039;);\n    echo &#039;html:&#039;, PHP_EOL, $response-&gt;body();\n}WebSocket ClientYurunHttp::setDefaultHandler(\\Yurun\\Util\\YurunHttp\\Handler\\Swoole::class);\ngo(function(){\n    $url = &#039;ws://127.0.0.1:1234/&#039;;\n    $http = new HttpRequest;\n    $client = $http-&gt;websocket($url);\n    if(!$client-&gt;isConnected())\n    {\n        throw new \\RuntimeException(&#039;Connect failed&#039;);\n    }\n    $client-&gt;send(&#039;data&#039;);\n    $recv = $client-&gt;recv();\n    var_dump(&#039;recv:&#039;, $recv);\n    $client-&gt;close();\n});Http2 兼容用法$http = new HttpRequest;\n$http-&gt;protocolVersion = &#039;2.0&#039;; // 这句是关键\n$response = $http-&gt;get(&#039;https://wiki.swoole.com/&#039;);Curl、Swoole Handler 都支持 Http2，但需要注意的是编译时都需要带上启用 Http2 的参数。查看是否支持：Curl: php --ri curlSwoole: php --ri swooleHttp2 全双工用法该用法仅支持 Swoole$uri = new Uri(&#039;https://wiki.swoole.com/&#039;);\n\n// 客户端初始化和连接\n$client = new \\Yurun\\Util\\YurunHttp\\Http2\\SwooleClient($uri-&gt;getHost(), Uri::getServerPort($uri), &#039;https&#039; === $uri-&gt;getScheme());\n$client-&gt;connect();\n\n// 请求构建\n$httpRequest = new HttpRequest;\n$request = $httpRequest-&gt;header(&#039;aaa&#039;, &#039;bbb&#039;)-&gt;buildRequest($uri, [\n    &#039;date&#039;  =&gt;  $i,\n], &#039;POST&#039;, &#039;json&#039;);\n\nfor($i = 0; $i &lt; 10; ++$i)\n{\n    go(function() use($client, $request){\n        // 发送（支持在多个协程执行）\n        $streamId = $client-&gt;send($request);\n        var_dump(&#039;send:&#039; . $streamId);\n\n        // 接收（支持在多个协程执行）\n        $response = $client-&gt;recv($streamId, 3);\n        $content = $response-&gt;body();\n        var_dump($response);\n    });\n}"},{"id":264,"title":"守护进程","pageTitle":"守护进程","url":"production/daemon.html","content":"守护进程目录命令模式守护进程方式启动：bin/imi-swoole swoole/start -d重定向标准输入输出：bin/imi-swoole swoole/start -d 文件名.log此方法只可让服务在后台运行，退出 ssh 后不被终止。无法在服务崩溃后重新拉起，建议使用 systemdSystemdSystemd 一般都已经集成在了现代 Linux 发行版中，使用它可以实现开机自启动和守护进程等功能。但 Systemd 在 WSL、Docker 环境中，可能难以使用。创建服务配置文件 test.service[Unit]\nDescription=test\nAfter=network.target syslog.target\n\n[Service]\nType=simple\nLimitNOFILE=65535\nExecStart=/your app path/vendor/bin/imi-swoole swoole/start\nExecReload=/bin/kill -USR1 $MAINPID\nRestart=always\n\n[Install]\nWantedBy=multi-user.target graphical.target修改ExecStart为你的启动命令，该文件适用于任何应用，不仅限于 imi 项目启用服务：systemctl --user enable $PWD/test.service启动服务：systemctl start test重启服务：systemctl restart test停止服务：systemctl stop test禁用服务：systemctl --user disable $PWD/test.serviceSupervisorSupervisor是用 Python 开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台 daemon，并监控进程状态，异常退出时能自动重启。安装和启动apt 安装：apt-get install -y supervisoryum 安装：yum install -y supervisorpip 安装：pip install supervisor启动 Supervisor 服务：service supervisor start服务配置文件文件名：/etc/supervisord.d/服务名.conf文件内容：# 项目名\n[program:服务名]\n\n# 脚本目录\ndirectory=/your app path\n\n# 脚本执行命令\ncommand=/your app path/vendor/bin/imi-swoole swoole/start\n\n# supervisor启动的时候是否随着同时启动，默认True\nautostart=true\n\n# 当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的\nautorestart = false\n\n# 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1\nstartsecs = 1\n\n# 脚本运行的用户身份 \nuser = test\n\n# 日志输出 \nstderr_logfile=/tmp/stderr.log\nstdout_logfile=/tmp/stdout.log\n\n# 把stderr重定向到stdout，默认 false\nredirect_stderr = true\n\n# stdout日志文件大小，默认 50MB\nstdout_logfile_maxbytes = 20MB\n\n# stdout日志文件备份数\nstdout_logfile_backups = 20Supervisor 服务管理命令说明# 查看所有进程的状态\nsupervisorctl status\n\n# 启动服务名\nsupervisorctl start 服务名\n\n# 停止服务\nsupervisorctl stop 服务名\n\n# 重启服务名\nsupervisorctl restart 服务名\n\n# 配置文件修改后使用该命令加载新的配置\nsupervisorctl update\n\n# 重新启动配置中的所有程序\nsupervisorctl reload"},{"id":263,"title":"Docker","pageTitle":"Docker","url":"production/docker.html","content":"Docker目录Swoole 模式推荐使用 Swoole 官方 Docker：https://github.com/swoole/docker-swoolehttps://hub.docker.com/r/phpswoole/swooleDockerfile:# 版本也可以自行修改\nFROM phpswoole/swoole:4.8-php7.4\n\nRUN apt update &amp;&amp; apt install unzip\n\n# 安装必要的扩展\nRUN docker-php-ext-install mysqli pdo_mysql &gt; /dev/null\n\n# 安装 Redis 扩展\nRUN pecl install redis &amp;&amp; docker-php-ext-enable redisWorkerman 模式推荐使用 PHP 公共 Docker：https://hub.docker.com/_/phpDockerfile:# 版本也可以自行修改\nFROM php:7.4-cli\n\nRUN apt update &amp;&amp; apt install unzip libevent-dev libssl-dev\n\n# 安装必要的扩展\nRUN docker-php-ext-install mysqli pdo_mysql pcntl sockets &gt; /dev/null\n\n# 安装 Redis 扩展\nRUN pecl install redis &amp;&amp; docker-php-ext-enable redis\n\n# 安装 Event 扩展，提升 Workerman 性能\nRUN pecl install event &amp;&amp; docker-php-ext-enable event\n\n# 安装 Composer，如果不需要可以注释\nRUN curl -o /usr/bin/composer https://getcomposer.org/composer.phar &amp;&amp; chmod +x /usr/bin/composerphp-fpm 模式推荐使用 PHP 公共 Docker：https://hub.docker.com/_/phpDockerfile:# 版本也可以自行修改\nFROM php:7.4\n\nRUN apt update &amp;&amp; apt install unzip\n\n# 安装必要的扩展\nRUN docker-php-ext-install mysqli pdo_mysql &gt; /dev/null\n\n# 安装 Redis 扩展\nRUN pecl install redis &amp;&amp; docker-php-ext-enable redis\n\n# 安装 Composer，如果不需要可以注释\nRUN curl -o /usr/bin/composer https://getcomposer.org/composer.phar &amp;&amp; chmod +x /usr/bin/composer"},{"id":265,"title":"Swoole Compiler 代码加密","pageTitle":"Swoole Compiler 代码加密","url":"production/swoole-compiler.html","content":"Swoole Compiler 代码加密目录Swoole Compiler 是识沃科技推出的 PHP 代码加密和客户端授权解决方案，通过业内先进的代码加密技术，包括流程混淆、花指令、变量混淆、函数名混淆、虚拟机保护技术、扁平化代码、SCCP 优化等，将 PHP 程序源代码编译为二进制指令，来保护您的源代码。服务地址：https://business.swoole.com/compiler.html使用说明使用 imi + Swoole Compiler 你需要注意如下事项：加密前先生成运行时缓存（注解扫描缓存）：vendor/bin/imi-swoole imi/buildRuntime加密时，不推荐加密 config、tests、vendor 等目录加密后启动服务带上参数：vendor/bin/imi-swoole swoole/start --app-runtime={你的项目路径}/.runtime/swoole/runtime/"},{"id":2,"title":"项目介绍","pageTitle":"项目介绍","url":"index.html","content":"项目介绍      介绍imi 是一款支持长连接微服务分布式的 PHP 开发框架，可在 PHP-FPM、Swoole、Workerman 和 RoadRunner 等多种容器环境下运行。imi 提供了丰富的基础功能：MySQL、PostgreSQL、Redis、超强超好用的自研 ORM、连接池、Web Api、Web MVC、WebSocket、TCP Server、UDP Server、HTTP2、MQTT、gRPC、容器化（Container）、依赖注入、Aop、事件、异步（Async）、缓存（Cache）、命令行（Command）、配置化（Config）、上下文（Context）、定时任务（Cron）、门面（Facade）、验证器（Validate）、锁（Lock）、日志（Log）、定时器（Timer）、权限控制、消息队列（RabbitMQ、Kafka、Redis）、Swagger、Hprose、宏（Macro）、限流、共享内存、Smarty、雪花算法发号器（Snowflake）、Workerman Gateway、InfluxDB 和 TDengine 等组件。同时，imi 还提供了微服务相关支持：Nacos 配置中心、etcd 配置中心、Nacos 服务注册、Nacos 服务发现、Swoole Tracker、Zipkin、Jaeger、Prometheus、InfluxDB 服务指标监控、TDengine 服务指标监控 和 负载均衡 等组件。除此之外，imi 还提供了管理后台开发骨架 imi-admin。imi 框架自 2018 年 6 月 21 日首次发布以来，已经稳定运行在许多项目中，例如文旅电商平台、物联网充电云平台、停车云平台、支付微服务、短信微服务、钱包微服务、卡牌游戏服务端和数据迁移服务（虎扑）等项目。社群imi 框架交流群： 17916227 微信群：（请注明来意）打赏赞助：https://www.imiphp.com/donate.html官方视频教程（完全免费）imi 2.0 基础视频教程(免费连载中):https://space.bilibili.com/768718/channel/seriesdetail?sid=274078https://www.zhihu.com/people/yurunsoft/zvideosimi 1.0 框架入门教程（免费11集全）https://www.bilibili.com/video/av78158909imi 框架进阶教程——五子棋游戏开发(免费7集全)https://space.bilibili.com/768718/channel/detail?cid=136926扩展组件优秀的第三方组件权限控制 (phpben/imi-auth)注册中心 (phpben/imi-config-center)模块化路由 (phpben/imi-module-route)ThinkPHP6 验证器 (phpben/imi-validate)优秀的开源项目后台管理框架 (phpben/imi-admin)开始使用创建 Http Server 项目：composer create-project imiphp/project-http:~2.1.0创建 WebSocket Server 项目：composer create-project imiphp/project-websocket:~2.1.0创建 TCP Server 项目：composer create-project imiphp/project-tcp:~2.1.0创建 UDP Server 项目：composer create-project imiphp/project-udp:~2.1.0创建 gRPC 项目：composer create-project imiphp/project-grpc:~2.1.0创建 MQTT Server 项目：composer create-project imiphp/project-mqtt:~2.1.0完全开发手册运行环境Linux 系统 (Swoole 不支持在 Windows 上运行)PHP &gt;= 7.4Composer &gt;= 2.0Swoole &gt;= 4.8.0Redis、PDO 扩展Docker推荐使用 Swoole 官方 Docker：https://github.com/swoole/docker-swoole成功案例无论您是在个人项目还是公司项目中使用 imi 开发，无论是开源还是商业项目，都可以向我们提交您的案例。我们会对您提交的案例进行审查，可能会将其展示在 imi 官网、Swoole 官网等处，这将有助于您的项目推广和发展。提交格式：项目名称项目介绍项目地址（官网/下载地址/Github等至少一项）联系方式（电话/邮箱/QQ/微信等至少一项）项目截图（可选）感言案例展示成功案例：https://www.imiphp.com/case.htmlimi 有你的案例会发展得更好，欢迎有条件的用户将项目案例挂上来，同时也是一种免费的宣传！版权信息imi 遵循木兰宽松许可证（Mulan PSL v2）开源协议发布，并提供免费商业使用。鸣谢感谢以下开源项目 (按字母顺序排列) 为 imi 提供强力支持！doctrine/annotations (PHP 注解处理类库)PHP (没有 PHP 就没有 imi)Swoole (没有 Swoole 就没有 imi)贡献者你想出现在贡献者列表中吗？你可以做的事（包括但不限于以下）：纠正拼写、错别字完善注释bug修复功能开发文档编写教程、博客分享提交 Pull Request 到本仓库，你可以成为 imi 的贡献者！参与框架开发教程详见：https://doc.imiphp.com/v2.1/adv/devp.html"},{"id":236,"title":"App 类","pageTitle":"App 类","url":"utils/app.html","content":"App 类目录Imi\\App 类，是框架应用类。方法getNamespace获取应用命名空间public static function getNamespace()getContainer获取容器对象public static function getContainer()getBean获取全局Bean对象public static function getBean($name, ...$params)isDebug当前是否为调试模式public static function isDebug()setDebug开关调试模式public static function setDebug($isDebug)get获取应用上下文数据public static function get($name, $default = null)set设置应用上下文数据public static function set($name, $value, $readonly = false)第三个参数可以禁止非 Imi\\ 开头的命名空间的类，对应用上下文中$name对应的值进行写操作。setNx设置应用上下文数据，当指定名称不存在时才设置public static function setNx(string $name, $value, bool $readonly = false): bool第三个参数可以禁止非 Imi\\ 开头的命名空间的类，对应用上下文中$name对应的值进行写操作。has应用上下文数据是否存在public static function has(string $name): boolgetImiVersion获取 imi 版本public static function getImiVersion(): stringgetApp获取 app 实例对象public static function getApp(): \\Imi\\Core\\App\\Contract\\IApp框架核心上下文列表进程相关类 Imi\\Util\\Process\\ProcessAppContexts:ProcessAppContexts::PROCESS_TYPE - 进程类型ProcessAppContexts::PROCESS_NAME - 进程名称ProcessAppContexts::MASTER_PID - 主进程pid进程类型定义类 Imi\\Util\\Process\\ProcessType:ProcessType::MASTER - master 进程ProcessType::MANAGER - manager 进程ProcessType::WORKER - worker 进程ProcessType::TASK_WORKER - task worker 进程ProcessType::PROCESS - 进程"},{"id":240,"title":"ArrayUtil","pageTitle":"ArrayUtil","url":"utils/ArrayUtil.html","content":"ArrayUtil目录类名: Imi\\Util\\ArrayUtil数组帮助类方法remove从数组中移除一个元素$array = [1, 2, 3, 4, 5];\n\n// 删除一个元素：[1, 3, 4, 5]\nvar_dump(ArrayUtil::remove($array, 2));\n\n// 删除多个元素：[1, 5]\nvar_dump(ArrayUtil::remove($array, 2, 3, 4));recursiveMerge多维数组递归合并，具体效果请看下面代码及运行结果$array1 = [\n    &#039;a&#039;    =&gt;    [\n        &#039;b1&#039;    =&gt;    [\n            &#039;c1&#039;    =&gt;    1,\n        ],\n        &#039;b2&#039;    =&gt;    [\n            &#039;c2&#039;    =&gt;    2,\n        ]\n    ]\n];\n$array2 = [\n    &#039;a&#039;    =&gt;    [\n        &#039;b1&#039;    =&gt;    [\n            &#039;c1&#039;    =&gt;    3,\n        ]\n    ]\n];\n\n// array_merge\nprint_r(array_merge($array1, $array2));\n\n// +\nprint_r($array1 + $array2);\n\n// ArrayUtil::recursiveMerge\nprint_r(ArrayUtil::recursiveMerge($array1, $array2));运行结果：Array\n(\n    [a] =&gt; Array\n        (\n            [b1] =&gt; Array\n                (\n                    [c1] =&gt; 3\n                )\n        )\n)\nArray\n(\n    [a] =&gt; Array\n        (\n            [b1] =&gt; Array\n                (\n                    [c1] =&gt; 1\n                )\n            [b2] =&gt; Array\n                (\n                    [c2] =&gt; 2\n                )\n        )\n)\nArray\n(\n    [a] =&gt; Array\n        (\n            [b1] =&gt; Array\n                (\n                    [c1] =&gt; 3\n                )\n            [b2] =&gt; Array\n                (\n                    [c2] =&gt; 2\n                )\n        )\n)columnToKey将二维数组第二纬某key变为一维的key$array = [\n    [&#039;id&#039;=&gt;1,&#039;name&#039;=&gt;&#039;a&#039;],\n    [&#039;id&#039;=&gt;2,&#039;name&#039;=&gt;&#039;b&#039;],\n    [&#039;id&#039;=&gt;3,&#039;name&#039;=&gt;&#039;c&#039;],\n];\n\n// 保留原始字段\nprint_r(ArrayUtil::columnToKey($array, &#039;id&#039;));\n\n// 去除原始字段\nprint_r(ArrayUtil::columnToKey($array, &#039;id&#039;, false));运行结果：Array\n(\n    [1] =&gt; Array\n        (\n            [id] =&gt; 1\n            [name] =&gt; a\n        )\n    [2] =&gt; Array\n        (\n            [id] =&gt; 2\n            [name] =&gt; b\n        )\n    [3] =&gt; Array\n        (\n            [id] =&gt; 3\n            [name] =&gt; c\n        )\n\n)\nArray\n(\n    [1] =&gt; Array\n        (\n            [name] =&gt; a\n        )\n    [2] =&gt; Array\n        (\n            [name] =&gt; b\n        )\n    [3] =&gt; Array\n        (\n            [name] =&gt; c\n        )\n)isAssoc判断数组是否为关联数组$array = [1, 2, 3];\n// false\nvar_dump(ArrayUtil::isAssoc($array));\n\n$array = [1, &#039;b&#039;=&gt;2, 3];\n// true\nvar_dump(ArrayUtil::isAssoc($array));random随机获得数组中的值保持键名：$array = [&#039;a&#039; =&gt; 1, &#039;b&#039; =&gt; 2, &#039;c&#039; =&gt; 3];\n// 返回随机的数组，如：[&#039;a&#039; =&gt; 1]，第二个参数缺省默认为1\nvar_dump(ArrayUtil::random($array));\n\n// 返回随机的数组，如：[&#039;b&#039; =&gt; 2, &#039;a&#039; =&gt; 1]\nvar_dump(ArrayUtil::random($array, 2));不保持键名：$array = [&#039;a&#039; =&gt; 1, &#039;b&#039; =&gt; 2, &#039;c&#039; =&gt; 3];\n// 返回随机的数组，如：[1, 2]\nvar_dump(ArrayUtil::random($array, 2, false));"},{"id":241,"title":"Bit","pageTitle":"Bit","url":"utils/Bit.html","content":"Bit目录类名: Imi\\Util\\Bit位操作工具类方法has判断是否包含值// true\nvar_dump(Bit::has(LOCK_SH | LOCK_NB, LOCK_NB));\n\n// false\nvar_dump(Bit::has(LOCK_SH, LOCK_NB));"},{"id":46,"title":"ChannelContainer","pageTitle":"ChannelContainer","url":"utils/ChannelContainer.html","content":"ChannelContainer目录类名: Imi\\Swoole\\Util\\Co\\ChannelContainer一个通道（Channel）管理容器，通过一个 id，快速操作和管理通道。imi v1.2.0 版本新增方法push向通道中写入数据。ChannelContainer::push(&#039;id123&#039;, &#039;数据&#039;);\nChannelContainer::push(&#039;id123&#039;, &#039;数据&#039;, 3); // 超时 3 秒pop从通道中读取数据。ChannelContainer::pop(&#039;id123&#039;);\nChannelContainer::pop(&#039;id123&#039;, 3); // 超时 3 秒finallyPop从通道拿数据，并且释放通道ChannelContainer::finallyPop(&#039;id123&#039;);\nChannelContainer::finallyPop(&#039;id123&#039;, 3); // 超时 3 秒stats获取通道的状态ChannelContainer::stats(&#039;id123&#039;);close关闭通道。并唤醒所有等待读写的协程。ChannelContainer::close(&#039;id123&#039;);length获取通道中的元素数量。ChannelContainer::length(&#039;id123&#039;);isEmpty判断当前通道是否为空。ChannelContainer::isEmpty(&#039;id123&#039;);isFull判断当前通道是否已满。ChannelContainer::isFull(&#039;id123&#039;);getChannel获取 \\Swoole\\Coroutine\\Channel 对象，不存在会自动创建并返回ChannelContainer::getChannel(&#039;id123&#039;);hasChannel通道是否存在ChannelContainer::hasChannel(&#039;id123&#039;);removeChannel移除通道ChannelContainer::removeChannel(&#039;id123&#039;);"},{"id":242,"title":"ClassObject","pageTitle":"ClassObject","url":"utils/ClassObject.html","content":"ClassObject目录类名: Imi\\Util\\ClassObject类和对象相关工具类方法isAnymous是否是匿名类对象// true\nvar_dump(ClassObject::isAnymous(App::getBean(&#039;Logger&#039;)));\n\n// false\nvar_dump(ClassObject::isAnymous(new \\Imi\\Log\\Logger));处理可能是同级的类名如果 $className 是一个类名，则原样返回否则返回 $sameLevelClass 同级下的类名ClassObject::parseSameLevelClassName($className, $sameLevelClass)将方法的参数处理成 kv 数组class A\n{\n    public function test($id, $name, $age = 9999)\n    {\n\n    }\n}\n\n$args = [\n    19260817,\n    &#039;imiphp.com&#039;,\n];\n\n$result1 = ClassObject::convertArgsToKV(&#039;A&#039;, &#039;test&#039;, $args, true);\nvar_dump($result1);\n/*\narray(3) {\n  [&quot;id&quot;]=&gt;\n  int(19260817)\n  [&quot;name&quot;]=&gt;\n  string(10) &quot;imiphp.com&quot;\n  [&quot;age&quot;]=&gt;\n  int(9999)\n}\n*/\n\n$result2 = ClassObject::convertArgsToKV(&#039;A&#039;, &#039;test&#039;, $args, false);\nvar_dump($result2);\n/*\narray(2) {\n  [&quot;id&quot;]=&gt;\n  int(19260817)\n  [&quot;name&quot;]=&gt;\n  string(10) &quot;imiphp.com&quot;\n}\n*/"},{"id":44,"title":"Coroutine","pageTitle":"Coroutine","url":"utils/Coroutine.html","content":"Coroutine目录类名: Imi\\Swoole\\Util\\Coroutine协程帮助类继承了\\Swoole\\Coroutine方法isIn判断当前是否在协程中运行var_dump(Coroutine::isIn());由于继承了 Swoole 的协程类，所以可以使用其全部方法: http://wiki.swoole.com/#/coroutine/coroutine"},{"id":248,"title":"DateTime","pageTitle":"DateTime","url":"utils/DateTime.html","content":"DateTime目录类名: Imi\\Util\\DateTime日期时间工具类方法getSecondsByInterval将一个 \\DateInterval，与当前时间进行计算，获取毫秒数$d1 = new DateTime(&quot;2019-06-21&quot;);\n$d2 = new DateTime(&quot;2018-06-21&quot;);\n$diff = $d2-&gt;diff($d1); \n$s = \\Imi\\Util\\DateTime::getSecondsByInterval($diff);\nvar_dump($s); // 31622400"},{"id":"645b0aaa2c7e59.66088070","title":"Digital","pageTitle":"Digital","url":"utils/Digital.html","content":"Digital目录类名: Imi\\Util\\Digital数字相关工具类方法scientificToNum科学计数转小数形式的echo Digital::scientificToNum(2.1E-5, 6); // 0.000021"},{"id":250,"title":"ExpiredStorage","pageTitle":"ExpiredStorage","url":"utils/ExpiredStorage.html","content":"ExpiredStorage目录类名: Imi\\Util\\ExpiredStorage支持键值过期的存储对象方法__construct$storage = new \\Imi\\Util\\ExpiredStorage();\n$storage = new \\Imi\\Util\\ExpiredStorage([\n    &#039;key&#039; =&gt; &#039;value&#039;,\n]);set设置值$storage-&gt;set(&#039;key&#039;, &#039;value&#039;);\n$ttl = 1.5; // 过期时间，单位：秒\n$storage-&gt;set(&#039;key&#039;, &#039;value&#039;, $ttl);get获取值，不会返回已过期的值var_dump($storage-&gt;get(&#039;key&#039;));\nvar_dump($storage-&gt;get(&#039;key&#039;, &#039;default&#039;)); // 缺省默认值\n\n// 获取存储对象 $item\nvar_dump($storage-&gt;get(&#039;key&#039;, null, $item));\n$item-&gt;setValue(&#039;value&#039;); // 设置值\n$item-&gt;getValue(); // 获取值，不受超时时间限制\n$item-&gt;setTTL(1.5); // 设置超时时间\n$item-&gt;getTTL(); // 获取超时时间\n$item-&gt;isExpired(); // 是否过期\n$item-&gt;getLastModifyTime(); // 获取数据最后修改时间，microtime(true) 的返回值，小数，单位：秒unset删除值$storage-&gt;unset(&#039;key&#039;);isset值是否存在，过期会返回 false$storage-&gt;isset(&#039;key&#039;);clear清空$storage-&gt;clear();获取所有存储对象$items = $storage-&gt;getItems();"},{"id":243,"title":"File","pageTitle":"File","url":"utils/File.html","content":"File目录类名: Imi\\Util\\File文件相关工具类方法enum方法返回一个迭代器对象。// 枚举当前目录及所有子目录中的文件，不包含.和..\nforeach(File::enum(__DIR__) as $fileName)\n{\n    echo (string)$fileName, PHP_EOL;\n}enumPHPFile方法返回一个迭代器对象。// 枚举当前目录及所有子目录中的PHP文件\nforeach(File::enumPHPFile(__DIR__) as $fileName)\n{\n    echo (string)$fileName, PHP_EOL;\n}path组合路径，目录后的/不是必须// abc/index.html\necho File::path(&#039;abc&#039;, &#039;index.html&#039;);\n\n// 支持协议uri，多余的/会合并为一个：http:/www.baidu.com/a/b/index.html\necho File::path(&#039;http://www.baidu.com&#039;, &#039;a//b///&#039;, &#039;index.html&#039;);readAll根据文件打开句柄，读取文件所有内容$fp = fopen(__FILE__, &#039;r&#039;);\necho File::readAll($fp);\nfclose($fp);createDir创建一个目录// 递归创建目录，权限默认0755\nFile::createDir(&#039;a/b/c&#039;);\n\n// 递归创建目录，权限为0777\nFile::createDir(&#039;a/b/c&#039;, 0777);createFile创建一个文件// 创建文件，目录不存在则自动创建，权限默认0755\nFile::createFile(&#039;a/b/c.txt&#039;);\n\n// 创建文件，目录不存在，指定内容为abc，则自动创建，权限默认0755\nFile::createFile(&#039;a/b/c.txt&#039;, &#039;abc&#039;);\n\n// 创建文件，目录不存在则自动创建，权限为0777\nFile::createFile(&#039;a/b/c.txt&#039;, &#039;&#039;, 0777);isEmptyDir判断是否为空目录File::isEmptyDir(__DIR__);deleteDir递归删除目录及目录中所有文件File::deleteDir(&#039;xxx&#039;);putContents写入内容到文件，如果目录不存在自动创建多级目录。参数、返回值与 file_put_contents 完全一致File::putContents(&#039;./a/b/c/1.txt&#039;, &#039;123&#039;);absolute获取绝对路径相比 realpath() 函数，此方法不需要路径是真实存在的。// /a/b/c/1.jpg\nFile::absolute(&#039;/a/b/d/e/../../c/./1.jpg&#039;);"},{"id":237,"title":"全局函数","pageTitle":"全局函数","url":"utils/functions.html","content":"全局函数目录imigo启动一个协程，自动创建和销毁上下文imigo(function(){\n    $value = Redis::get(&#039;key&#039;);\n    // 无需手动释放任何资源\n});传入参数：imigo(function($id, $name){\n    echo $id, &#039;:&#039;, $name, PHP_EOL; // 1:test\n}, 1, &#039;test&#039;);imiCallable为传入的回调自动创建和销毁上下文，并返回新的回调$callable = imiCallable(function(){\n    return &#039;abc&#039;;\n});\nfunction test($a)\n{\n    $value = $a(); // abc\n}\ntest($callable);开新协程去执行回调，无法获取返回值：$callable = imiCallable(function(){\n    return &#039;abc&#039;;\n}, true); // 这里加了 true\nfunction test($a)\n{\n    $value = $a(); // 协程ID\n}\ntest($callable);imiGetEnv获取环境变量值定义：imiGetEnv($varname = null, $default = null, $localOnly = false);将在 imi v3.0.0 废弃，请使用 Imi\\env()Imi\\env获取环境变量值定义：env($varname = null, $default = null, $localOnly = false);Imi\\cmd处理命令行，执行后不会有 sh 进程echo \\Imi\\cmd(&#039;ls&#039;);Imi\\ttyExec尝试使用 tty 模式执行命令，可以保持带颜色格式的输出返回进程退出码定义：function ttyExec(string|array $commands, ?float $timeout = null, ?\\Symfony\\Component\\Process\\Process &amp;$process = null): int\\Imi\\tty(&#039;ls&#039;); // 默认不超时\n\n\\Imi\\tty(&#039;sleep 2&#039;, 1.5); // 1.5 秒超时\n\n\\Imi\\tty(&#039;ls&#039;, null, $process); // 捕获 \\Symfony\\Component\\Process\\Process 对象超时会抛出异常：\\Symfony\\Component\\Process\\Exception\\ProcessTimedOutExceptionImi\\dump调试输出函数，用法同 var_dump()。cli 模式运行时，会通过 Log::debug() 来记录运行结果。例：\\Imi\\dump(&#039;Hello imi!&#039;);[2022-03-21 16:21:34] imi.DEBUG: \nstring(10) &quot;Hello imi!&quot;"},{"id":238,"title":"Imi","pageTitle":"Imi","url":"utils/Imi.html","content":"Imi目录类名: Imi\\Util\\Imi框架里杂七杂八的各种工具方法基本都放在这个类方法仅列出可能常用的方法，大多数方法无需了解。parseDotRule处理按.分隔的规则文本，支持.转义不分隔// [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;]\nvar_dump(Imi::parseDotRule(&#039;a.b.c&#039;));\n\n// [&#039;a.b&#039;, &#039;c&#039;]\nvar_dump(Imi::parseDotRule(&#039;a\\.b.c&#039;));getClassNamespace获取类命名空间// A\\B\necho Imi::getClassNamespace(&#039;A\\B\\C&#039;);getClassShortName获取类短名称// C\necho Imi::getClassShortName(&#039;A\\B\\C&#039;);getNamespacePath根据命名空间获取真实路径，返回null则为获取失败// /mnt/d/projects/imi-demo/vendor/imiphp/imi/src/\necho Imi::getNamespacePath(&#039;Imi&#039;), PHP_EOL;\n\n// /mnt/d/projects/imi-demo/HttpDemo/\necho Imi::getNamespacePath(&#039;ImiDemo\\HttpDemo&#039;), PHP_EOL;getNamespacePaths根据命名空间获取真实路径，允许返回多个var_dump(Imi::getNamespacePaths(&#039;Imi&#039;));getClassPropertyValue获取类属性的值，值为beans配置或默认配置，支持传入Bean名称构造方法赋值无法取出// 默认为Imi\\Server\\Group\\Handler\\Redis\necho Imi::getClassPropertyValue(&#039;ServerGroup&#039;, &#039;groupHandler&#039;);getImiCmd获取imi命令行// php /mnt/d/projects/imi-demo/HttpDemo/bin/imi-swoole swoole/reload\necho Imi::getImiCmd(&#039;swoole&#039;, &#039;reload&#039;);getRuntimePath获取运行时目录路径// 返回：运行时目录路径\necho Imi::getRuntimePath();\n\n// 返回：运行时目录路径/a.jpg\necho Imi::getRuntimePath(&#039;a.jpg&#039;);\n\n// 返回：运行时目录路径/a/b.jpg\necho Imi::getRuntimePath(&#039;a&#039;, &#039;b.jpg&#039;);getModeRuntimePath获取模式对应的运行时目录路径// 返回：运行时目录路径/swoole/a/b.jpg\necho Imi::getModeRuntimePath(&#039;swoole&#039;, &#039;a&#039;, &#039;b.jpg&#039;);getCurrentModeRuntimePath获取当前模式对应的运行时目录路径// 返回：运行时目录路径/swoole/a/b.jpg\necho Imi::getModeRuntimePath(&#039;a&#039;, &#039;b.jpg&#039;);buildRuntime构建运行时缓存/**\n * 构建运行时缓存.\n *\n * @param string|null $cacheName 如果为空则默认为runtime\n */\npublic static function buildRuntime(?string $cacheName = null): voidloadRuntimeInfo/**\n * 从文件加载运行时数据\n */\npublic static function loadRuntimeInfo(string $cacheName): boolincrUpdateRuntime/**\n * 增量更新运行时缓存.\n */\npublic static function incrUpdateRuntime(array $files): voidcheckReusePort/**\n * 检查系统是否支持端口重用.\n */\npublic static function checkReusePort(): boolevaleval() 函数的安全替代方法Imi::eval(&#039;echo &quot;hello imi&quot;;&#039;);isWSL检测是否为 WSL 环境/**\n * 检测是否为 WSL 环境.\n */\npublic static function isWSL(): boolgetLinuxVersion获取 Linux 版本号/**\n * 获取 Linux 版本号.\n */\npublic static function getLinuxVersion(): stringgetDarwinVersion获取苹果系统版本/**\n * 获取苹果系统版本.\n */\npublic static function getDarwinVersion(): stringgetCygwinVersion/**\n * 获取 Cygwin 版本.\n */\npublic static function getCygwinVersion(): stringisDockerEnvironment判断是否为 Docker 环境/**\n * 判断是否为 Docker 环境.\n */\npublic static function isDockerEnvironment(): boolcheckAppType检查应用运行类型/**\n * 检查应用运行类型.\n */\npublic static function checkAppType(string $appType): bool目前支持：swoole、workerman、fpm、cli"},{"id":244,"title":"ObjectArrayHelper","pageTitle":"ObjectArrayHelper","url":"utils/ObjectArrayHelper.html","content":"ObjectArrayHelper目录类名: Imi\\Util\\ObjectArrayHelper对象及数组帮助类智能识别数组和对象，支持对a.b.c这样的name属性进行操作方法以下所有示例，前提代码为：$data = [\n    &#039;a&#039; =&gt;  [\n        &#039;b&#039; =&gt;  [\n            &#039;c&#039; =&gt;  &#039;111&#039;,\n        ],\n    ],\n];\n// 也可以是任意对象及数组的混合用法，如：\n$data = new \\stdClass;\n$data-&gt;a = [];\n$data-&gt;a[&#039;b&#039;] = new \\stdClass;\n$data-&gt;a[&#039;b&#039;]-&gt;c = &#039;111&#039;;get获取值// 111\necho ObjectArrayHelper::get($data, &#039;a.b.c&#039;);\n\n// 222\necho ObjectArrayHelper::get($data, &#039;a.b.c.d&#039;, &#039;222&#039;);set设置值ObjectArrayHelper::set($data, &#039;a.b.c2&#039;, &#039;333&#039;);remove移除值ObjectArrayHelper::remove($data, &#039;a.b.c2&#039;);exists值是否存在var_dump(ObjectArrayHelper::exists($data, &#039;a.b.c2&#039;));filter过滤属性$data = [\n    &#039;id&#039;    =&gt;    1,\n    &#039;name&#039;    =&gt;    &#039;imi&#039;,\n];\n// $data = new stdClass;\n// $data-&gt;id = 1;\n// $data-&gt;name = &#039;imi&#039;;\n\n// 以上两个都支持\n\n// 只保留 name 字段\nvar_dump(ObjectArrayHelper::filter($data, [&#039;name&#039;]));\n\n// 剔除 name 字段\nvar_dump(ObjectArrayHelper::filter($data, [&#039;name&#039;], &#039;deny&#039;));"},{"id":247,"title":"Pagination","pageTitle":"Pagination","url":"utils/Pagination.html","content":"Pagination目录类名: Imi\\Util\\Pagination分页计算类方法构造方法public function __construct($page, $count)$page 当前页码$count 每页数量getPage字面意思setPage字面意思getCount字面意思setCount字面意思getLimitOffset获取偏移量，如 limit 20, 10 中的 20getLimitEndOffset获取结束的偏移量，如 limit 20, 10 中的 29calcPageCount根据记录数计算总页数$records = 101;\n$page = new \\Imi\\Util\\Pagination(1, 10);\n$pagination-&gt;calcPageCount($records); // 11例子$page = new \\Imi\\Util\\Pagination(10, 15);\n$limit = &#039;limit &#039; . $page-&gt;getLimitOffset() . &#039;,&#039; . $page-&gt;getCount();\necho $limit;"},{"id":245,"title":"Random","pageTitle":"Random","url":"utils/Random.html","content":"Random目录类名: Imi\\Util\\Random随机生成一些东西的工具类方法int随机整数// 随机范围：PHP_INT_MIN-PHP_INT_MAX\necho Random::int(), PHP_EOL;\n\n// 随机范围：1-20\necho Random::int(1, 20), PHP_EOL;float随机小数// 随机范围：PHP_INT_MIN-PHP_INT_MAX\necho Random::float(), PHP_EOL;\n\n// 随机范围：1.1-20.5\necho Random::float(1.1, 20.5), PHP_EOL;number随机生成小数文本// 随机范围：PHP_INT_MIN-PHP_INT_MAX\necho Random::number(), PHP_EOL;\n\n// 随机范围：12-20\necho Random::number(1.2, 20), PHP_EOL;text随机生成文本// 从啊哦额中随机4-6个字符\necho Random::text(&#039;啊哦额&#039;, 4, 6), PHP_EOL;\n\n// 从啊哦额中随机5个字符\necho Random::text(&#039;啊哦额&#039;, 5), PHP_EOL;bytes随机生成字节集// 从abcdefg中随机4-6个字节\necho Random::bytes(&#039;abcdefg&#039;, 4, 6), PHP_EOL;\n\n// 从abcdefg中随机5个字节\necho Random::bytes(&#039;abcdefg&#039;, 5), PHP_EOL;letter随机生成字母// 随机大小写字母4-6个\necho Random::letter(4, 6), PHP_EOL;\n// 随机大小写字母5个\necho Random::letter(5), PHP_EOL;digital随机生成数字和Random::int()方法不同的是，这个是生成字符串，所以不限制数值的大小。// 随机100-200个数字\necho Random::digital(100, 200), PHP_EOL;\n// 随机100个数字\necho Random::digital(100), PHP_EOL;letterAndNumber// 随机生成4-6个字母+数字\necho Random::letterAndNumber(4, 6);\n// 随机生成5个字母+数字\necho Random::letterAndNumber(5);"},{"id":251,"title":"服务器工具类","pageTitle":"服务器工具类","url":"utils/Server.html","content":"服务器工具类目录类名: Imi\\Server\\Server服务器工具类，支持向客户端进行消息推送，部分工具类实现还支持了分布式消息推送。多种服务器工具类实现配置：&#039;imi&#039; =&gt; [\n    &#039;beans&#039; =&gt; [\n        &#039;ServerUtil&#039; =&gt; &#039;类名或Bean名称&#039;,\n    ],\n],SwooleSwoole 本地服务器工具类Bean 名称：LocalServerUtil基于 Swoole Server 的 sendMessage() 方法实现，支持跨 Worker 进程中的连接，推送数据到客户端。适用于单实例部署的场景。Swoole 模式下默认使用该类Redis 服务器工具类Bean 名称：RedisServerUtil使用 Redis 发布订阅实现的，分布式服务器工具类，支持分布式消息推送。适用于分布式多实例部署的场景。支持注入的 beans 参数：[\n    &#039;beans&#039; =&gt; [\n        &#039;RedisServerUtil&#039; =&gt; [\n            &#039;redisName&#039; =&gt; null, // 配置的 Redis 连接名称，为 null 则使用默认\n            &#039;channel&#039; =&gt; &#039;imi:RedisServerUtil:channel&#039;, // 发布订阅的频道名，不同服务请设为不同的，以防冲突\n        ],\n    ],\n]使用 RedisServerUtil 请在 redis 连接池的 resource.options 中加入：\\Redis::OPT_READ_TIMEOUT =&gt; -1，防止 read error on connection to xxx 错误刷屏SwooleGatewayServerUtil在 Swoole 模式下使用 Workerman 网关WorkermanWorkerman 本地服务器工具类Bean 名称：LocalServerUtil仅支持单个进程中，连接的消息推送，建议仅用于开发环境。Workerman 频道工具类Bean 名称：ChannelServerUtil基于 Workerman 的 Channel 组件实现。适用于分布式多实例部署的场景。首先你需要配置一个 Channel 服务：// Workerman 服务器配置\n&#039;workermanServer&#039; =&gt; [\n    // channel 是名称可以改成你自己的\n    &#039;channel&#039; =&gt; [\n        &#039;namespace&#039;   =&gt; &#039;&#039;,\n        &#039;type&#039;        =&gt; Imi\\Workerman\\Server\\Type::CHANNEL,\n        &#039;host&#039;        =&gt; &#039;0.0.0.0&#039;,\n        &#039;port&#039;        =&gt; 13005,\n        &#039;configs&#039;     =&gt; [\n        ],\n    ],\n]然后配置 Worker 进程连接 Channel：&#039;workerman&#039; =&gt; [\n    // 多进程通讯组件配置\n    &#039;channel&#039; =&gt; [\n        &#039;host&#039; =&gt; &#039;127.0.0.1&#039;,\n        &#039;port&#039; =&gt; 13005,\n    ],\n],Workerman 网关工具类Bean 名称：WorkermanGatewayServerUtil在 Workerman 模式下使用 Workerman 网关Fpm无方法getServer获取服务器$server = Server::getServer(); // 获取当前服务器\n$server = Server::getServer(&#039;serverName&#039;); // 获取指定名称的服务器\n$server = Server::getServer(&#039;serverName&#039;, \\Imi\\Swoole\\Server\\Contract\\ISwooleServer::class); // 获取指定名称的服务器，并且验证是否属于某一类服务器对象sendMessage发送消息给 Worker 进程，使用框架内置格式返回成功发送消息数量// 发送给所有 Worker\nServer::sendMessage(&#039;动作&#039;, [\n    // 数据\n]);\n\n// 发送给指定 Worker\nServer::sendMessage(&#039;动作&#039;, [\n    // 数据\n], 0);\n\n// 发送给指定多个 Worker\nServer::sendMessage(&#039;动作&#039;, [\n    // 数据\n], [0, 1, 2]);sendMessageRaw发送消息给 Worker 进程返回成功发送消息数量// 发送给所有 Worker\nServer::sendMessageRaw(&#039;数据&#039;);\n\n// 发送给指定 Worker\nServer::sendMessageRaw(&#039;数据&#039;, 0);\n\n// 发送给指定多个 Worker\nServer::sendMessageRaw(&#039;数据&#039;, [0, 1, 2]);send发送数据给指定客户端，支持一个或多个（数组）数据将会通过处理器编码// 发送给当前连接\nServer::send([\n    // 数据\n]);\n\n// 发送给指定连接\nServer::send([\n    // 数据\n], 1);\n\n// 发送给指定多个连接\nServer::send([\n    // 数据\n], [1, 2, 3]);\n\n// 指定服务名，支持监听多个子服务器的情况\nServer::send([\n    // 数据\n], 1, &#039;myServer&#039;);\n\n// SWOOLE_BASE 模式下只发送给当前 worker 进程中的连接\nServer::send([\n    // 数据\n], 1, &#039;myServer&#039;, false);sendByFlag发送数据给指定标记的客户端，支持一个或多个（数组）数据将会通过处理器编码// 需要有绑定过的连接，才可以使用此方法\n\\Imi\\ConnectionContext::bind(&#039;user1&#039;);\n\n// 发送给当前连接\nServer::sendByFlag([\n    // 数据\n]);\n\n// 发送给指定连接\nServer::sendByFlag([\n    // 数据\n], &#039;user1&#039;);\n\n// 发送给指定多个连接\nServer::sendByFlag([\n    // 数据\n], [&#039;user1&#039;, &#039;user2&#039;, &#039;user3&#039;]);\n\n// 指定服务名，支持监听多个子服务器的情况\nServer::sendByFlag([\n    // 数据\n], &#039;user1&#039;, &#039;myServer&#039;);\n\n// SWOOLE_BASE 模式下只发送给当前 worker 进程中的连接\nServer::sendByFlag([\n    // 数据\n], &#039;user1&#039;, &#039;myServer&#039;, false);sendRaw发送数据给指定客户端，支持一个或多个（数组）// 发送给当前连接\nServer::sendRaw(&#039;数据&#039;);\n\n// 发送给指定连接\nServer::sendRaw(&#039;数据&#039;, 1);\n\n// 发送给指定多个连接\nServer::sendRaw(&#039;数据&#039;, [1, 2, 3]);\n\n// 指定服务名，支持监听多个子服务器的情况\nServer::sendRaw(&#039;数据&#039;, 1, &#039;myServer&#039;);\n\n// SWOOLE_BASE 模式下只发送给当前 worker 进程中的连接\nServer::sendRaw(&#039;数据&#039;, 1, &#039;myServer&#039;, false);sendRawByFlag发送数据给指定标记的客户端，支持一个或多个（数组）// 需要有绑定过的连接，才可以使用此方法\n\\Imi\\ConnectionContext::bind(&#039;user1&#039;);\n\n// 发送给当前连接\nServer::sendRawByFlag(&#039;数据&#039;);\n\n// 发送给指定连接\nServer::sendRawByFlag(&#039;数据&#039;, &#039;user1&#039;);\n\n// 发送给指定多个连接\nServer::sendRawByFlag(&#039;数据&#039;, [&#039;user1&#039;, &#039;user2&#039;, &#039;user3&#039;]);\n\n// 指定服务名，支持监听多个子服务器的情况\nServer::sendRawByFlag(&#039;数据&#039;, &#039;user1&#039;, &#039;myServer&#039;);\n\n// SWOOLE_BASE 模式下只发送给当前 worker 进程中的连接\nServer::sendRawByFlag(&#039;数据&#039;, &#039;user1&#039;, &#039;myServer&#039;, false);sendToAll发送数据给所有客户端数据将会通过处理器编码\n// 发送给所有连接\nServer::sendToAll([\n    // 数据\n]);\n\n// 指定服务名，支持监听多个子服务器的情况\nServer::sendToAll([\n    // 数据\n], &#039;myServer&#039;);\n\n// BASE模式下，只发送给当前 worker 中的所有连接（默认发给所有进程的连接）\nServer::sendToAll([\n    // 数据\n], &#039;myServer&#039;, false);sendRawToAll发送数据给所有客户端数据原样发送// 发送给所有连接\nServer::sendRawToAll(&#039;数据&#039;);\n\n// 指定服务名，支持监听多个子服务器的情况\nServer::sendRawToAll(&#039;数据&#039;, &#039;myServer&#039;);\n\n// BASE模式下，只发送给当前 worker 中的所有连接（默认发给所有进程的连接）\nServer::sendRawToAll(&#039;数据&#039;, &#039;myServer&#039;, false);sendToGroup发送数据给分组中的所有客户端，支持一个或多个（数组）数据将会通过处理器编码// 发送给单个分组\nServer::sendToGroup(&#039;myGroupName&#039;, [\n    // 数据\n]);\n\n// 发送给多个分组\nServer::sendToGroup([&#039;myGroupName1&#039;, &#039;myGroupName2&#039;], [\n    // 数据\n]);\n\n// 指定服务名，支持监听多个子服务器的情况\nServer::sendToGroup(&#039;myGroupName&#039;, [\n    // 数据\n], &#039;myServer&#039;);\n\n// BASE模式下，只发送给当前 worker 中的所有连接（默认发给所有进程的连接）\nServer::sendToGroup(&#039;myGroupName&#039;, [\n    // 数据\n], &#039;myServer&#039;, false);sendRawToGroup发送数据给分组中的所有客户端，支持一个或多个（数组）数据原样发送// 发送\nServer::sendRawToGroup(&#039;myGroupName&#039;, &#039;数据&#039;);\n\n\n// 发送给多个分组\nServer::sendRawToGroup([&#039;myGroupName1&#039;, &#039;myGroupName2&#039;], &#039;数据&#039;);\n\n// 指定服务名，支持监听多个子服务器的情况\nServer::sendRawToGroup(&#039;myGroupName&#039;, &#039;数据&#039;, &#039;myServer&#039;);\n\n// BASE模式下，只发送给当前 worker 中的所有连接（默认发给所有进程的连接）\nServer::sendRawToGroup(&#039;myGroupName&#039;, &#039;数据&#039;, &#039;myServer&#039;, false);close关闭一个或多个连接Server::close(1); // 关闭 clientId 1\nServer::close([1, 2, 3]); // 关闭 clientId 1、2、3\nServer::close(1, &#039;myServer&#039;); // 指定服务器名\n\n// BASE模式下，只关闭当前 worker 中的连接（默认关闭所有进程的指定连接）\nServer::close(1, &#039;myServer&#039;, false);closeByFlag关闭一个或多个指定标记的连接// 需要有绑定过的连接，才可以使用此方法\n\\Imi\\ConnectionContext::bind(&#039;user1&#039;);\n\nServer::closeByFlag(&#039;user1&#039;); // 关闭 user1\nServer::closeByFlag([&#039;user1&#039;, &#039;user2&#039;]); // 关闭 user1、user2\nServer::closeByFlag(&#039;user1&#039;, &#039;myServer&#039;); // 指定服务器名\n\n// BASE模式下，只关闭当前 worker 中的连接（默认关闭所有进程的指定连接）\nServer::closeByFlag(&#039;user1&#039;, &#039;myServer&#039;, false);exists连接是否存在即便连接存在，也不代表连接 100% 联通，请勿过于依赖此方法。推荐仅在 Local、Gateway 模式使用。如在 Redis、Channel 模式下使用可能获取到的结果不准确。var_dump(Server::exists(123));flagExists指定标记的连接是否存在即便连接存在，也不代表连接 100% 联通，请勿过于依赖此方法。推荐仅在 Local、Gateway 模式使用。如在 Redis、Channel 模式下使用可能获取到的结果不准确。var_dump(Server::flagExists(&#039;user-123&#039;));getConnections获取连接数组。有可能返回的是当前进程管理的连接。$clientIds = Server::getConnections();getConnectionCount获取当前连接数量Swoole 下获取到的是所有 Worker 加起来的连接数，无论是 PROCESS 模式，还是 BASE 模式，imi 做了兼容。Workerman 是获取当前 Worker 连接数Worerman-Gateway 是获取所有连接数$count = Server::getConnectionCount();其它连接上下文的使用：https://doc.imiphp.com/v2.1/components/websocketServer/session.html"},{"id":249,"title":"ServerManage","pageTitle":"ServerManage","url":"utils/ServerManager.html","content":"ServerManage目录类名：Imi\\Server\\ServerManagerimi 支持服务监听多个端口、多个协议，该类用于管理监听端口的服务。可用方法/**\n * 获取服务器数组\n * @return \\Imi\\Swoole\\Server\\Base[]\n */\npublic static function getServers();\n\n/**\n * 获取服务器对象\n * @param string $name\n * @return \\Imi\\Swoole\\Server\\Base\n */\npublic static function getServer($name);$name 参数是在配置文件中，定义的服务器名称。如果是主服务，强制为：main获取 Swoole 服务器对象$swooleServer = ServerManager::getServer(&#039;main&#039;)-&gt;getSwooleServer();"},{"id":45,"title":"SwooleWorker","pageTitle":"SwooleWorker","url":"utils/Swoole.html","content":"SwooleWorker目录v2.x类名: Imi\\Swoole\\SwooleWorker继承: Imi\\Worker (详见：https://doc.imiphp.com/v2.1/utils/Worker.html)方法isTask是否为 task 进程public static function isTask(): boolgetTaskWorkerNum获取 task 进程数量public static function getTaskWorkerNum(): intisWorkerStartAppComplete是否 IMI.MAIN_SERVER.WORKER.START.APP 事件执行完毕public static function isWorkerStartAppComplete(): boolgetManagerPid获取服务器 manager 进程 PIDpublic static function getManagerPid(): intisWorkerIdProcess返回 workerId 是否是用户进程public static function isWorkerIdProcess(int $workerId): bool"},{"id":246,"title":"Text","pageTitle":"Text","url":"utils/Text.html","content":"Text目录类名: Imi\\Util\\Text字符串工具类方法startwith字符串是否以另一个字符串开头// true\nvar_dump(Text::startwith(&#039;http://www.baidu.com&#039;, &#039;http://&#039;));\n\n// false\nvar_dump(Text::startwith(&#039;http://www.baidu.com&#039;, &#039;https://&#039;));\n\n// 不区分大小写-true\nvar_dump(Text::startwith(&#039;http://www.baidu.com&#039;, &#039;HTTP://&#039;, false));endwith字符串是否以另一个字符串结尾// true\nvar_dump(Text::endwith(&#039;http://www.baidu.com/index.html&#039;, &#039;.html&#039;));\n\n// false\nvar_dump(Text::endwith(&#039;http://www.baidu.com/index.html&#039;, &#039;.htm&#039;));\n\n// 不区分大小写-true\nvar_dump(Text::endwith(&#039;http://www.baidu.com/index.html&#039;, &#039;.HTML&#039;));insert插入字符串$str = &#039;abde&#039;;\n// abcde\necho Text::insert($str, 2, &#039;c&#039;), PHP_EOL;isEmpty字符串是否为空字符串或者为null// true\nvar_dump(Text::isEmpty(&#039;&#039;));\n\n// true\nvar_dump(Text::isEmpty(null));\n\n// false\nvar_dump(Text::isEmpty(0));\n\n// false\nvar_dump(Text::isEmpty(&#039;0&#039;));toCamelName转为驼峰命名，会把下划线后字母转为大写// adminUserAge\necho Text::toCamelName(&#039;admin_user_age&#039;), PHP_EOL;toPascalName转为每个单词大写的命名，会把下划线后字母转为大写// AdminUserAge\necho Text::toPascalName(&#039;admin_user_age&#039;), PHP_EOL;toUnderScoreCase转为下划线命名// admin_user_age\necho Text::toUnderScoreCase(&#039;AdminUserAge&#039;), PHP_EOL;\n\n// Admin_User_Age\necho Text::toUnderScoreCase(&#039;AdminUserAge&#039;, false), PHP_EOL;"},{"id":239,"title":"Worker","pageTitle":"Worker","url":"utils/Worker.html","content":"Worker目录类名: Imi\\Worker方法setWorkerHandler设置 Worker 的具体实现类例如 Swoole、Workerman 下的实现类各不相同public static function setWorkerHandler(\\Imi\\Contract\\IWorker $workerHandler): voidgetWorkerHandler获取 Worker 的具体实现类例如 Swoole、Workerman 下的实现类各不相同public static function getWorkerHandler(): \\Imi\\Contract\\IWorkergetWorkerId获取当前 worker 进程的 ID注意，不是进程IDpublic static function getWorkerId(): ?intisInited是否初始化完毕public static function isInited(): boolinited初始化完毕public static function inited(): voidgetWorkerNum获取 Worker 进程数量public static function getWorkerNum(): intgetMasterPid获取服务器 master 进程 PIDpublic static function getMasterPid(): int"}];
var searchDatas = [];
function initSearchDatas()
{
    searchDatas = JSON.parse(JSON.stringify(originSearchDatas));
    for(var i = 0; i < searchDatas.length; ++i)
    {
        if(void 0 !== searchDatas[i].url)
        {
            searchDatas[i].url = rootPath + searchDatas[i].url;
        }
    }
    doSearch($('#search-keyword').val());
}

function filterRegex(r)
{
    return r.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
}

String.prototype.indexOf2 = function(f){
    var rt = this.match(eval('/' + filterRegex(f) + '/i'));
    return (rt == null) ? -1 : rt.index;
}

function switchSearchNode(a)
{
    if ('pushState' in history)
    {
        getChapter(a.attr('href'));
        history.pushState('', '', a.attr('href'));
        $('#treeSearch a').removeClass('curSelectedNode');
        a.addClass('curSelectedNode');
    }
    else
    {
        location = treeNode.url;
    }
}

function searchArticle(keyword)
{
    var keywords = keyword.split(' ');
    var tSearchDatas = searchDatas;
    var result = [];
    keywords.forEach(function(kw){
        if('' === kw)
        {
            return;
        }
        result = [];
        tSearchDatas.forEach(function(item, index){
            var titleIndex = item.title.indexOf2(kw);
            var contentIndex = item.content.indexOf2(kw);
            if(titleIndex > -1 || contentIndex > -1)
            {
                var newItem = JSON.parse(JSON.stringify(item));
                if(titleIndex > -1)
                {
                    newItem.searchedTitle = lightKeyword(newItem.title, kw);
                }
                else
                {
                    newItem.searchedTitle = newItem.title;
                }
                if(contentIndex > -1)
                {
                    var start = contentIndex < 11 ? 0 : contentIndex - 10;
                    var end = start === 0 ? 70 : contentIndex + kw.length + 60;

                    newItem.searchedContent = lightKeyword(newItem.content.substring(start, end), kw);
                }
                else
                {
                    newItem.searchedContent = newItem.content.substring(0, 60);
                }
                newItem.searchedContent = '...' + newItem.searchedContent + '...';
                result.push(newItem);
            }
        });
        tSearchDatas = result;
    });
    return result;
}

function lightKeyword(content, keyword)
{
    return content.replace(new RegExp('(' + filterRegex(keyword) + ')', 'ig'), '<strong>$1</strong>')
}

var searchTimer = null;
function parseSearch()
{
    $('#search-keyword').on('input', function(){
        if(null != searchTimer)
        {
            clearTimeout(searchTimer);
            searchTimer = null;
        }
        var inputKeyword = $(this);
        searchTimer = setTimeout(function(){
            doSearch(inputKeyword.val());
            searchTimer = null;
        }, 200);
        return false;
    });
}

function doSearch(keyword)
{
    var result = searchArticle(keyword);
    if(result.length > 0)
    {
        $('.searchResultNone').hide();
    }
    else
    {
        $('.searchResultNone').show();
    }
    var index = -1;
    $('#treeSearch a').each(function(i, item){
        ++index;
        if($(item).hasClass('curSelectedNode'))
        {
            return false;
        }
    });
    layui.laytpl($('#searchListTemplate').html()).render(result, function(html){
        $('#treeSearch').html(html);
        if(index >= 0)
        {
            var node = $('#treeSearch a').get(index);
            if(null !== node)
            {
                $(node).addClass('curSelectedNode');
            }
        }
    });
}

$(function(){

    $('body').on('click', '#treeSearch a', function(e){
        switchSearchNode($(this));
        return false;
    });

    parseSearch();

})